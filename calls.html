<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="manifest" href="../manifest.json">
    <meta name="theme-color" content="#4F46E5">
    <link rel="icon" href="../icons/moodchat-192.png">
    <link rel="icon" href="../icons/moodchat-512.png">
    <meta name="theme-color" content="#000000">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Calls | Chat App</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- PeerJS for WebRTC -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    
    <!-- Simple Markdown for notes -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        :root {
            --primary-color: #0084ff;
            --secondary-color: #f0f2f5;
            --danger-color: #ff3b30;
            --success-color: #34c759;
            --warning-color: #ff9500;
            --text-primary: #050505;
            --text-secondary: #65676b;
            --bg-color: #ffffff;
            --border-color: #dddfe2;
            --call-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 30px rgba(0, 0, 0, 0.2);
            --video-bg: #1a1a1a;
            --offline-overlay: rgba(255, 255, 255, 0.95);
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }
        
        .app-container {
            display: flex;
            height: 100vh;
            position: relative;
        }
        
        /* Offline Overlay */
        .offline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--offline-overlay);
            z-index: 9999;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            animation: fadeIn 0.3s ease;
        }
        
        .offline-overlay.active {
            display: flex;
        }
        
        .offline-icon {
            font-size: 64px;
            color: var(--text-secondary);
            margin-bottom: 20px;
            opacity: 0.7;
        }
        
        .offline-title {
            font-size: 24px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 10px;
        }
        
        .offline-message {
            font-size: 16px;
            color: var(--text-secondary);
            margin-bottom: 30px;
            max-width: 400px;
            line-height: 1.5;
        }
        
        .offline-submessage {
            font-size: 14px;
            color: var(--text-secondary);
            opacity: 0.8;
            max-width: 400px;
            margin-top: 20px;
            padding: 15px;
            background-color: var(--secondary-color);
            border-radius: 12px;
            border-left: 4px solid var(--warning-color);
        }
        
        .offline-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--warning-color);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: var(--shadow);
            animation: slideInRight 0.3s ease;
            display: none;
        }
        
        .offline-indicator.active {
            display: flex;
        }
        
        /* Sidebar Styles */
        .sidebar {
            width: 380px;
            background-color: var(--bg-color);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            position: relative;
        }
        
        .sidebar-header {
            padding: 20px;
            background: var(--call-gradient);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .sidebar-header h2 {
            font-size: 24px;
            font-weight: 600;
        }
        
        .new-call-btn {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 45px;
            height: 45px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }
        
        .new-call-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .new-call-btn:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .call-categories {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-color);
            flex-shrink: 0;
        }
        
        .category-btn {
            flex: 1;
            padding: 15px;
            text-align: center;
            font-weight: 500;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }
        
        .category-btn.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        
        .category-btn:hover {
            background-color: var(--secondary-color);
        }
        
        .call-list {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .call-list-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .section-title {
            padding: 15px 20px;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            flex-shrink: 0;
        }
        
        .quick-actions {
            padding: 0 20px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-shrink: 0;
        }
        
        .quick-action-btn {
            flex: 1;
            padding: 20px 15px;
            background-color: var(--secondary-color);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            transition: all 0.2s;
            position: relative;
        }
        
        .quick-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .quick-action-btn:hover:not(:disabled) {
            background-color: #e4e6e9;
            transform: translateY(-2px);
        }
        
        .quick-action-icon {
            font-size: 24px;
            color: var(--primary-color);
        }
        
        .quick-action-text {
            font-size: 14px;
            font-weight: 500;
        }
        
        .call-settings {
            padding: 0 20px;
            margin-bottom: 20px;
            flex-shrink: 0;
        }
        
        .settings-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            background-color: var(--secondary-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .settings-toggle:hover {
            background-color: #e4e6e9;
        }
        
        .settings-toggle-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
        }
        
        .settings-toggle-icon {
            font-size: 18px;
            color: var(--primary-color);
        }
        
        .settings-panel {
            background-color: var(--secondary-color);
            border-radius: 12px;
            padding: 20px;
            margin-top: 10px;
            display: none;
        }
        
        .settings-panel.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        .settings-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .settings-item:last-child {
            border-bottom: none;
        }
        
        .settings-item-label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }
        
        .settings-item-icon {
            font-size: 16px;
            color: var(--primary-color);
            width: 24px;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        .recent-calls {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .calls-section {
            display: none;
            flex: 1;
            flex-direction: column;
            overflow: hidden;
        }
        
        .calls-section.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }
        
        .calls-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
            min-height: 200px;
        }
        
        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            color: var(--text-secondary);
            text-align: center;
        }
        
        .empty-state i {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        .empty-state p {
            margin-bottom: 10px;
        }
        
        .empty-state .subtext {
            font-size: 14px;
            margin-top: 10px;
        }
        
        .call-item {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            background-color: var(--bg-color);
            border-radius: 12px;
            margin: 0 20px 10px 20px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        
        .call-item:hover {
            background-color: var(--secondary-color);
            border-color: var(--primary-color);
        }
        
        .call-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: white;
            margin-right: 15px;
            position: relative;
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }
        
        .call-status-icon {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--bg-color);
            font-size: 10px;
        }
        
        .call-status-icon.incoming {
            background-color: var(--success-color);
            color: white;
        }
        
        .call-status-icon.outgoing {
            background-color: var(--primary-color);
            color: white;
        }
        
        .call-status-icon.missed {
            background-color: var(--danger-color);
            color: white;
        }
        
        .call-info {
            flex: 1;
        }
        
        .call-name {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .call-details {
            color: var(--text-secondary);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .call-time {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .call-action-btn {
            background: none;
            border: none;
            color: var(--primary-color);
            cursor: pointer;
            font-size: 18px;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s;
        }
        
        .call-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .call-action-btn:hover:not(:disabled) {
            background-color: var(--secondary-color);
        }
        
        /* Call Container */
        .call-container {
            flex: 1;
            background-color: var(--video-bg);
            position: relative;
            display: none;
            overflow: hidden;
        }
        
        .call-container.active {
            display: flex;
            flex-direction: column;
        }
        
        .call-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 100;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%);
        }
        
        .call-info-bar {
            display: flex;
            align-items: center;
            color: white;
        }
        
        .call-type-icon {
            background: rgba(255, 255, 255, 0.1);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 18px;
            backdrop-filter: blur(10px);
        }
        
        .call-info-text h4 {
            font-size: 17px;
            font-weight: 600;
            margin-bottom: 3px;
        }
        
        .call-info-text p {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .call-duration {
            color: white;
            font-weight: 500;
            font-size: 18px;
        }
        
        /* Video Grid */
        .video-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 10px;
            padding: 20px;
            overflow: auto;
        }
        
        .video-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            background-color: #2a2a2a;
            aspect-ratio: 16/9;
        }
        
        .video-container.large {
            grid-column: span 2;
            grid-row: span 2;
        }
        
        .video-container.pinned {
            border: 3px solid var(--primary-color);
            box-shadow: 0 0 20px rgba(0, 132, 255, 0.5);
        }
        
        .video-element {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        .video-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .video-name {
            font-weight: 500;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .video-status {
            font-size: 12px;
            opacity: 0.8;
        }
        
        .video-actions {
            display: flex;
            gap: 5px;
        }
        
        .video-action-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }
        
        .video-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .video-action-btn.active {
            background-color: var(--primary-color);
        }
        
        .video-action-btn.danger {
            background-color: var(--danger-color);
        }
        
        /* Call Controls */
        .call-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            z-index: 100;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }
        
        .control-btn.active {
            background-color: var(--primary-color);
        }
        
        .control-btn.danger {
            background-color: var(--danger-color);
        }
        
        .control-btn.danger:hover {
            background-color: #ff1a1a;
        }
        
        /* Call Side Panel */
        .call-side-panel {
            width: 300px;
            background-color: var(--bg-color);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            transition: transform 0.3s ease;
        }
        
        .call-side-panel.collapsed {
            transform: translateX(100%);
        }
        
        .panel-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .panel-header h3 {
            font-size: 18px;
            font-weight: 600;
        }
        
        .panel-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }
        
        .panel-tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }
        
        .panel-tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        /* Participants List */
        .participants-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .participant-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: 8px;
            background-color: var(--bg-color);
            transition: all 0.2s;
        }
        
        .participant-item:hover {
            background-color: var(--secondary-color);
        }
        
        .participant-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: white;
            margin-right: 12px;
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }
        
        .participant-info {
            flex: 1;
        }
        
        .participant-name {
            font-weight: 500;
            font-size: 14px;
            margin-bottom: 3px;
        }
        
        .participant-status {
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .participant-status.active {
            color: var(--success-color);
        }
        
        .participant-status.offline {
            color: var(--text-secondary);
        }
        
        .participant-actions {
            display: flex;
            gap: 5px;
        }
        
        /* Chat Panel */
        .chat-messages {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .chat-message {
            padding: 10px 15px;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
        }
        
        .chat-message.sent {
            background-color: var(--primary-color);
            color: white;
            align-self: flex-end;
        }
        
        .chat-message.received {
            background-color: var(--secondary-color);
            align-self: flex-start;
        }
        
        .message-sender {
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 3px;
        }
        
        .message-content {
            font-size: 14px;
        }
        
        .chat-input {
            display: flex;
            gap: 10px;
        }
        
        .chat-input-field {
            flex: 1;
            padding: 12px 15px;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            font-size: 14px;
        }
        
        /* Notes Panel */
        .notes-editor {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .notes-toolbar {
            display: flex;
            gap: 10px;
        }
        
        .notes-btn {
            padding: 8px 12px;
            background-color: var(--secondary-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s;
        }
        
        .notes-btn:hover {
            background-color: #e4e6e9;
        }
        
        .notes-input {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            resize: vertical;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }
        
        .notes-preview {
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--secondary-color);
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        /* Whiteboard Panel */
        .whiteboard-container {
            width: 100%;
            height: 400px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background-color: white;
            margin-bottom: 15px;
        }
        
        .whiteboard-tools {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        /* Poll Panel */
        .poll-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .poll-question {
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--secondary-color);
        }
        
        .poll-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .poll-option {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .poll-option:hover {
            background-color: var(--secondary-color);
        }
        
        .poll-option.selected {
            border-color: var(--primary-color);
            background-color: rgba(0, 132, 255, 0.1);
        }
        
        .poll-option-text {
            flex: 1;
        }
        
        .poll-votes {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        /* Reactions */
        .reactions-container {
            position: absolute;
            bottom: 120px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 50;
        }
        
        .reaction-btn {
            background: rgba(255, 255, 255, 0.9);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .reaction-btn:hover {
            transform: scale(1.1);
        }
        
        /* Floating Reactions Animation */
        .floating-reaction {
            position: absolute;
            font-size: 40px;
            z-index: 1000;
            pointer-events: none;
            animation: floatUp 3s ease-out forwards;
        }
        
        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(0.5);
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) scale(1);
                opacity: 0;
            }
        }
        
        /* Incoming Call Modal */
        .incoming-call-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .incoming-call-modal.active {
            display: flex;
        }
        
        .incoming-call-container {
            width: 90%;
            max-width: 400px;
            background-color: var(--bg-color);
            border-radius: 20px;
            overflow: hidden;
            text-align: center;
            padding: 30px;
            box-shadow: var(--shadow-lg);
        }
        
        .incoming-call-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            color: white;
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }
        
        .incoming-call-name {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .incoming-call-type {
            color: var(--text-secondary);
            margin-bottom: 30px;
        }
        
        .incoming-call-actions {
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        
        /* New Call Modal */
        .new-call-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .new-call-modal.active {
            display: flex;
        }
        
        .new-call-container {
            width: 90%;
            max-width: 500px;
            background-color: var(--bg-color);
            border-radius: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: 90vh;
            box-shadow: var(--shadow-lg);
        }
        
        .new-call-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--call-gradient);
            color: white;
        }
        
        .new-call-header h3 {
            font-size: 20px;
            font-weight: 600;
        }
        
        .new-call-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }
        
        .new-call-tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }
        
        .new-call-tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        
        .new-call-content {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
        }
        
        .contact-search {
            margin-bottom: 20px;
        }
        
        .search-input {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
        }
        
        .contacts-list {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .contact-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .contact-item:hover {
            background-color: var(--secondary-color);
        }
        
        .contact-item.selected {
            background-color: rgba(0, 132, 255, 0.1);
            border: 1px solid var(--primary-color);
        }
        
        .contact-checkbox {
            margin-right: 12px;
        }
        
        .group-call-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .option-item {
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .option-item:hover {
            background-color: var(--secondary-color);
        }
        
        .option-item.selected {
            border-color: var(--primary-color);
            background-color: rgba(0, 132, 255, 0.1);
        }
        
        .option-title {
            font-weight: 600;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .option-desc {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        /* Notification */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--success-color);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
        }
        
        .notification.active {
            transform: translateY(0);
            opacity: 1;
        }
        
        .notification.error {
            background-color: var(--danger-color);
        }
        
        .notification.warning {
            background-color: var(--warning-color);
        }
        
        /* Picture in Picture */
        .pip-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            overflow: hidden;
            background-color: var(--video-bg);
            box-shadow: var(--shadow-lg);
            z-index: 999;
            cursor: move;
            resize: both;
            overflow: hidden;
            display: none;
        }
        
        .pip-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .pip-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            display: flex;
            justify-content: center;
            gap: 5px;
        }
        
        /* Responsive */
        @media (max-width: 1024px) {
            .sidebar {
                width: 350px;
            }
            
            .call-side-panel {
                width: 250px;
            }
        }
        
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 70vh;
                min-height: 500px;
            }
            
            .call-container {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 100;
            }
            
            .call-side-panel {
                position: fixed;
                top: 0;
                right: 0;
                width: 100%;
                height: 100%;
                z-index: 200;
            }
            
            .offline-indicator {
                top: 10px;
                right: 10px;
                font-size: 12px;
                padding: 6px 12px;
            }
            
            /* Fix call history display for mobile */
            .call-list {
                display: flex;
                flex-direction: column;
                flex: 1;
                min-height: 300px;
            }
            
            .recent-calls {
                flex: 1;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }
            
            .calls-section {
                flex: 1;
                display: none;
                flex-direction: column;
                overflow: hidden;
            }
            
            .calls-section.active {
                display: flex;
                animation: fadeIn 0.3s ease;
            }
            
            .calls-list {
                flex: 1;
                overflow-y: auto;
                padding: 10px 0;
                min-height: 250px;
            }
            
            /* Ensure at least 5 call items are visible without scrolling */
            .call-item {
                padding: 12px 20px;
                margin: 0 15px 8px 15px;
            }
            
            .call-avatar {
                width: 45px;
                height: 45px;
                font-size: 16px;
            }
            
            .call-name {
                font-size: 15px;
            }
            
            .call-details {
                font-size: 13px;
            }
            
            .quick-actions {
                padding: 0 15px;
                gap: 10px;
                flex-wrap: wrap;
            }
            
            .quick-action-btn {
                padding: 15px 10px;
                min-width: 100px;
            }
            
            .quick-action-icon {
                font-size: 20px;
            }
            
            .quick-action-text {
                font-size: 13px;
            }
            
            .call-settings {
                padding: 0 15px;
            }
            
            .section-title {
                padding: 15px;
            }
            
            /* Make empty state look good on mobile */
            .empty-state {
                padding: 30px 15px;
            }
            
            .empty-state i {
                font-size: 40px;
            }
        }
        
        /* Animations */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .pulsing {
            animation: pulse 2s infinite;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* Offline-specific styles */
        .call-button-disabled {
            position: relative;
        }
        
        .call-button-disabled::after {
            content: " (Offline)";
            font-size: 12px;
            opacity: 0.8;
        }
        
        .call-list-offline {
            position: relative;
        }
        
        .call-list-offline::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            z-index: 10;
            display: none;
        }
        
        .offline-message-small {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--warning-color);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 11;
            display: none;
            white-space: nowrap;
        }
        
        /* Offline button styles */
        .button-offline {
            position: relative;
        }
        
        .button-offline::after {
            content: " (Offline)";
            font-size: 10px;
            opacity: 0.8;
            color: var(--warning-color);
        }
        
        .offline-warning-text {
            color: var(--warning-color);
            font-size: 11px;
            margin-top: 2px;
            font-weight: normal;
        }
        
        .disabled-by-offline {
            opacity: 0.6;
            cursor: not-allowed;
            position: relative;
        }
        
        .disabled-by-offline::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.5);
            z-index: 1;
            border-radius: inherit;
        }
        
        .disabled-by-offline > * {
            position: relative;
            z-index: 2;
        }
        
        /* Call history offline badge */
        .offline-history-badge {
            display: inline-block;
            background-color: var(--secondary-color);
            color: var(--text-secondary);
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: 8px;
            vertical-align: middle;
        }
        
        /* Offline contacts styling */
        .offline-contacts-message {
            text-align: center;
            padding: 30px 20px;
            color: var(--text-secondary);
        }
        
        .offline-contacts-message i {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        /* Always visible buttons */
        .always-visible {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .button-visible-offline {
            pointer-events: auto !important;
            display: flex !important;
        }
        
        /* Offline call screen placeholder */
        .offline-call-placeholder {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-align: center;
            padding: 40px;
        }
        
        .offline-call-placeholder i {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.7;
        }
        
        .offline-call-placeholder h3 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .offline-call-placeholder p {
            font-size: 16px;
            opacity: 0.8;
            margin-bottom: 30px;
            max-width: 400px;
            line-height: 1.5;
        }
        
        /* Enhanced offline UI states */
        .offline-ui-active .control-btn:not(#endCallBtn) {
            background: rgba(255, 255, 255, 0.05) !important;
        }
        
        .offline-ui-active .control-btn:not(#endCallBtn):hover {
            background: rgba(255, 255, 255, 0.1) !important;
        }
        
        .offline-ui-active .call-controls {
            background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.4) 100%);
        }
        
        .offline-ui-active .call-header {
            background: linear-gradient(to bottom, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.4) 100%);
        }
        
        /* Offline video placeholder */
        .offline-video-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
        }
    </style>
</head>
<body>
    <!-- Offline Overlay -->
    <div class="offline-overlay" id="offlineOverlay">
        <div class="offline-icon">
            <i class="fas fa-wifi-slash"></i>
        </div>
        <div class="offline-title">You're Offline</div>
        <div class="offline-message">Calls require internet connection to work properly.</div>
        <div class="offline-submessage">
            <i class="fas fa-info-circle"></i> You can still view your call history, but making or receiving calls requires an active internet connection.
        </div>
    </div>
    
    <!-- Offline Indicator -->
    <div class="offline-indicator" id="offlineIndicator">
        <i class="fas fa-wifi-slash"></i>
        <span>Offline</span>
    </div>
    
    <div class="app-container">
        <!-- Sidebar with call history -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h2>Calls</h2>
                <button class="new-call-btn always-visible" id="newCallBtn" title="Start new call">
                    <i class="fas fa-phone-alt"></i>
                </button>
            </div>
            
            <div class="call-categories">
                <button class="category-btn active always-visible" id="allTab">All</button>
                <button class="category-btn always-visible" id="missedTab">Missed</button>
                <button class="category-btn always-visible" id="groupsTab">Groups</button>
            </div>
            
            <div class="call-list">
                <div class="quick-actions">
                    <button class="quick-action-btn always-visible button-visible-offline" id="voiceCallBtn" title="Start voice call">
                        <div class="quick-action-icon">
                            <i class="fas fa-phone"></i>
                        </div>
                        <div class="quick-action-text">Voice Call</div>
                    </button>
                    <button class="quick-action-btn always-visible button-visible-offline" id="videoCallBtn" title="Start video call">
                        <div class="quick-action-icon">
                            <i class="fas fa-video"></i>
                        </div>
                        <div class="quick-action-text">Video Call</div>
                    </button>
                    <button class="quick-action-btn always-visible button-visible-offline" id="groupCallBtn" title="Start group call">
                        <div class="quick-action-icon">
                            <i class="fas fa-users"></i>
                        </div>
                        <div class="quick-action-text">Group Call</div>
                    </button>
                </div>
                
                <!-- Call Settings Panel -->
                <div class="call-settings">
                    <div class="settings-toggle always-visible" id="settingsToggle">
                        <div class="settings-toggle-title">
                            <i class="fas fa-cog settings-toggle-icon"></i>
                            <span>Call Settings</span>
                        </div>
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    
                    <div class="settings-panel" id="settingsPanel">
                        <div class="settings-item">
                            <div class="settings-item-label">
                                <i class="fas fa-smile settings-item-icon"></i>
                                <span>Live Reactions</span>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="reactionsToggle" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-label">
                                <i class="fas fa-comment settings-item-icon"></i>
                                <span>In-call Chat</span>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="chatToggle" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-label">
                                <i class="fas fa-paint-brush settings-item-icon"></i>
                                <span>Shared Whiteboard</span>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="whiteboardToggle" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-label">
                                <i class="fas fa-poll settings-item-icon"></i>
                                <span>Polls</span>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="pollsToggle" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-label">
                                <i class="fas fa-sticky-note settings-item-icon"></i>
                                <span>Shared Notes</span>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="notesToggle" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="settings-item">
                            <button class="notes-btn always-visible" id="resetSettingsBtn" style="width: 100%; margin-top: 10px;">
                                <i class="fas fa-undo"></i> Reset to Default Settings
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="recent-calls">
                    <div class="section-title">Recent Calls</div>
                    <div class="call-list-content">
                        <!-- All Calls Section -->
                        <div class="calls-section active" id="allCallsSection">
                            <div class="calls-list" id="allCallsList">
                                <div class="loading-placeholder" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
                                    <i class="fas fa-spinner fa-spin" style="font-size: 24px; margin-bottom: 15px;"></i>
                                    <p>Loading call history...</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Missed Calls Section -->
                        <div class="calls-section" id="missedCallsSection">
                            <div class="calls-list" id="missedCallsList">
                                <!-- Missed calls will be loaded here -->
                            </div>
                        </div>
                        
                        <!-- Group Calls Section -->
                        <div class="calls-section" id="groupCallsSection">
                            <div class="calls-list" id="groupCallsList">
                                <!-- Group calls will be loaded here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Call Container -->
        <div class="call-container" id="callContainer">
            <div class="call-header">
                <div class="call-info-bar">
                    <div class="call-type-icon" id="callTypeIcon">
                        <i class="fas fa-video"></i>
                    </div>
                    <div class="call-info-text">
                        <h4 id="callParticipants">Ready to call</h4>
                        <p id="callStatus">Start a new call or wait for incoming calls</p>
                    </div>
                </div>
                <div class="call-duration" id="callDuration">00:00</div>
            </div>
            
            <div class="video-grid" id="videoGrid">
                <!-- Video streams will be added here -->
                <div class="offline-call-placeholder" id="offlineCallPlaceholder" style="display: none;">
                    <i class="fas fa-wifi-slash"></i>
                    <h3>Offline Mode</h3>
                    <p>You are currently offline. Call features require internet connection.</p>
                    <p style="font-size: 14px; opacity: 0.6;">All call controls remain visible for exploration.</p>
                </div>
            </div>
            
            <div class="reactions-container always-visible" id="reactionsContainer">
                <div class="reaction-btn always-visible" data-reaction=""></div>
                <div class="reaction-btn always-visible" data-reaction=""></div>
                <div class="reaction-btn always-visible" data-reaction=""></div>
                <div class="reaction-btn always-visible" data-reaction=""></div>
                <div class="reaction-btn always-visible" data-reaction=""></div>
            </div>
            
            <div class="call-controls always-visible">
                <button class="control-btn always-visible" id="muteBtn" title="Mute">
                    <i class="fas fa-microphone"></i>
                </button>
                <button class="control-btn always-visible" id="videoBtn" title="Video">
                    <i class="fas fa-video"></i>
                </button>
                <button class="control-btn always-visible" id="speakerBtn" title="Speaker">
                    <i class="fas fa-volume-up"></i>
                </button>
                <button class="control-btn always-visible" id="screenShareBtn" title="Share Screen">
                    <i class="fas fa-desktop"></i>
                </button>
                <button class="control-btn always-visible" id="effectsBtn" title="Effects">
                    <i class="fas fa-magic"></i>
                </button>
                <button class="control-btn always-visible" id="moreBtn" title="More Options">
                    <i class="fas fa-ellipsis-h"></i>
                </button>
                <button class="control-btn danger always-visible" id="endCallBtn" title="End Call">
                    <i class="fas fa-phone-slash"></i>
                </button>
            </div>
        </div>
        
        <!-- Call Side Panel -->
        <div class="call-side-panel collapsed always-visible" id="callSidePanel">
            <div class="panel-header">
                <h3 id="panelTitle">Call Controls</h3>
                <button class="call-action-btn always-visible" id="closePanelBtn">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="panel-tabs always-visible" id="panelTabs">
                <button class="panel-tab active always-visible" data-panel="participants">Participants</button>
                <button class="panel-tab always-visible" data-panel="chat">Chat</button>
                <button class="panel-tab always-visible" data-panel="whiteboard">Whiteboard</button>
                <button class="panel-tab always-visible" data-panel="notes">Notes</button>
                <button class="panel-tab always-visible" data-panel="polls">Polls</button>
            </div>
            
            <div class="panel-content" id="panelContent">
                <!-- Participants Panel -->
                <div class="panel-section active" id="participantsPanel">
                    <div class="participants-list" id="participantsList">
                        <!-- Participants will be listed here -->
                    </div>
                    <div style="margin-top: 20px;">
                        <button class="notes-btn always-visible" id="addParticipantsBtn" style="width: 100%;">
                            <i class="fas fa-user-plus"></i> Add Participants
                        </button>
                    </div>
                </div>
                
                <!-- Chat Panel -->
                <div class="panel-section" id="chatPanel">
                    <div class="chat-messages" id="chatMessages">
                        <!-- Chat messages will be shown here -->
                    </div>
                    <div class="chat-input always-visible">
                        <input type="text" class="chat-input-field always-visible" id="chatInput" placeholder="Type a message...">
                        <button class="video-action-btn always-visible" id="sendChatBtn">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Whiteboard Panel -->
                <div class="panel-section" id="whiteboardPanel">
                    <div class="whiteboard-container always-visible">
                        <canvas id="whiteboardCanvas"></canvas>
                    </div>
                    <div class="whiteboard-tools always-visible">
                        <button class="notes-btn always-visible" data-tool="pencil">
                            <i class="fas fa-pencil-alt"></i> Pencil
                        </button>
                        <button class="notes-btn always-visible" data-tool="line">
                            <i class="fas fa-minus"></i> Line
                        </button>
                        <button class="notes-btn always-visible" data-tool="rectangle">
                            <i class="fas fa-square"></i> Rectangle
                        </button>
                        <button class="notes-btn always-visible" data-tool="circle">
                            <i class="fas fa-circle"></i> Circle
                        </button>
                        <button class="notes-btn always-visible" data-tool="text">
                            <i class="fas fa-font"></i> Text
                        </button>
                        <button class="notes-btn always-visible" id="clearWhiteboardBtn">
                            <i class="fas fa-trash"></i> Clear
                        </button>
                    </div>
                </div>
                
                <!-- Notes Panel -->
                <div class="panel-section" id="notesPanel">
                    <div class="notes-editor">
                        <div class="notes-toolbar always-visible">
                            <button class="notes-btn always-visible" id="saveNoteBtn">
                                <i class="fas fa-save"></i> Save
                            </button>
                            <button class="notes-btn always-visible" id="shareNoteBtn">
                                <i class="fas fa-share"></i> Share
                            </button>
                            <button class="notes-btn always-visible" id="loadNotesBtn">
                                <i class="fas fa-history"></i> Load Previous
                            </button>
                        </div>
                        <textarea class="notes-input always-visible" id="notesInput" placeholder="Take notes during the call..."></textarea>
                        <div class="notes-preview always-visible" id="notesPreview">
                            <!-- Notes preview will appear here -->
                        </div>
                    </div>
                </div>
                
                <!-- Polls Panel -->
                <div class="panel-section" id="pollsPanel">
                    <div class="poll-container">
                        <div id="activePoll">
                            <!-- Active poll will be shown here -->
                        </div>
                        <div style="margin-top: 20px;">
                            <button class="notes-btn always-visible" id="createPollBtn" style="width: 100%;">
                                <i class="fas fa-plus"></i> Create New Poll
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- New Call Modal -->
    <div class="new-call-modal" id="newCallModal">
        <div class="new-call-container">
            <div class="new-call-header">
                <h3>Start New Call</h3>
                <button class="new-call-btn always-visible" id="closeNewCallModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="new-call-tabs always-visible">
                <button class="new-call-tab active always-visible" data-tab="contacts">Contacts</button>
                <button class="new-call-tab always-visible" data-tab="group">Group Call</button>
                <button class="new-call-tab always-visible" data-tab="link">Call Link</button>
            </div>
            
            <div class="new-call-content">
                <!-- Contacts Tab -->
                <div class="new-call-tab-content active" id="contactsTab">
                    <div class="contact-search">
                        <input type="text" class="search-input always-visible" id="contactSearch" placeholder="Search contacts...">
                    </div>
                    <div class="contacts-list" id="contactsList">
                        <!-- Contacts will be loaded here -->
                    </div>
                </div>
                
                <!-- Group Call Tab -->
                <div class="new-call-tab-content" id="groupTab">
                    <div class="group-call-options">
                        <div class="option-item always-visible" data-type="instant">
                            <div class="option-title">
                                <i class="fas fa-bolt"></i> Instant Group Call
                            </div>
                            <div class="option-desc">Start a call and add participants as you go</div>
                        </div>
                        <div class="option-item always-visible" data-type="scheduled">
                            <div class="option-title">
                                <i class="fas fa-calendar"></i> Schedule Group Call
                            </div>
                            <div class="option-desc">Schedule a call for later and send invites</div>
                        </div>
                    </div>
                    <div style="margin-top: 20px;">
                        <h4 style="margin-bottom: 10px;">Select Participants</h4>
                        <div class="contacts-list" id="groupContactsList">
                            <!-- Group contacts will be loaded here -->
                        </div>
                    </div>
                </div>
                
                <!-- Call Link Tab -->
                <div class="new-call-tab-content" id="linkTab">
                    <div style="text-align: center; padding: 30px 0;">
                        <div style="font-size: 48px; margin-bottom: 20px; color: var(--primary-color);">
                            <i class="fas fa-link"></i>
                        </div>
                        <h3 style="margin-bottom: 10px;">Create Call Link</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px;">
                            Create a shareable link for anyone to join your call
                        </p>
                        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                            <button class="notes-btn always-visible" id="createVoiceLinkBtn">
                                <i class="fas fa-phone"></i> Voice Call Link
                            </button>
                            <button class="notes-btn always-visible" id="createVideoLinkBtn">
                                <i class="fas fa-video"></i> Video Call Link
                            </button>
                        </div>
                        <div id="callLinkContainer" style="display: none;">
                            <div style="margin-bottom: 15px;">
                                <input type="text" id="callLinkInput" readonly style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 8px;">
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button class="notes-btn always-visible" id="copyLinkBtn">
                                    <i class="fas fa-copy"></i> Copy Link
                                </button>
                                <button class="notes-btn always-visible" id="shareLinkBtn">
                                    <i class="fas fa-share"></i> Share
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div style="padding: 20px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between;">
                <button class="notes-btn always-visible" id="cancelNewCallBtn">Cancel</button>
                <button class="notes-btn always-visible" id="startCallBtn" style="background-color: var(--primary-color); color: white;">Start Call</button>
            </div>
        </div>
    </div>
    
    <!-- Incoming Call Modal -->
    <div class="incoming-call-modal" id="incomingCallModal">
        <div class="incoming-call-container">
            <div class="incoming-call-avatar" id="incomingCallAvatar">
                <i class="fas fa-user"></i>
            </div>
            <div class="incoming-call-name" id="incomingCallName">John Doe</div>
            <div class="incoming-call-type" id="incomingCallType">Incoming Video Call</div>
            <div class="incoming-call-actions">
                <button class="control-btn danger pulsing always-visible" id="declineCallBtn">
                    <i class="fas fa-phone-slash"></i>
                </button>
                <button class="control-btn active pulsing always-visible" id="acceptCallBtn">
                    <i class="fas fa-phone"></i>
                </button>
                <button class="control-btn always-visible" id="acceptVideoCallBtn">
                    <i class="fas fa-video"></i>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Notification -->
    <div class="notification" id="notification">
        <i class="fas fa-check-circle"></i>
        <span id="notificationText">Operation completed successfully</span>
    </div>
    
    <!-- Picture in Picture Container -->
    <div class="pip-container" id="pipContainer">
        <video class="pip-video" id="pipVideo" autoplay muted></video>
        <div class="pip-controls">
            <button class="video-action-btn always-visible" id="pipExpandBtn">
                <i class="fas fa-expand"></i>
            </button>
            <button class="video-action-btn danger always-visible" id="pipEndBtn">
                <i class="fas fa-phone-slash"></i>
            </button>
        </div>
    </div>

    <script>
        // Enhanced Firebase Configuration with offline support
        const firebaseConfig = {
            apiKey: "AIzaSyDHHyGgsSV18BcXrGgzi4C8frzDAE1C1zo",
            authDomain: "uniconnect-ee95c.firebaseapp.com",
            projectId: "uniconnect-ee95c",
            storageBucket: "uniconnect-ee95c.firebasestorage.app",
            messagingSenderId: "1003264444309",
            appId: "1:1003264444309:web:9f0307516e44d21e97d89c"
        };
        
        // Initialize Firebase
        let firebaseApp;
        let db;
        let auth;
        let rtdb;
        
        try {
            firebaseApp = firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            auth = firebase.auth();
            rtdb = firebase.database();
            
            // Enable offline persistence
            db.enablePersistence().catch((err) => {
                console.log("Firebase persistence error:", err);
            });
        } catch (error) {
            console.log("Firebase initialization error (may be offline):", error);
        }
        
        // Global variables
        let currentUser = null;
        let peer = null;
        let localStream = null;
        let remoteStreams = new Map();
        let currentCall = null;
        let callStartTime = null;
        let callInterval = null;
        let isMuted = false;
        let isVideoOff = false;
        let isSpeakerOn = false;
        let isScreenSharing = false;
        let currentCallType = null;
        let callParticipants = [];
        let selectedContacts = [];
        let whiteboardCanvas = null;
        let whiteboardCtx = null;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentTool = 'pencil';
        let callLink = null;
        let activeCalls = new Map();
        let userPresenceRef = null;
        let dataConnections = new Map();
        let reactionsChannel = null;
        let chatChannel = null;
        
        // Offline state management - FEATURE 1: Detect offline state
        let isOnline = navigator.onLine;
        let offlineCheckInterval = null;
        
        // User settings with default values
        let userSettings = {
            reactions: true,
            chat: true,
            whiteboard: true,
            polls: true,
            notes: true
        };
        
        // Default settings (for reset functionality)
        const defaultSettings = {
            reactions: true,
            chat: true,
            whiteboard: true,
            polls: true,
            notes: true
        };
        
        // DOM Elements
        const callContainer = document.getElementById('callContainer');
        const callSidePanel = document.getElementById('callSidePanel');
        const newCallModal = document.getElementById('newCallModal');
        const incomingCallModal = document.getElementById('incomingCallModal');
        const videoGrid = document.getElementById('videoGrid');
        const notification = document.getElementById('notification');
        const pipContainer = document.getElementById('pipContainer');
        const settingsPanel = document.getElementById('settingsPanel');
        const settingsToggle = document.getElementById('settingsToggle');
        const offlineOverlay = document.getElementById('offlineOverlay');
        const offlineIndicator = document.getElementById('offlineIndicator');
        const offlineCallPlaceholder = document.getElementById('offlineCallPlaceholder');
        
        // Call sections
        const allCallsSection = document.getElementById('allCallsSection');
        const missedCallsSection = document.getElementById('missedCallsSection');
        const groupCallsSection = document.getElementById('groupCallsSection');
        const allCallsList = document.getElementById('allCallsList');
        const missedCallsList = document.getElementById('missedCallsList');
        const groupCallsList = document.getElementById('groupCallsList');
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });
        
        async function initializeApp() {
            // FEATURE 1: Initialize offline detection
            initializeOfflineDetection();
            
            // FEATURE 5: Detect logged-in user via app.js (or Firebase auth)
            // First try to get user from localStorage for immediate UI
            const cachedUser = localStorage.getItem('currentUser');
            if (cachedUser) {
                try {
                    currentUser = JSON.parse(cachedUser);
                    console.log('Using cached user:', currentUser.uid);
                    
                    // Initialize UI immediately with cached user
                    await initializeUser();
                    await loadUserSettings();
                    setupEventListeners();
                    initializeWhiteboard();
                    
                    // Load calls from local storage immediately (fast)
                    loadCallsFromLocalStorage();
                    
                    // Show UI
                    fixMobileLayout();
                    
                    // Listen for external calls from friends.html
                    listenForExternalCalls();
                    
                    // Update UI for offline/online state
                    updateUIForConnectivity();
                    
                } catch (error) {
                    console.error('Error with cached user:', error);
                }
            }
            
            // Then try Firebase auth (works online/offline)
            if (auth) {
                auth.onAuthStateChanged(async user => {
                    if (user) {
                        currentUser = user;
                        console.log('User detected via Firebase:', currentUser.uid);
                        
                        // Cache user for offline use
                        localStorage.setItem('currentUser', JSON.stringify({
                            uid: user.uid,
                            displayName: user.displayName,
                            email: user.email,
                            photoURL: user.photoURL
                        }));
                        
                        await initializeUser();
                        await loadUserSettings();
                        setupEventListeners();
                        initializeWhiteboard();
                        
                        // FEATURE 1 & 2: Load calls from local storage when offline
                        if (isOnline) {
                            loadAllCalls();
                            setupPresenceTracking();
                            
                            // FEATURE 5: Only initialize PeerJS if online
                            setTimeout(() => {
                                initializePeerJS();
                            }, 1000);
                        } else {
                            console.log('Offline: Loading call history from local storage');
                            loadCallsFromLocalStorage();
                            showNotification('Offline: Call features unavailable', 'warning');
                        }
                        
                        // Listen for incoming calls from friends.html
                        listenForExternalCalls();
                        
                        // Fix mobile layout on load
                        setTimeout(fixMobileLayout, 100);
                        
                        // Update UI for connectivity state
                        updateUIForConnectivity();
                        
                    } else if (!currentUser) {
                        console.log('No user detected, redirecting to login');
                        // Check if we're in the app.js context
                        if (typeof window !== 'undefined' && window.location.pathname.includes('calls.html')) {
                            window.location.href = 'index.html';
                        }
                    }
                });
            } else {
                // If Firebase fails (offline), use cached user
                if (!currentUser) {
                    console.log('No user available, showing login redirect');
                    showNotification('Please login to continue', 'error');
                }
            }
        }
        
        function fixMobileLayout() {
            if (window.innerWidth <= 768) {
                // Ensure sections display properly on mobile
                const activeSection = document.querySelector('.calls-section.active');
                if (activeSection) {
                    activeSection.style.display = 'flex';
                    activeSection.style.flex = '1';
                }
                
                // Ensure call list is visible
                const callsList = document.querySelector('.calls-list');
                if (callsList) {
                    callsList.style.display = 'flex';
                    callsList.style.flexDirection = 'column';
                    callsList.style.minHeight = '250px';
                }
                
                // Adjust sidebar height for better visibility
                const sidebar = document.querySelector('.sidebar');
                if (sidebar) {
                    const windowHeight = window.innerHeight;
                    const availableHeight = Math.min(windowHeight * 0.7, windowHeight - 100);
                    sidebar.style.maxHeight = availableHeight + 'px';
                }
            }
        }
        
        function initializeOfflineDetection() {
            // Check initial online status
            updateOnlineStatus();
            
            // Listen for online/offline events
            window.addEventListener('online', handleOnline);
            window.addEventListener('offline', handleOffline);
            
            // Start periodic connectivity check
            offlineCheckInterval = setInterval(checkConnectivity, 30000);
            
            // Initial UI update - FEATURE 2: Show "Calls require internet" message
            updateUIForConnectivity();
            
            // Ensure all buttons are visible
            ensureButtonsVisible();
        }
        
        function ensureButtonsVisible() {
            // Make sure all buttons are visible regardless of online status
            const allButtons = document.querySelectorAll('button, .quick-action-btn, .call-action-btn, .control-btn, .video-action-btn, .notes-btn, .panel-tab, .new-call-tab, .category-btn, .reaction-btn');
            allButtons.forEach(button => {
                button.classList.add('always-visible');
                button.style.display = 'flex';
                button.style.visibility = 'visible';
                button.style.opacity = '1';
            });
            
            // Make sure call history sections are visible
            const callSections = document.querySelectorAll('.calls-section, .call-list, .call-item');
            callSections.forEach(section => {
                section.classList.add('always-visible');
                section.style.display = 'flex';
            });
            
            // Ensure call container UI elements are visible
            const callUIElements = document.querySelectorAll('.call-controls, .call-header, .reactions-container, .video-grid');
            callUIElements.forEach(element => {
                element.classList.add('always-visible');
            });
        }
        
        function updateOnlineStatus() {
            isOnline = navigator.onLine;
            console.log('Network status:', isOnline ? 'Online' : 'Offline');
        }
        
        function handleOnline() {
            console.log('App is now online');
            isOnline = true;
            updateUIForConnectivity();
            
            // FEATURE 5: Try to reinitialize PeerJS when network is restored
            if (!peer && currentUser) {
                setTimeout(() => {
                    initializePeerJS();
                }, 1000);
            }
            
            // Show notification
            showNotification('You are back online', 'success');
            
            // Update user presence
            if (userPresenceRef && currentUser) {
                userPresenceRef.update({
                    online: true,
                    lastOnline: firebase.firestore.FieldValue.serverTimestamp()
                });
            }
            
            // Reload calls data from server
            loadAllCalls();
            
            // Ensure buttons are visible
            ensureButtonsVisible();
            
            // Remove offline UI state
            callContainer.classList.remove('offline-ui-active');
            
            // Hide offline placeholder if showing
            if (offlineCallPlaceholder.style.display !== 'none') {
                offlineCallPlaceholder.style.display = 'none';
            }
        }
        
        function handleOffline() {
            console.log('App is now offline');
            isOnline = false;
            updateUIForConnectivity();
            
            // FEATURE 2: Show "Calls require internet" message
            showNotification('You are offline. Calls require internet connection.', 'warning');
            
            // End any active calls gracefully
            if (currentCall) {
                endCall();
            }
            
            // Update user presence
            if (userPresenceRef && currentUser) {
                userPresenceRef.update({
                    online: false,
                    lastOnline: firebase.firestore.FieldValue.serverTimestamp()
                });
            }
            
            // FEATURE 1: Load calls from local storage when offline
            loadCallsFromLocalStorage();
            
            // Ensure buttons are visible
            ensureButtonsVisible();
            
            // Add offline UI state for visual indication
            callContainer.classList.add('offline-ui-active');
            
            // Show offline placeholder in video grid if call container is active
            if (callContainer.classList.contains('active')) {
                offlineCallPlaceholder.style.display = 'flex';
            }
        }
        
        function checkConnectivity() {
            // Simple connectivity check by trying to fetch a small resource
            fetch('https://www.google.com/favicon.ico', { 
                mode: 'no-cors',
                cache: 'no-cache'
            })
            .then(() => {
                if (!isOnline) {
                    console.log('Connectivity check passed - switching to online');
                    handleOnline();
                }
            })
            .catch(() => {
                if (isOnline) {
                    console.log('Connectivity check failed - switching to offline');
                    handleOffline();
                }
            });
        }
        
        function updateUIForConnectivity() {
            if (!isOnline) {
                // Show offline overlay - FEATURE 2
                offlineOverlay.classList.add('active');
                offlineIndicator.classList.add('active');
                
                // FEATURE 4: Disable call buttons when offline (but keep them visible)
                const callButtons = [
                    'newCallBtn',
                    'voiceCallBtn',
                    'videoCallBtn',
                    'groupCallBtn',
                    'startCallBtn',
                    'createVoiceLinkBtn',
                    'createVideoLinkBtn',
                    'addParticipantsBtn'
                ];
                
                callButtons.forEach(buttonId => {
                    const button = document.getElementById(buttonId);
                    if (button) {
                        button.disabled = true;
                        button.title = 'Calls require internet connection';
                        button.classList.add('disabled-by-offline');
                        // Still keep it visible
                        button.classList.add('always-visible');
                        button.style.display = 'flex';
                    }
                });
                
                // Update button texts to indicate offline - FEATURE 2
                const quickActionButtons = document.querySelectorAll('.quick-action-btn');
                quickActionButtons.forEach(button => {
                    if (button.disabled) {
                        const textElement = button.querySelector('.quick-action-text');
                        if (textElement) {
                            const originalText = textElement.getAttribute('data-original-text') || textElement.textContent;
                            textElement.innerHTML = originalText + '<div class="offline-warning-text">(Offline)</div>';
                        }
                    }
                });
                
                // Disable call-back buttons in call history
                const callbackButtons = document.querySelectorAll('.call-action-btn');
                callbackButtons.forEach(button => {
                    button.disabled = true;
                    button.title = 'Calls require internet connection';
                    button.classList.add('disabled-by-offline');
                    // Still keep it visible
                    button.classList.add('always-visible');
                });
                
                // Disable contact checkboxes in new call modal
                const contactCheckboxes = document.querySelectorAll('.contact-checkbox');
                contactCheckboxes.forEach(checkbox => {
                    checkbox.disabled = true;
                });
                
                // Close new call modal if open
                if (newCallModal.classList.contains('active')) {
                    newCallModal.classList.remove('active');
                    showNotification('Cannot start call while offline', 'error');
                }
                
                // Close incoming call modal if open
                if (incomingCallModal.classList.contains('active')) {
                    incomingCallModal.classList.remove('active');
                    showNotification('Cannot accept calls while offline', 'error');
                }
                
                // Disable panel tabs that require internet (but keep visible)
                const panelTabs = document.querySelectorAll('.panel-tab');
                panelTabs.forEach(tab => {
                    if (tab.dataset.panel !== 'participants') {
                        tab.disabled = true;
                        tab.title = 'Feature unavailable offline';
                        // Still keep it visible
                        tab.classList.add('always-visible');
                    }
                });
                
                // Ensure all UI elements are visible
                ensureButtonsVisible();
                
                // Update call status to show offline state
                if (callContainer.classList.contains('active')) {
                    document.getElementById('callParticipants').textContent = 'Offline Mode';
                    document.getElementById('callStatus').textContent = 'Call features unavailable without internet';
                    offlineCallPlaceholder.style.display = 'flex';
                }
                
            } else {
                // Hide offline overlay
                offlineOverlay.classList.remove('active');
                offlineIndicator.classList.remove('active');
                
                // FEATURE 4: Enable call buttons when online
                const callButtons = [
                    'newCallBtn',
                    'voiceCallBtn',
                    'videoCallBtn',
                    'groupCallBtn',
                    'startCallBtn',
                    'createVoiceLinkBtn',
                    'createVideoLinkBtn',
                    'addParticipantsBtn'
                ];
                
                callButtons.forEach(buttonId => {
                    const button = document.getElementById(buttonId);
                    if (button) {
                        button.disabled = false;
                        button.title = button.getAttribute('data-original-title') || '';
                        button.classList.remove('disabled-by-offline');
                        button.classList.add('always-visible');
                    }
                });
                
                // Restore original button texts
                const quickActionButtons = document.querySelectorAll('.quick-action-btn');
                quickActionButtons.forEach(button => {
                    const textElement = button.querySelector('.quick-action-text');
                    if (textElement) {
                        const originalText = textElement.getAttribute('data-original-text') || textElement.textContent;
                        textElement.innerHTML = originalText;
                    }
                });
                
                // Enable call-back buttons in call history
                const callbackButtons = document.querySelectorAll('.call-action-btn');
                callbackButtons.forEach(button => {
                    button.disabled = false;
                    button.title = 'Call Back';
                    button.classList.remove('disabled-by-offline');
                    button.classList.add('always-visible');
                });
                
                // Enable contact checkboxes
                const contactCheckboxes = document.querySelectorAll('.contact-checkbox');
                contactCheckboxes.forEach(checkbox => {
                    checkbox.disabled = false;
                });
                
                // Enable panel tabs
                const panelTabs = document.querySelectorAll('.panel-tab');
                panelTabs.forEach(tab => {
                    tab.disabled = false;
                    tab.title = '';
                    tab.classList.add('always-visible');
                });
                
                // Ensure all UI elements are visible
                ensureButtonsVisible();
                
                // Remove offline UI state
                callContainer.classList.remove('offline-ui-active');
                
                // Hide offline placeholder
                offlineCallPlaceholder.style.display = 'none';
                
                // Update call status if in call
                if (callContainer.classList.contains('active') && !currentCall) {
                    document.getElementById('callParticipants').textContent = 'Ready to call';
                    document.getElementById('callStatus').textContent = 'Start a new call or wait for incoming calls';
                }
            }
        }
        
        // FEATURE 1: Enhanced localStorage management for calls
        function getLocalStorageKey(key) {
            return currentUser ? `calls_${currentUser.uid}_${key}` : `calls_${key}`;
        }
        
        // FEATURE 1: Save calls to local storage with better structure
        function saveCallToLocalStorage(callData) {
            try {
                if (!currentUser) return;
                
                const storageKey = getLocalStorageKey('history');
                const storedCalls = localStorage.getItem(storageKey);
                let calls = [];
                
                if (storedCalls) {
                    calls = JSON.parse(storedCalls);
                }
                
                // Add new call with unique ID
                const callWithId = {
                    ...callData,
                    id: `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    savedAt: new Date().toISOString(),
                    isLocal: true
                };
                
                // Remove any existing call with same ID
                calls = calls.filter(call => call.id !== callWithId.id);
                
                // Add new call to beginning
                calls.unshift(callWithId);
                
                // Keep only last 100 calls
                if (calls.length > 100) {
                    calls = calls.slice(0, 100);
                }
                
                localStorage.setItem(storageKey, JSON.stringify(calls));
                console.log('Call saved to local storage:', callWithId.id);
                
                // Update UI if we're on the calls page
                if (window.location.pathname.includes('calls.html')) {
                    loadCallsFromLocalStorage();
                }
                
                return callWithId.id;
                
            } catch (error) {
                console.error('Error saving call to local storage:', error);
                return null;
            }
        }
        
        // FEATURE 1: Load calls from local storage with better error handling
        function loadCallsFromLocalStorage() {
            console.log('Loading calls from local storage (offline mode)');
            
            try {
                if (!currentUser) {
                    console.log('No user, cannot load calls');
                    return;
                }
                
                const storageKey = getLocalStorageKey('history');
                const storedCalls = localStorage.getItem(storageKey);
                let calls = [];
                
                if (storedCalls) {
                    calls = JSON.parse(storedCalls);
                    console.log(`Loaded ${calls.length} calls from local storage`);
                } else {
                    console.log('No calls found in local storage');
                    // Create some sample data for demo purposes
                    calls = generateSampleCalls();
                    localStorage.setItem(storageKey, JSON.stringify(calls));
                }
                
                // Display calls in all sections
                displayCallsFromArray(calls, allCallsList, 'all');
                
                // Filter and display missed calls
                const missedCalls = calls.filter(call => call.status === 'missed');
                displayCallsFromArray(missedCalls, missedCallsList, 'missed');
                
                // Filter and display group calls
                const groupCalls = calls.filter(call => call.group === true || (call.participants && call.participants.length > 2));
                displayCallsFromArray(groupCalls, groupCallsList, 'group');
                
                // Add offline badge to section title if offline
                if (!isOnline) {
                    const sectionTitle = document.querySelector('.section-title');
                    if (sectionTitle && !sectionTitle.querySelector('.offline-history-badge')) {
                        const badge = document.createElement('span');
                        badge.className = 'offline-history-badge';
                        badge.textContent = 'Offline';
                        sectionTitle.appendChild(badge);
                    }
                }
                
            } catch (error) {
                console.error('Error loading calls from local storage:', error);
                showNotification('Failed to load offline call history', 'error');
            }
        }
        
        // Generate sample calls for demo purposes
        function generateSampleCalls() {
            const sampleCalls = [];
            const now = new Date();
            
            // Add some sample calls
            const sampleParticipants = ['user1', 'user2', 'user3'];
            const sampleNames = ['John Doe', 'Jane Smith', 'Mike Johnson', 'Sarah Wilson', 'Alex Brown'];
            
            for (let i = 0; i < 5; i++) {
                const callDate = new Date(now.getTime() - (i * 3600000 * 24)); // 1 day apart
                const isMissed = i === 1;
                const isGroup = i === 4;
                
                sampleCalls.push({
                    id: `sample_${i}`,
                    participants: isGroup ? ['user1', 'user2', 'user3'] : ['user1', sampleParticipants[i % 3]],
                    initiator: i % 2 === 0 ? 'user1' : sampleParticipants[i % 3],
                    type: i % 2 === 0 ? 'video' : 'voice',
                    status: isMissed ? 'missed' : 'completed',
                    timestamp: callDate.toISOString(),
                    savedAt: callDate.toISOString(),
                    duration: isMissed ? 0 : Math.floor(Math.random() * 600) + 30,
                    group: isGroup,
                    isLocal: true,
                    displayName: isGroup ? 'Group Call (3)' : sampleNames[i]
                });
            }
            
            return sampleCalls;
        }
        
        // FEATURE 1: Display calls from array (enhanced for offline mode)
        function displayCallsFromArray(callsArray, container, type) {
            if (!container) return;
            
            if (!callsArray || callsArray.length === 0) {
                let emptyMessage = '';
                switch(type) {
                    case 'missed':
                        emptyMessage = `
                            <div class="empty-state always-visible">
                                <i class="fas fa-phone-slash"></i>
                                <p>No missed calls</p>
                                <p class="subtext">All calls have been answered</p>
                            </div>
                        `;
                        break;
                    case 'group':
                        emptyMessage = `
                            <div class="empty-state always-visible">
                                <i class="fas fa-users"></i>
                                <p>No group calls</p>
                                <p class="subtext">Start your first group call</p>
                            </div>
                        `;
                        break;
                    default:
                        emptyMessage = `
                            <div class="empty-state always-visible">
                                <i class="fas fa-phone"></i>
                                <p>No recent calls</p>
                                <p class="subtext">Start your first call with the button above</p>
                            </div>
                        `;
                }
                container.innerHTML = emptyMessage;
                return;
            }
            
            container.innerHTML = '';
            
            // Process each call
            callsArray.forEach(callData => {
                displayCallItemFromData(callData, container);
            });
            
            // Ensure at least 5 items are visible without scrolling
            const callItems = container.querySelectorAll('.call-item');
            if (callItems.length > 0) {
                // Calculate height needed for 5 items
                const itemHeight = callItems[0].offsetHeight || 80;
                const minHeight = itemHeight * Math.min(5, callItems.length);
                container.style.minHeight = minHeight + 'px';
            }
            
            // Ensure all items are visible
            callItems.forEach(item => {
                item.classList.add('always-visible');
                item.style.display = 'flex';
            });
        }
        
        // FEATURE 1: Display call item from data (enhanced for offline mode)
        function displayCallItemFromData(callData, container) {
            let displayName = callData.displayName || 'Unknown';
            let otherParticipantIds = [];
            
            if (callData.participants) {
                otherParticipantIds = callData.participants.filter(id => 
                    id !== (currentUser ? currentUser.uid : 'user1')
                );
                
                if (!displayName || displayName === 'Unknown') {
                    if (otherParticipantIds.length === 1) {
                        // Try to get name from local storage
                        const contactName = localStorage.getItem(`contact_${otherParticipantIds[0]}_name`);
                        displayName = contactName || 'Unknown';
                    } else if (otherParticipantIds.length > 1) {
                        displayName = `Group Call (${callData.participants.length})`;
                    }
                }
            }
            
            const isGroupCall = callData.group === true || (callData.participants && callData.participants.length > 2);
            const callType = callData.type || 'voice';
            const callStatus = callData.status || 'completed';
            const isMissed = callStatus === 'missed';
            const isOutgoing = callData.initiator === (currentUser ? currentUser.uid : 'user1');
            
            let callTime = 'Recently';
            if (callData.timestamp) {
                const timestamp = typeof callData.timestamp === 'string' ? 
                    new Date(callData.timestamp) : 
                    (callData.timestamp.toDate ? callData.timestamp.toDate() : new Date(callData.timestamp));
                callTime = formatTimeAgo(timestamp);
            } else if (callData.savedAt) {
                callTime = formatTimeAgo(new Date(callData.savedAt));
            }
            
            let durationText = '';
            if (callData.duration && callData.duration > 0) {
                const minutes = Math.floor(callData.duration / 60);
                const seconds = callData.duration % 60;
                durationText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            const callItem = document.createElement('div');
            callItem.className = 'call-item always-visible';
            callItem.dataset.callId = callData.id || `local_${Date.now()}`;
            callItem.style.display = 'flex';
            
            let statusIconClass = '';
            let statusIcon = '';
            
            if (isMissed) {
                statusIconClass = 'missed';
                statusIcon = isOutgoing ? 'fas fa-phone-slash' : 'fas fa-phone-missed';
            } else if (isOutgoing) {
                statusIconClass = 'outgoing';
                statusIcon = 'fas fa-phone-alt';
            } else {
                statusIconClass = 'incoming';
                statusIcon = 'fas fa-phone';
            }
            
            const initials = displayName.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2);
            const avatarUrl = callData.avatar || localStorage.getItem(`contact_${otherParticipantIds[0]}_avatar`) || '';
            
            callItem.innerHTML = `
                <div class="call-avatar always-visible" ${avatarUrl ? `style="background-image: url('${avatarUrl}')"` : ''}>
                    ${avatarUrl ? '' : `<span>${initials}</span>`}
                    <div class="call-status-icon ${statusIconClass} always-visible">
                        <i class="${statusIcon}"></i>
                    </div>
                </div>
                <div class="call-info">
                    <div class="call-name always-visible">
                        <span>${displayName}</span>
                        <span class="call-time always-visible">${callTime}</span>
                    </div>
                    <div class="call-details always-visible">
                        <i class="fas fa-${callType === 'video' ? 'video' : 'phone'}"></i>
                        <span>${isMissed ? 'Missed' : (isOutgoing ? 'Outgoing' : 'Incoming')}</span>
                        ${durationText ? `<span> ${durationText}</span>` : ''}
                        ${callData.isLocal ? '<span class="offline-history-badge" style="font-size: 10px; padding: 1px 6px;">Offline</span>' : ''}
                    </div>
                </div>
                <button class="call-action-btn always-visible" title="Call Back" ${!isOnline ? 'disabled' : ''} style="display: flex;">
                    <i class="fas fa-phone"></i>
                </button>
            `;
            
            const callbackBtn = callItem.querySelector('.call-action-btn');
            callbackBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!isOnline) {
                    showNotification('Cannot start call while offline', 'error');
                    return;
                }
                
                if (otherParticipantIds.length > 0) {
                    if (isGroupCall) {
                        startGroupCall(otherParticipantIds);
                    } else if (otherParticipantIds.length === 1) {
                        startCall(otherParticipantIds[0], callType);
                    }
                } else {
                    showNotification('Cannot call: No participant information', 'error');
                }
            });
            
            container.appendChild(callItem);
        }
        
        function listenForExternalCalls() {
            // Listen for messages from other tabs (like friends.html)
            window.addEventListener('message', function(event) {
                console.log('Message received from friends.html:', event.data);
                
                // FEATURE 1: Check if offline before processing call requests
                if (!isOnline) {
                    showNotification('Cannot start call while offline', 'error');
                    return;
                }
                
                // Accept calls initiated from friends.html
                if (event.data && event.data.type === 'callUser') {
                    const userId = event.data.userId;
                    const callType = event.data.callType || 'video';
                    
                    console.log('Call request from friends.html:', userId, callType);
                    startCall(userId, callType);
                }
                
                // Handle video call requests specifically
                if (event.data && event.data.type === 'videoCall') {
                    const userId = event.data.userId;
                    console.log('Video call request from friends.html:', userId);
                    startCall(userId, 'video');
                }
                
                // Handle voice call requests specifically
                if (event.data && event.data.type === 'voiceCall') {
                    const userId = event.data.userId;
                    console.log('Voice call request from friends.html:', userId);
                    startCall(userId, 'voice');
                }
                
                // Handle open calls page
                if (event.data && event.data.type === 'openCallsPage') {
                    console.log('Opening calls page from friends.html');
                    // Ensure calls page is properly loaded
                    if (window.location.pathname.includes('calls.html')) {
                        // Already on calls page, refresh call history
                        if (isOnline) {
                            loadAllCalls();
                        } else {
                            loadCallsFromLocalStorage();
                        }
                    }
                }
            });
            
            // Also check for URL parameters (in case the call was initiated via URL)
            const urlParams = new URLSearchParams(window.location.search);
            const callUserId = urlParams.get('call');
            const callType = urlParams.get('type') || 'video';
            
            if (callUserId) {
                console.log('Call initiated via URL:', callUserId, callType);
                setTimeout(() => {
                    if (isOnline) {
                        startCall(callUserId, callType);
                    } else {
                        showNotification('Cannot start call while offline', 'error');
                    }
                }, 2000);
                
                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }
        
        async function initializeUser() {
            // Only initialize user if online and Firebase is available
            if (!isOnline || !db) {
                // FEATURE 5: Get user info from app.js context or local storage
                const userInfo = localStorage.getItem(`userInfo_${currentUser.uid}`);
                if (userInfo) {
                    const userData = JSON.parse(userInfo);
                    window.userInitials = userData.displayName 
                        ? userData.displayName.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2)
                        : 'ME';
                    window.userAvatar = userData.photoURL || '';
                } else if (currentUser) {
                    window.userInitials = currentUser.displayName 
                        ? currentUser.displayName.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2)
                        : 'ME';
                    window.userAvatar = currentUser.photoURL || '';
                }
                return;
            }
            
            try {
                const userRef = db.collection('users').doc(currentUser.uid);
                const userDoc = await userRef.get();
                
                if (!userDoc.exists) {
                    await userRef.set({
                        uid: currentUser.uid,
                        displayName: currentUser.displayName || `User_${currentUser.uid.substring(0, 8)}`,
                        email: currentUser.email || '',
                        photoURL: currentUser.photoURL || '',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
                        online: true
                    });
                } else {
                    await userRef.update({
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
                        online: true
                    });
                }
                
                const userData = userDoc.exists ? userDoc.data() : {
                    displayName: currentUser.displayName || 'User'
                };
                
                // Save user info to local storage for offline use
                localStorage.setItem(`userInfo_${currentUser.uid}`, JSON.stringify({
                    displayName: userData.displayName,
                    photoURL: userData.photoURL || currentUser.photoURL || ''
                }));
                
                window.userInitials = userData.displayName 
                    ? userData.displayName.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2)
                    : 'ME';
                window.userAvatar = userData.photoURL || currentUser.photoURL || '';
                
            } catch (error) {
                console.error('Error initializing user:', error);
                // Use cached data if available
                const cachedUser = localStorage.getItem(`userInfo_${currentUser.uid}`);
                if (cachedUser) {
                    const userData = JSON.parse(cachedUser);
                    window.userInitials = userData.displayName 
                        ? userData.displayName.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2)
                        : 'ME';
                    window.userAvatar = userData.photoURL || '';
                }
            }
        }
        
        function setupPresenceTracking() {
            if (!currentUser || !isOnline || !db) return;
            
            try {
                userPresenceRef = db.collection('userPresence').doc(currentUser.uid);
                
                const presenceData = {
                    uid: currentUser.uid,
                    online: true,
                    lastOnline: firebase.firestore.FieldValue.serverTimestamp(),
                    peerId: null
                };
                
                userPresenceRef.set(presenceData, { merge: true });
                
                const updatePresenceWithPeerId = () => {
                    if (peer && peer.id && isOnline && userPresenceRef) {
                        userPresenceRef.update({
                            peerId: peer.id,
                            lastOnline: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                };
                
                if (peer) {
                    peer.on('open', updatePresenceWithPeerId);
                }
                
                document.addEventListener('visibilitychange', () => {
                    if (userPresenceRef && isOnline) {
                        if (document.hidden) {
                            userPresenceRef.update({
                                online: false,
                                lastOnline: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        } else {
                            userPresenceRef.update({
                                online: true,
                                lastOnline: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        }
                    }
                });
                
                window.addEventListener('beforeunload', () => {
                    if (userPresenceRef && isOnline) {
                        userPresenceRef.update({
                            online: false,
                            lastOnline: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                });
                
            } catch (error) {
                console.error('Error setting up presence tracking:', error);
            }
        }
        
        function initializePeerJS() {
            if (!currentUser || !isOnline) {
                console.error('Cannot initialize PeerJS: No user logged in or offline');
                return;
            }
            
            try {
                const peerId = `${currentUser.uid}_${Date.now()}`;
                
                console.log('Initializing PeerJS with ID:', peerId);
                
                peer = new Peer(peerId, {
                    host: '0.peerjs.com',
                    port: 443,
                    path: '/',
                    secure: true,
                    config: {
                        'iceServers': [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' },
                            { urls: 'stun:stun3.l.google.com:19302' },
                            { urls: 'stun:stun4.l.google.com:19302' }
                        ]
                    },
                    debug: 2
                });
                
                peer.on('open', (id) => {
                    console.log(' PeerJS connected successfully with ID:', id);
                    
                    if (userPresenceRef && isOnline) {
                        userPresenceRef.update({
                            peerId: id,
                            lastOnline: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                    
                    showNotification('Connected to call server', 'success');
                });
                
                peer.on('error', (err) => {
                    console.error(' PeerJS error:', err.type, err.message);
                    
                    let errorMessage = 'Connection error';
                    if (err.type === 'unavailable-id') {
                        errorMessage = 'User ID already in use. Refreshing...';
                        setTimeout(() => location.reload(), 2000);
                    } else if (err.type === 'network') {
                        errorMessage = 'Network error. Check your connection';
                    } else if (err.type === 'peer-unavailable') {
                        errorMessage = 'User is offline or not connected';
                    }
                    
                    showNotification(errorMessage, 'error');
                });
                
                peer.on('connection', (dataConnection) => {
                    console.log('Incoming data connection from:', dataConnection.peer);
                    
                    const userId = dataConnection.peer.split('_')[0];
                    dataConnections.set(userId, dataConnection);
                    
                    dataConnection.on('data', (data) => {
                        handleDataMessage(data, userId);
                    });
                    
                    dataConnection.on('close', () => {
                        console.log('Data connection closed with:', userId);
                        dataConnections.delete(userId);
                    });
                    
                    dataConnection.on('error', (err) => {
                        console.error('Data connection error:', err);
                    });
                });
                
                peer.on('call', async (incomingCall) => {
                    console.log(' Incoming call from:', incomingCall.peer);
                    
                    try {
                        const metadata = incomingCall.metadata || {};
                        const callerId = metadata.callerId || incomingCall.peer.split('_')[0];
                        
                        let callerData = null;
                        
                        // Try to get caller info from Firebase
                        if (db) {
                            const callerDoc = await db.collection('users').doc(callerId).get();
                            if (callerDoc.exists) {
                                callerData = callerDoc.data();
                            }
                        }
                        
                        // If no Firebase data, check localStorage
                        if (!callerData) {
                            const cachedCaller = localStorage.getItem(`userInfo_${callerId}`);
                            if (cachedCaller) {
                                callerData = JSON.parse(cachedCaller);
                            }
                        }
                        
                        // Fallback to basic info
                        if (!callerData) {
                            callerData = {
                                displayName: 'Unknown',
                                photoURL: ''
                            };
                        }
                        
                        document.getElementById('incomingCallName').textContent = callerData.displayName || 'Unknown';
                        document.getElementById('incomingCallType').textContent = 
                            metadata.type === 'video' ? 'Incoming Video Call' : 'Incoming Voice Call';
                        
                        const incomingCallAvatar = document.getElementById('incomingCallAvatar');
                        if (callerData.photoURL) {
                            incomingCallAvatar.style.backgroundImage = `url('${callerData.photoURL}')`;
                            incomingCallAvatar.innerHTML = '';
                        } else {
                            const initials = callerData.displayName ? 
                                callerData.displayName.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2) : 
                                'U';
                            incomingCallAvatar.innerHTML = `<span style="color: white; font-size: 24px;">${initials}</span>`;
                        }
                        
                        window.incomingCall = incomingCall;
                        window.callerData = {
                            id: callerId,
                            name: callerData.displayName,
                            avatar: callerData.photoURL,
                            peerId: incomingCall.peer,
                            type: metadata.type || 'video'
                        };
                        
                        incomingCallModal.classList.add('active');
                        
                        setTimeout(() => {
                            if (incomingCallModal.classList.contains('active')) {
                                declineCall();
                                showNotification('Missed call from ' + callerData.displayName, 'warning');
                            }
                        }, 45000);
                        
                    } catch (error) {
                        console.error('Error handling incoming call:', error);
                        if (incomingCall) {
                            incomingCall.close();
                        }
                    }
                });
                
                peer.on('disconnected', () => {
                    console.log('PeerJS disconnected, attempting reconnect...');
                    setTimeout(() => {
                        if (peer && peer.disconnected && isOnline) {
                            peer.reconnect();
                        }
                    }, 1000);
                });
                
                peer.on('close', () => {
                    console.log('PeerJS connection closed');
                });
                
            } catch (error) {
                console.error('Error initializing PeerJS:', error);
                showNotification('Failed to initialize call system', 'error');
            }
        }
        
        async function checkUserOnlineStatus(userId) {
            // If we're offline, all users appear offline
            if (!isOnline || !db) {
                return { online: false, lastOnline: 999, peerId: null };
            }
            
            try {
                const presenceDoc = await db.collection('userPresence').doc(userId).get();
                if (presenceDoc.exists) {
                    const presenceData = presenceDoc.data();
                    const lastOnline = presenceData.lastOnline?.toDate();
                    const now = new Date();
                    const minutesAgo = lastOnline ? Math.floor((now - lastOnline) / 60000) : 999;
                    
                    return {
                        online: presenceData.online === true,
                        lastOnline: minutesAgo,
                        peerId: presenceData.peerId
                    };
                }
                return { online: false, lastOnline: 999, peerId: null };
            } catch (error) {
                console.error('Error checking user status:', error);
                return { online: false, lastOnline: 999, peerId: null };
            }
        }
        
        async function startCall(userId, type = 'video') {
            console.log('Starting call to:', userId, 'type:', type);
            
            // FEATURE 1 & 4: Check if offline before starting call
            if (!isOnline) {
                showNotification('Cannot start call while offline', 'error');
                
                // Save as missed call attempt to local storage
                saveCallToLocalStorage({
                    participants: [currentUser.uid, userId],
                    initiator: currentUser.uid,
                    type: type,
                    status: 'missed',
                    timestamp: new Date().toISOString(),
                    missedReason: 'offline_attempt',
                    displayName: 'Unknown'
                });
                
                return;
            }
            
            if (!peer || !peer.id || peer.disconnected) {
                showNotification('Not connected to call server. Please wait...', 'error');
                return;
            }
            
            const status = await checkUserOnlineStatus(userId);
            console.log('User status:', status);
            
            if (!status.online) {
                showNotification('User is offline. They will see missed call when back online.', 'warning');
                
                // FEATURE 1: Save missed call to local storage
                saveCallToLocalStorage({
                    participants: [currentUser.uid, userId],
                    initiator: currentUser.uid,
                    type: type,
                    status: 'missed',
                    timestamp: new Date().toISOString(),
                    missedReason: 'user_offline',
                    displayName: 'Unknown'
                });
                
                return;
            }
            
            if (!status.peerId) {
                showNotification('User is not connected to call server', 'error');
                return;
            }
            
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: type === 'video',
                    audio: true
                });
                
                let callId = null;
                if (db) {
                    const callRef = db.collection('callInvitations').doc();
                    callId = callRef.id;
                    
                    await callRef.set({
                        callId: callId,
                        from: currentUser.uid,
                        to: userId,
                        type: type,
                        status: 'ringing',
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        expiresAt: new Date(Date.now() + 60000)
                    });
                }
                
                currentCallType = type;
                callParticipants = [currentUser.uid, userId];
                
                callContainer.classList.add('active');
                document.getElementById('callTypeIcon').innerHTML = 
                    `<i class="fas fa-${type === 'video' ? 'video' : 'phone'}"></i>`;
                document.getElementById('callParticipants').textContent = 'Calling...';
                document.getElementById('callStatus').textContent = 'Connecting...';
                
                addVideoStream(currentUser.uid, localStream, true);
                
                currentCall = {
                    callId: callId,
                    targetId: userId,
                    targetPeerId: status.peerId,
                    type: type,
                    startTime: new Date()
                };
                
                initiateWebRTCCall(status.peerId, userId, type, callId);
                
                setTimeout(async () => {
                    if (currentCall && currentCall.status !== 'connected') {
                        console.log('Call timeout - no answer');
                        showNotification('No answer. Call ended.', 'warning');
                        
                        // FEATURE 1: Save missed call to local storage
                        saveCallToLocalStorage({
                            participants: [currentUser.uid, userId],
                            initiator: currentUser.uid,
                            type: type,
                            status: 'missed',
                            timestamp: new Date().toISOString(),
                            duration: 0,
                            displayName: 'Unknown'
                        });
                        
                        endCall();
                    }
                }, 45000);
                
            } catch (error) {
                console.error('Error starting call:', error);
                
                if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    showNotification('Camera or microphone not found', 'error');
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    showNotification('Camera or microphone is already in use', 'error');
                } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
                    showNotification('Camera or microphone constraints cannot be satisfied', 'error');
                } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showNotification('Camera or microphone permission denied', 'error');
                } else if (error.name === 'TypeError' || error.name === 'TypeError') {
                    showNotification('Camera or microphone access not supported', 'error');
                } else {
                    showNotification('Failed to start call: ' + error.message, 'error');
                }
                
                endCall();
            }
        }
        
        async function initiateWebRTCCall(targetPeerId, userId, type, callId) {
            try {
                console.log('Initiating WebRTC call to peer:', targetPeerId);
                
                const call = peer.call(targetPeerId, localStream, {
                    metadata: {
                        callerId: currentUser.uid,
                        callerName: currentUser.displayName || 'User',
                        callerAvatar: currentUser.photoURL || '',
                        type: type,
                        callId: callId
                    }
                });
                
                if (!call) {
                    throw new Error('Failed to create call object');
                }
                
                activeCalls.set(userId, call);
                
                call.on('stream', (remoteStream) => {
                    console.log('Received remote stream from:', userId);
                    addVideoStream(userId, remoteStream);
                    
                    if (currentCall) currentCall.status = 'connected';
                    callStartTime = new Date();
                    startCallTimer();
                    
                    document.getElementById('callParticipants').textContent = 'Connected';
                    document.getElementById('callStatus').textContent = 'In call';
                    
                    if (callId && db) {
                        db.collection('callInvitations').doc(callId).delete();
                    }
                    
                    // FEATURE 1: Save connected call to local storage
                    saveCallToLocalStorage({
                        participants: [currentUser.uid, userId],
                        initiator: currentUser.uid,
                        type: type,
                        status: 'connected',
                        timestamp: new Date().toISOString(),
                        startTime: callStartTime,
                        displayName: 'Unknown'
                    });
                    
                    setupDataConnection(userId);
                });
                
                call.on('close', () => {
                    console.log('Call closed with:', userId);
                    removeVideoStream(userId);
                    activeCalls.delete(userId);
                    
                    if (dataConnections.has(userId)) {
                        dataConnections.get(userId).close();
                        dataConnections.delete(userId);
                    }
                    
                    if (activeCalls.size === 0 && currentCall) {
                        endCall();
                    }
                });
                
                call.on('error', (err) => {
                    console.error('Call error with', userId, ':', err);
                    showNotification('Call error: ' + err.message, 'error');
                    removeVideoStream(userId);
                    activeCalls.delete(userId);
                });
                
                if (call.peerConnection) {
                    call.peerConnection.oniceconnectionstatechange = () => {
                        console.log('ICE connection state:', call.peerConnection.iceConnectionState);
                        if (call.peerConnection.iceConnectionState === 'failed' ||
                            call.peerConnection.iceConnectionState === 'disconnected') {
                            showNotification('Network connection unstable', 'warning');
                        }
                    };
                }
                
            } catch (error) {
                console.error('Error initiating WebRTC call:', error);
                showNotification('Failed to connect call: ' + error.message, 'error');
                endCall();
            }
        }
        
        function setupDataConnection(userId) {
            if (dataConnections.has(userId)) return;
            
            try {
                const statusPromise = checkUserOnlineStatus(userId);
                statusPromise.then(status => {
                    if (!status.peerId) return;
                    
                    const dataConnection = peer.connect(status.peerId, {
                        metadata: {
                            userId: currentUser.uid,
                            userName: currentUser.displayName
                        },
                        reliable: true
                    });
                    
                    dataConnection.on('open', () => {
                        console.log('Data connection established with:', userId);
                        dataConnections.set(userId, dataConnection);
                        
                        sendDataMessage(userId, {
                            type: 'handshake',
                            userId: currentUser.uid,
                            userName: currentUser.displayName,
                            timestamp: new Date().toISOString()
                        });
                    });
                    
                    dataConnection.on('data', (data) => {
                        handleDataMessage(data, userId);
                    });
                    
                    dataConnection.on('close', () => {
                        console.log('Data connection closed with:', userId);
                        dataConnections.delete(userId);
                    });
                    
                    dataConnection.on('error', (err) => {
                        console.error('Data connection error with', userId, ':', err);
                    });
                    
                }).catch(error => {
                    console.error('Error setting up data connection:', error);
                });
                
            } catch (error) {
                console.error('Error creating data connection:', error);
            }
        }
        
        function sendDataMessage(targetUserId, message) {
            if (dataConnections.has(targetUserId)) {
                const connection = dataConnections.get(targetUserId);
                if (connection.open) {
                    connection.send(message);
                    return true;
                }
            }
            
            return false;
        }
        
        function broadcastDataMessage(message, excludeUserId = null) {
            dataConnections.forEach((connection, userId) => {
                if (userId !== excludeUserId && connection.open) {
                    connection.send(message);
                }
            });
        }
        
        function handleDataMessage(data, senderId) {
            console.log('Received data message from:', senderId, data);
            
            switch(data.type) {
                case 'handshake':
                    console.log('Handshake received from:', senderId);
                    break;
                    
                case 'reaction':
                    if (userSettings.reactions) {
                        showFloatingReaction(data.reaction);
                    }
                    break;
                    
                case 'chat':
                    if (userSettings.chat) {
                        addChatMessage(data.message, senderId, false);
                    }
                    break;
                    
                case 'whiteboard':
                    if (userSettings.whiteboard) {
                        handleWhiteboardData(data, senderId);
                    }
                    break;
                    
                case 'call-control':
                    handleCallControlMessage(data, senderId);
                    break;
            }
        }
        
        function showFloatingReaction(reaction) {
            const reactionElement = document.createElement('div');
            reactionElement.className = 'floating-reaction';
            reactionElement.textContent = reaction;
            reactionElement.style.left = Math.random() * 80 + 10 + '%';
            reactionElement.style.top = Math.random() * 80 + 10 + '%';
            
            callContainer.appendChild(reactionElement);
            
            setTimeout(() => {
                if (reactionElement.parentNode) {
                    reactionElement.remove();
                }
            }, 3000);
        }
        
        async function startGroupCall(userIds) {
            console.log('Starting group call with:', userIds);
            
            // FEATURE 1 & 4: Check if offline
            if (!isOnline) {
                showNotification('Cannot start call while offline', 'error');
                
                // Save group call attempt to local storage
                saveCallToLocalStorage({
                    participants: [currentUser.uid, ...userIds],
                    initiator: currentUser.uid,
                    type: 'video',
                    group: true,
                    status: 'missed',
                    timestamp: new Date().toISOString(),
                    missedReason: 'offline_attempt',
                    displayName: `Group Call (${userIds.length + 1})`
                });
                
                return;
            }
            
            if (!peer || !peer.id || peer.disconnected) {
                showNotification('Not connected to call server', 'error');
                return;
            }
            
            const onlineUsers = [];
            const offlineUsers = [];
            
            for (const userId of userIds) {
                const status = await checkUserOnlineStatus(userId);
                if (status.online && status.peerId) {
                    onlineUsers.push({ id: userId, peerId: status.peerId });
                } else {
                    offlineUsers.push(userId);
                }
            }
            
            if (onlineUsers.length === 0) {
                showNotification('All selected users are offline', 'warning');
                return;
            }
            
            if (offlineUsers.length > 0) {
                showNotification(`${offlineUsers.length} user(s) offline and won't join the call`, 'warning');
            }
            
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                
                currentCallType = 'video';
                callParticipants = [currentUser.uid, ...onlineUsers.map(u => u.id)];
                
                callContainer.classList.add('active');
                document.getElementById('callTypeIcon').innerHTML = '<i class="fas fa-users"></i>';
                document.getElementById('callParticipants').textContent = `Group Call (${callParticipants.length})`;
                document.getElementById('callStatus').textContent = 'Starting...';
                
                addVideoStream(currentUser.uid, localStream, true);
                
                currentCall = {
                    group: true,
                    participants: onlineUsers,
                    startTime: new Date(),
                    status: 'connecting'
                };
                
                const callPromises = [];
                for (const user of onlineUsers) {
                    const callId = `group_${Date.now()}_${user.id}`;
                    callPromises.push(initiateWebRTCCall(user.peerId, user.id, 'video', callId));
                }
                
                await Promise.allSettled(callPromises);
                
                callStartTime = new Date();
                startCallTimer();
                if (currentCall) currentCall.status = 'connected';
                
                // FEATURE 1: Save group call to local storage
                saveCallToLocalStorage({
                    participants: callParticipants,
                    initiator: currentUser.uid,
                    type: 'video',
                    group: true,
                    status: 'connected',
                    timestamp: new Date().toISOString(),
                    startTime: callStartTime,
                    displayName: `Group Call (${callParticipants.length})`
                });
                
                updateParticipantsList();
                
                showNotification(`Group call started with ${onlineUsers.length} participant(s)`, 'success');
                
            } catch (error) {
                console.error('Error starting group call:', error);
                showNotification('Failed to start group call: ' + error.message, 'error');
                endCall();
            }
        }
        
        function addVideoStream(userId, stream, isLocal = false) {
            const existingVideo = document.querySelector(`[data-user-id="${userId}"]`);
            if (existingVideo) {
                existingVideo.remove();
            }
            
            const videoContainer = document.createElement('div');
            videoContainer.className = 'video-container fade-in always-visible';
            videoContainer.dataset.userId = userId;
            
            if (isLocal) {
                videoContainer.classList.add('pinned');
            }
            
            const video = document.createElement('video');
            video.className = 'video-element always-visible';
            video.srcObject = stream;
            video.autoplay = true;
            video.muted = isLocal;
            video.playsInline = true;
            
            let userName = isLocal ? 'You' : 'User';
            let userAvatar = '';
            
            if (isLocal) {
                userName = 'You';
                userAvatar = window.userAvatar;
            } else {
                // Try to get user info from Firebase or localStorage
                const getUserInfo = async () => {
                    try {
                        if (db) {
                            const userDoc = await db.collection('users').doc(userId).get();
                            if (userDoc.exists) {
                                const userData = userDoc.data();
                                userName = userData.displayName || 'User';
                                userAvatar = userData.photoURL || '';
                            }
                        } else {
                            // Check localStorage
                            const cachedUser = localStorage.getItem(`userInfo_${userId}`);
                            if (cachedUser) {
                                const userData = JSON.parse(cachedUser);
                                userName = userData.displayName || 'User';
                                userAvatar = userData.photoURL || '';
                            }
                        }
                    } catch (error) {
                        console.error('Error getting user info:', error);
                    }
                    
                    const nameSpan = videoContainer.querySelector('.video-name span');
                    if (nameSpan) nameSpan.textContent = userName;
                };
                
                getUserInfo();
            }
            
            const videoOverlay = document.createElement('div');
            videoOverlay.className = 'video-overlay always-visible';
            videoOverlay.innerHTML = `
                <div class="video-name always-visible">
                    <i class="fas fa-${isLocal ? 'user' : 'user-friends'}"></i>
                    <span>${userName}</span>
                </div>
                <div class="video-actions always-visible">
                    <button class="video-action-btn always-visible" data-action="pin" title="Pin">
                        <i class="fas fa-thumbtack"></i>
                    </button>
                    <button class="video-action-btn always-visible" data-action="spotlight" title="Spotlight">
                        <i class="fas fa-star"></i>
                    </button>
                </div>
            `;
            
            videoContainer.appendChild(video);
            videoContainer.appendChild(videoOverlay);
            videoGrid.appendChild(videoContainer);
            
            if (!isLocal) {
                remoteStreams.set(userId, stream);
            }
            
            updateVideoGrid();
            
            videoOverlay.querySelectorAll('.video-action-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = btn.dataset.action;
                    if (action === 'pin') {
                        videoContainer.classList.toggle('pinned');
                        btn.classList.toggle('active');
                    }
                });
            });
        }
        
        function removeVideoStream(userId) {
            const videoElement = document.querySelector(`[data-user-id="${userId}"]`);
            if (videoElement) {
                videoElement.remove();
                remoteStreams.delete(userId);
                updateVideoGrid();
            }
        }
        
        function updateVideoGrid() {
            const videoContainers = document.querySelectorAll('.video-container');
            const count = videoContainers.length;
            
            if (count === 0) return;
            
            videoContainers.forEach(container => {
                container.classList.remove('large');
            });
            
            if (count === 1) {
                videoContainers[0].classList.add('large');
            }
            
            if (currentCall && currentCall.group) {
                document.getElementById('callParticipants').textContent = 
                    `Group Call (${count})`;
            }
        }
        
        function startCallTimer() {
            callStartTime = new Date();
            
            if (callInterval) clearInterval(callInterval);
            
            callInterval = setInterval(() => {
                if (!callStartTime) return;
                
                const now = new Date();
                const diff = Math.floor((now - callStartTime) / 1000);
                const minutes = Math.floor(diff / 60);
                const seconds = diff % 60;
                
                document.getElementById('callDuration').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }
        
        async function endCall() {
            console.log('Ending call...');
            
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                    track.enabled = false;
                });
                localStream = null;
            }
            
            activeCalls.forEach((call, userId) => {
                try {
                    call.close();
                } catch (e) {
                    console.error('Error closing call with', userId, ':', e);
                }
            });
            activeCalls.clear();
            
            dataConnections.forEach((connection, userId) => {
                try {
                    connection.close();
                } catch (e) {
                    console.error('Error closing data connection with', userId, ':', e);
                }
            });
            dataConnections.clear();
            
            remoteStreams.forEach(stream => {
                stream.getTracks().forEach(track => track.stop());
            });
            remoteStreams.clear();
            
            if (callInterval) {
                clearInterval(callInterval);
                callInterval = null;
            }
            
            if (currentCall && callStartTime) {
                const endTime = new Date();
                const duration = Math.floor((endTime - callStartTime) / 1000);
                
                const participants = currentCall.group ? 
                    callParticipants : 
                    [currentUser.uid, currentCall.targetId];
                
                // FEATURE 1: Save completed call to local storage
                saveCallToLocalStorage({
                    participants: participants,
                    initiator: currentCall.group ? currentUser.uid : currentCall.initiator,
                    type: currentCallType,
                    status: 'completed',
                    timestamp: new Date().toISOString(),
                    startTime: callStartTime,
                    endTime: endTime,
                    duration: duration,
                    group: currentCall.group || false,
                    displayName: currentCall.group ? `Group Call (${participants.length})` : 'Unknown'
                });
            }
            
            callContainer.classList.remove('active');
            callSidePanel.classList.add('collapsed');
            incomingCallModal.classList.remove('active');
            pipContainer.style.display = 'none';
            
            videoGrid.innerHTML = '';
            
            document.getElementById('callDuration').textContent = '00:00';
            
            currentCall = null;
            callStartTime = null;
            currentCallType = null;
            callParticipants = [];
            
            // Reload call history
            if (isOnline) {
                loadAllCalls();
            } else {
                loadCallsFromLocalStorage();
            }
            
            showNotification('Call ended', 'success');
        }
        
        async function acceptCall(type = 'voice') {
            try {
                // FEATURE 1 & 4: Check if offline before accepting call
                if (!isOnline) {
                    showNotification('Cannot accept call while offline', 'error');
                    declineCall();
                    return;
                }
                
                const incomingCall = window.incomingCall;
                if (!incomingCall) {
                    showNotification('No incoming call to accept', 'error');
                    return;
                }
                
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: type === 'video',
                    audio: true
                });
                
                incomingCall.answer(localStream);
                
                currentCall = {
                    targetId: window.callerData.id,
                    type: type,
                    startTime: new Date()
                };
                
                currentCallType = type;
                callParticipants = [currentUser.uid, window.callerData.id];
                
                callContainer.classList.add('active');
                incomingCallModal.classList.remove('active');
                
                document.getElementById('callTypeIcon').innerHTML = 
                    `<i class="fas fa-${type === 'video' ? 'video' : 'phone'}"></i>`;
                document.getElementById('callParticipants').textContent = window.callerData.name;
                document.getElementById('callStatus').textContent = 'Connected';
                
                addVideoStream(currentUser.uid, localStream, true);
                
                incomingCall.on('stream', (remoteStream) => {
                    addVideoStream(window.callerData.id, remoteStream);
                    activeCalls.set(window.callerData.id, incomingCall);
                    setupDataConnection(window.callerData.id);
                });
                
                incomingCall.on('close', () => {
                    console.log('Incoming call closed by caller');
                    endCall();
                });
                
                incomingCall.on('error', (err) => {
                    console.error('Incoming call error:', err);
                    showNotification('Call error: ' + err.message, 'error');
                    endCall();
                });
                
                callStartTime = new Date();
                startCallTimer();
                
                if (incomingCall.metadata && incomingCall.metadata.callId && db) {
                    await db.collection('callInvitations').doc(incomingCall.metadata.callId).delete();
                }
                
                // FEATURE 1: Save accepted call to local storage
                saveCallToLocalStorage({
                    participants: [currentUser.uid, window.callerData.id],
                    initiator: window.callerData.id,
                    type: type,
                    status: 'completed',
                    timestamp: new Date().toISOString(),
                    startTime: callStartTime,
                    displayName: window.callerData.name
                });
                
                window.incomingCall = null;
                window.callerData = null;
                
            } catch (error) {
                console.error('Error accepting call:', error);
                showNotification('Failed to accept call: ' + error.message, 'error');
                declineCall();
            }
        }
        
        async function declineCall() {
            console.log('Declining call...');
            
            if (window.incomingCall) {
                try {
                    window.incomingCall.close();
                } catch (e) {
                    console.error('Error closing incoming call:', e);
                }
                
                if (window.callerData) {
                    // FEATURE 1: Save missed call to local storage
                    saveCallToLocalStorage({
                        participants: [currentUser.uid, window.callerData.id],
                        initiator: window.callerData.id,
                        type: window.callerData.type,
                        status: 'missed',
                        timestamp: new Date().toISOString(),
                        displayName: window.callerData.name
                    });
                }
                
                window.incomingCall = null;
                window.callerData = null;
            }
            
            incomingCallModal.classList.remove('active');
            showNotification('Call declined', 'success');
        }
        
        async function loadUserSettings() {
            try {
                // Try to load from localStorage first (works offline)
                const localSettings = localStorage.getItem(`userSettings_${currentUser.uid}`);
                if (localSettings) {
                    userSettings = JSON.parse(localSettings);
                }
                
                // Only try Firebase if online
                if (isOnline && db) {
                    const settingsDoc = await db.collection('userSettings').doc(currentUser.uid).get();
                    
                    if (settingsDoc.exists) {
                        const savedSettings = settingsDoc.data();
                        userSettings = {
                            reactions: savedSettings.reactions !== undefined ? savedSettings.reactions : true,
                            chat: savedSettings.chat !== undefined ? savedSettings.chat : true,
                            whiteboard: savedSettings.whiteboard !== undefined ? savedSettings.whiteboard : true,
                            polls: savedSettings.polls !== undefined ? savedSettings.polls : true,
                            notes: savedSettings.notes !== undefined ? savedSettings.notes : true
                        };
                        
                        // Save to localStorage for offline use
                        localStorage.setItem(`userSettings_${currentUser.uid}`, JSON.stringify(userSettings));
                    }
                }
                
                // Update UI toggles
                updateSettingsUI();
                applyUserSettings();
                
            } catch (error) {
                console.error('Error loading user settings:', error);
                updateSettingsUI();
                applyUserSettings();
            }
        }
        
        function updateSettingsUI() {
            document.getElementById('reactionsToggle').checked = userSettings.reactions;
            document.getElementById('chatToggle').checked = userSettings.chat;
            document.getElementById('whiteboardToggle').checked = userSettings.whiteboard;
            document.getElementById('pollsToggle').checked = userSettings.polls;
            document.getElementById('notesToggle').checked = userSettings.notes;
        }
        
        function saveUserSettings() {
            if (!currentUser) return;
            
            // Always save to localStorage (works offline)
            localStorage.setItem(`userSettings_${currentUser.uid}`, JSON.stringify(userSettings));
            
            // Try to save to Firebase if online
            if (isOnline && db) {
                try {
                    db.collection('userSettings').doc(currentUser.uid).set(userSettings, { merge: true })
                        .then(() => {
                            console.log('Settings saved to Firebase');
                        })
                        .catch(error => {
                            console.error('Error saving user settings to Firebase:', error);
                        });
                } catch (error) {
                    console.error('Error saving user settings:', error);
                }
            }
        }
        
        function resetSettingsToDefault() {
            userSettings = { ...defaultSettings };
            updateSettingsUI();
            applyUserSettings();
            saveUserSettings();
            showNotification('Settings reset to default', 'success');
        }
        
        function applyUserSettings() {
            const reactionsContainer = document.getElementById('reactionsContainer');
            if (reactionsContainer) {
                reactionsContainer.style.display = userSettings.reactions ? 'flex' : 'none';
                reactionsContainer.classList.add('always-visible');
            }
            
            const panelTabs = document.querySelectorAll('.panel-tab');
            panelTabs.forEach(tab => {
                const panelType = tab.dataset.panel;
                
                switch(panelType) {
                    case 'chat':
                        tab.style.display = userSettings.chat ? 'flex' : 'none';
                        break;
                    case 'whiteboard':
                        tab.style.display = userSettings.whiteboard ? 'flex' : 'none';
                        break;
                    case 'notes':
                        tab.style.display = userSettings.notes ? 'flex' : 'none';
                        break;
                    case 'polls':
                        tab.style.display = userSettings.polls ? 'flex' : 'none';
                        break;
                }
                
                // Always keep tab visible if setting is enabled
                if (tab.style.display !== 'none') {
                    tab.classList.add('always-visible');
                }
            });
        }
        
        async function loadAllCalls() {
            try {
                allCallsList.innerHTML = '<div class="loading-placeholder always-visible" style="text-align: center; padding: 40px 20px; color: var(--text-secondary);"><i class="fas fa-spinner fa-spin" style="font-size: 24px; margin-bottom: 15px;"></i><p>Loading call history...</p></div>';
                
                // If offline, load from local storage
                if (!isOnline || !db) {
                    loadCallsFromLocalStorage();
                    return;
                }
                
                const callsSnapshot = await db.collection('calls')
                    .where('participants', 'array-contains', currentUser.uid)
                    .orderBy('timestamp', 'desc')
                    .limit(50)
                    .get();
                
                // Save calls to local storage for offline access
                const callsToSave = [];
                callsSnapshot.forEach(doc => {
                    const callData = doc.data();
                    callsToSave.push({
                        ...callData,
                        id: doc.id,
                        timestamp: callData.timestamp ? callData.timestamp.toDate().toISOString() : new Date().toISOString(),
                        isLocal: false
                    });
                });
                
                // Save to local storage
                localStorage.setItem(getLocalStorageKey('history'), JSON.stringify(callsToSave));
                
                displayCalls(callsSnapshot, allCallsList, 'all');
                
                // Also load missed and group calls
                loadMissedCalls();
                loadGroupCalls();
                
            } catch (error) {
                console.error('Error loading all calls:', error);
                showNotification('Failed to load call history', 'error');
                
                // Fall back to local storage
                loadCallsFromLocalStorage();
            }
        }
        
        async function loadMissedCalls() {
            try {
                if (!isOnline || !db) {
                    // Load from local storage
                    const storedCalls = localStorage.getItem(getLocalStorageKey('history'));
                    if (storedCalls) {
                        const calls = JSON.parse(storedCalls);
                        const missedCalls = calls.filter(call => call.status === 'missed');
                        displayCallsFromArray(missedCalls, missedCallsList, 'missed');
                    }
                    return;
                }
                
                const callsSnapshot = await db.collection('calls')
                    .where('participants', 'array-contains', currentUser.uid)
                    .where('status', '==', 'missed')
                    .orderBy('timestamp', 'desc')
                    .limit(20)
                    .get();
                
                displayCalls(callsSnapshot, missedCallsList, 'missed');
                
            } catch (error) {
                console.error('Error loading missed calls:', error);
            }
        }
        
        async function loadGroupCalls() {
            try {
                if (!isOnline || !db) {
                    // Load from local storage
                    const storedCalls = localStorage.getItem(getLocalStorageKey('history'));
                    if (storedCalls) {
                        const calls = JSON.parse(storedCalls);
                        const groupCalls = calls.filter(call => call.group === true || (call.participants && call.participants.length > 2));
                        displayCallsFromArray(groupCalls, groupCallsList, 'group');
                    }
                    return;
                }
                
                const callsSnapshot = await db.collection('calls')
                    .where('participants', 'array-contains', currentUser.uid)
                    .where('group', '==', true)
                    .orderBy('timestamp', 'desc')
                    .limit(20)
                    .get();
                
                displayCalls(callsSnapshot, groupCallsList, 'group');
                
            } catch (error) {
                console.error('Error loading group calls:', error);
            }
        }
        
        function displayCalls(snapshot, container, type) {
            if (snapshot.empty) {
                let emptyMessage = '';
                switch(type) {
                    case 'missed':
                        emptyMessage = `
                            <div class="empty-state always-visible">
                                <i class="fas fa-phone-slash"></i>
                                <p>No missed calls</p>
                                <p class="subtext">All calls have been answered</p>
                            </div>
                        `;
                        break;
                    case 'group':
                        emptyMessage = `
                            <div class="empty-state always-visible">
                                <i class="fas fa-users"></i>
                                <p>No group calls</p>
                                <p class="subtext">Start your first group call</p>
                            </div>
                        `;
                        break;
                    default:
                        emptyMessage = `
                            <div class="empty-state always-visible">
                                <i class="fas fa-phone"></i>
                                <p>No recent calls</p>
                                <p class="subtext">Start your first call with the button above</p>
                            </div>
                        `;
                }
                container.innerHTML = emptyMessage;
                return;
            }
            
            container.innerHTML = '';
            
            // Process each call document
            const promises = [];
            snapshot.forEach(doc => {
                promises.push(displayCallItem(doc.data(), doc.id, container));
            });
            
            Promise.all(promises).catch(error => {
                console.error('Error displaying calls:', error);
            });
            
            // Ensure at least 5 items are visible without scrolling
            setTimeout(() => {
                const callItems = container.querySelectorAll('.call-item');
                if (callItems.length > 0) {
                    // Calculate height needed for 5 items
                    const itemHeight = callItems[0].offsetHeight || 80;
                    const minHeight = itemHeight * 5;
                    container.style.minHeight = minHeight + 'px';
                }
                
                // Ensure all items are visible
                callItems.forEach(item => {
                    item.classList.add('always-visible');
                    item.style.display = 'flex';
                });
            }, 100);
        }
        
        async function displayCallItem(callData, callId, container) {
            const otherParticipantIds = callData.participants ? callData.participants.filter(id => id !== currentUser.uid) : [];
            let displayName = callData.displayName || 'Unknown';
            let avatar = '';
            
            if (otherParticipantIds.length === 1 && !displayName) {
                try {
                    // Try Firebase first
                    if (db) {
                        const userDoc = await db.collection('users').doc(otherParticipantIds[0]).get();
                        if (userDoc.exists) {
                            const userData = userDoc.data();
                            displayName = userData.displayName || 'User';
                            avatar = userData.photoURL || '';
                            
                            // Save contact info to local storage for offline use
                            localStorage.setItem(`contact_${otherParticipantIds[0]}_name`, userData.displayName || 'User');
                            if (userData.photoURL) {
                                localStorage.setItem(`contact_${otherParticipantIds[0]}_avatar`, userData.photoURL);
                            }
                        }
                    } else {
                        // Check localStorage
                        const contactName = localStorage.getItem(`contact_${otherParticipantIds[0]}_name`);
                        if (contactName) {
                            displayName = contactName;
                            avatar = localStorage.getItem(`contact_${otherParticipantIds[0]}_avatar`) || '';
                        }
                    }
                } catch (error) {
                    console.error('Error fetching user data:', error);
                }
            } else if (otherParticipantIds.length > 1 && !displayName) {
                displayName = `Group Call (${callData.participants.length})`;
            }
            
            const isGroupCall = callData.participants && (callData.participants.length > 2 || callData.group);
            const callType = callData.type || 'voice';
            const callStatus = callData.status || 'completed';
            const isMissed = callStatus === 'missed';
            const isOutgoing = callData.initiator === currentUser.uid;
            
            const callTime = callData.timestamp ? 
                formatTimeAgo(callData.timestamp.toDate()) : 
                'Recently';
            
            let durationText = '';
            if (callData.duration && callData.duration > 0) {
                const minutes = Math.floor(callData.duration / 60);
                const seconds = callData.duration % 60;
                durationText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            const callItem = document.createElement('div');
            callItem.className = 'call-item always-visible';
            callItem.dataset.callId = callId;
            callItem.style.display = 'flex';
            
            let statusIconClass = '';
            let statusIcon = '';
            
            if (isMissed) {
                statusIconClass = 'missed';
                statusIcon = isOutgoing ? 'fas fa-phone-slash' : 'fas fa-phone-missed';
            } else if (isOutgoing) {
                statusIconClass = 'outgoing';
                statusIcon = 'fas fa-phone-alt';
            } else {
                statusIconClass = 'incoming';
                statusIcon = 'fas fa-phone';
            }
            
            const initials = displayName.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2);
            
            callItem.innerHTML = `
                <div class="call-avatar always-visible" ${avatar ? `style="background-image: url('${avatar}')"` : ''}>
                    ${avatar ? '' : `<span>${initials}</span>`}
                    <div class="call-status-icon ${statusIconClass} always-visible">
                        <i class="${statusIcon}"></i>
                    </div>
                </div>
                <div class="call-info">
                    <div class="call-name always-visible">
                        <span>${displayName}</span>
                        <span class="call-time always-visible">${callTime}</span>
                    </div>
                    <div class="call-details always-visible">
                        <i class="fas fa-${callType === 'video' ? 'video' : 'phone'}"></i>
                        <span>${isMissed ? 'Missed' : (isOutgoing ? 'Outgoing' : 'Incoming')}</span>
                        ${durationText ? `<span> ${durationText}</span>` : ''}
                    </div>
                </div>
                <button class="call-action-btn always-visible" title="Call Back" ${!isOnline ? 'disabled' : ''} style="display: flex;">
                    <i class="fas fa-phone"></i>
                </button>
            `;
            
            const callbackBtn = callItem.querySelector('.call-action-btn');
            callbackBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!isOnline) {
                    showNotification('Cannot start call while offline', 'error');
                    return;
                }
                
                if (isGroupCall && otherParticipantIds.length > 0) {
                    startGroupCall(otherParticipantIds);
                } else if (otherParticipantIds.length === 1) {
                    startCall(otherParticipantIds[0], callType);
                } else {
                    showNotification('Cannot call: No participant information', 'error');
                }
            });
            
            container.appendChild(callItem);
        }
        
        function formatTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return `${Math.floor(diffDays / 7)}w ago`;
        }
        
        function initializeWhiteboard() {
            whiteboardCanvas = document.getElementById('whiteboardCanvas');
            if (!whiteboardCanvas) return;
            
            whiteboardCtx = whiteboardCanvas.getContext('2d');
            whiteboardCanvas.width = whiteboardCanvas.offsetWidth;
            whiteboardCanvas.height = whiteboardCanvas.offsetHeight;
            
            whiteboardCtx.strokeStyle = '#000000';
            whiteboardCtx.lineWidth = 2;
            whiteboardCtx.lineCap = 'round';
            
            whiteboardCtx.fillStyle = '#ffffff';
            whiteboardCtx.fillRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
            
            whiteboardCanvas.addEventListener('mousedown', startDrawing);
            whiteboardCanvas.addEventListener('mousemove', draw);
            whiteboardCanvas.addEventListener('mouseup', stopDrawing);
            whiteboardCanvas.addEventListener('mouseout', stopDrawing);
            
            whiteboardCanvas.addEventListener('touchstart', handleTouchStart);
            whiteboardCanvas.addEventListener('touchmove', handleTouchMove);
            whiteboardCanvas.addEventListener('touchend', stopDrawing);
        }
        
        function startDrawing(e) {
            if (!userSettings.whiteboard) return;
            
            isDrawing = true;
            const rect = whiteboardCanvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
            
            if (currentTool === 'pencil') {
                whiteboardCtx.beginPath();
                whiteboardCtx.moveTo(lastX, lastY);
            }
        }
        
        function draw(e) {
            if (!isDrawing || !userSettings.whiteboard) return;
            
            const rect = whiteboardCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            switch(currentTool) {
                case 'pencil':
                    whiteboardCtx.lineTo(x, y);
                    whiteboardCtx.stroke();
                    break;
            }
            
            lastX = x;
            lastY = y;
        }
        
        function stopDrawing() {
            isDrawing = false;
            if (currentTool === 'pencil') {
                whiteboardCtx.closePath();
            }
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            whiteboardCanvas.dispatchEvent(mouseEvent);
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            whiteboardCanvas.dispatchEvent(mouseEvent);
        }
        
        function clearWhiteboard() {
            if (!userSettings.whiteboard) return;
            whiteboardCtx.fillStyle = '#ffffff';
            whiteboardCtx.fillRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
        }
        
        async function shareScreen() {
            try {
                if (isScreenSharing) {
                    // Stop screen sharing
                    if (localStream) {
                        localStream.getVideoTracks()[0].stop();
                    }
                    
                    // Get camera stream
                    const cameraStream = await navigator.mediaDevices.getUserMedia({ 
                        video: true,
                        audio: false
                    });
                    
                    if (localStream) {
                        const videoTrack = cameraStream.getVideoTracks()[0];
                        const oldVideoTrack = localStream.getVideoTracks()[0];
                        
                        localStream.removeTrack(oldVideoTrack);
                        localStream.addTrack(videoTrack);
                        
                        // Update all active calls
                        activeCalls.forEach(call => {
                            if (call.peerConnection) {
                                const senders = call.peerConnection.getSenders();
                                senders.forEach(sender => {
                                    if (sender.track && sender.track.kind === 'video') {
                                        sender.replaceTrack(videoTrack);
                                    }
                                });
                            }
                        });
                    }
                    
                    isScreenSharing = false;
                    document.getElementById('screenShareBtn').classList.remove('active');
                    
                    showNotification('Stopped screen sharing', 'success');
                    
                } else {
                    // Start screen sharing
                    const screenStream = await navigator.mediaDevices.getDisplayMedia({
                        video: {
                            displaySurface: 'monitor',
                            cursor: 'always'
                        },
                        audio: false
                    });
                    
                    if (!localStream) {
                        showNotification('No local stream available', 'error');
                        return;
                    }
                    
                    const screenTrack = screenStream.getVideoTracks()[0];
                    const oldVideoTrack = localStream.getVideoTracks()[0];
                    
                    localStream.removeTrack(oldVideoTrack);
                    localStream.addTrack(screenTrack);
                    
                    // Update all active calls
                    activeCalls.forEach(call => {
                        if (call.peerConnection) {
                            const senders = call.peerConnection.getSenders();
                            senders.forEach(sender => {
                                if (sender.track && sender.track.kind === 'video') {
                                    sender.replaceTrack(screenTrack);
                                }
                            });
                        }
                    });
                    
                    isScreenSharing = true;
                    document.getElementById('screenShareBtn').classList.add('active');
                    
                    showNotification('Screen sharing started', 'success');
                    
                    // Handle when user stops sharing
                    screenTrack.onended = () => {
                        shareScreen();
                    };
                }
                
            } catch (error) {
                console.error('Error sharing screen:', error);
                if (error.name === 'NotAllowedError') {
                    showNotification('Screen sharing permission denied', 'error');
                } else {
                    showNotification('Failed to share screen: ' + error.message, 'error');
                }
            }
        }
        
        function updateParticipantsList() {
            const participantsList = document.getElementById('participantsList');
            if (!participantsList) return;
            
            participantsList.innerHTML = '';
            
            addParticipantItem(currentUser.uid, 'You', window.userAvatar, true, true);
            
            remoteStreams.forEach((stream, userId) => {
                // Try to get user info
                const getUserInfo = async () => {
                    try {
                        let userData = null;
                        
                        if (db) {
                            const userDoc = await db.collection('users').doc(userId).get();
                            if (userDoc.exists) {
                                userData = userDoc.data();
                            }
                        }
                        
                        if (!userData) {
                            const cachedUser = localStorage.getItem(`userInfo_${userId}`);
                            if (cachedUser) {
                                userData = JSON.parse(cachedUser);
                            }
                        }
                        
                        addParticipantItem(userId, userData ? userData.displayName || 'User' : 'User', 
                                          userData ? userData.photoURL || '' : '', false, true);
                    } catch (error) {
                        console.error('Error getting participant info:', error);
                        addParticipantItem(userId, 'User', '', false, true);
                    }
                };
                
                getUserInfo();
            });
        }
        
        function addParticipantItem(userId, name, avatar, isLocal, isOnline) {
            const participantsList = document.getElementById('participantsList');
            if (!participantsList) return;
            
            const participantItem = document.createElement('div');
            participantItem.className = 'participant-item always-visible';
            participantItem.dataset.userId = userId;
            participantItem.style.display = 'flex';
            
            const initials = name.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2);
            
            participantItem.innerHTML = `
                <div class="participant-avatar always-visible" ${avatar ? `style="background-image: url('${avatar}')"` : ''}>
                    ${avatar ? '' : `<span>${initials}</span>`}
                </div>
                <div class="participant-info">
                    <div class="participant-name always-visible">${name}</div>
                    <div class="participant-status ${isOnline ? 'active' : 'offline'} always-visible">
                        <i class="fas fa-circle"></i>
                        ${isLocal ? 'You' : (isOnline ? 'Connected' : 'Offline')}
                    </div>
                </div>
                ${!isLocal ? `
                <div class="participant-actions always-visible">
                    <button class="video-action-btn always-visible" data-action="pin-user" title="Pin">
                        <i class="fas fa-thumbtack"></i>
                    </button>
                </div>
                ` : ''}
            `;
            
            participantsList.appendChild(participantItem);
        }
        
        async function loadContacts() {
            const contactsList = document.getElementById('contactsList');
            const groupContactsList = document.getElementById('groupContactsList');
            
            // If offline, show offline message - FEATURE 2 & 4
            if (!isOnline) {
                const offlineMessage = '<div class="offline-contacts-message always-visible"><i class="fas fa-wifi-slash"></i><p>Contacts unavailable while offline</p><p class="subtext">Calls require internet connection</p></div>';
                contactsList.innerHTML = offlineMessage;
                groupContactsList.innerHTML = offlineMessage;
                return;
            }
            
            contactsList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);" class="always-visible">Loading contacts...</div>';
            groupContactsList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);" class="always-visible">Loading contacts...</div>';
            
            try {
                if (!db) {
                    throw new Error('Database not available');
                }
                
                const usersSnapshot = await db.collection('users')
                    .where('uid', '!=', currentUser.uid)
                    .limit(50)
                    .get();
                
                contactsList.innerHTML = '';
                groupContactsList.innerHTML = '';
                
                if (usersSnapshot.empty) {
                    const emptyMessage = '<div class="offline-contacts-message always-visible"><i class="fas fa-users"></i><p>No contacts found</p></div>';
                    contactsList.innerHTML = emptyMessage;
                    groupContactsList.innerHTML = emptyMessage;
                    return;
                }
                
                for (const doc of usersSnapshot.docs) {
                    const userData = doc.data();
                    const status = await checkUserOnlineStatus(userData.uid);
                    userData.online = status.online;
                    userData.lastOnline = status.lastOnline;
                    
                    addContactItem(userData, contactsList);
                    addContactItem(userData, groupContactsList);
                }
                
            } catch (error) {
                console.error('Error loading contacts:', error);
                showNotification('Failed to load contacts', 'error');
                
                // Show offline message
                const offlineMessage = '<div class="offline-contacts-message always-visible"><i class="fas fa-wifi-slash"></i><p>Contacts unavailable while offline</p><p class="subtext">Calls require internet connection</p></div>';
                contactsList.innerHTML = offlineMessage;
                groupContactsList.innerHTML = offlineMessage;
            }
        }
        
        function addContactItem(userData, container) {
            const contactItem = document.createElement('div');
            contactItem.className = 'contact-item always-visible';
            contactItem.dataset.userId = userData.uid;
            contactItem.style.display = 'flex';
            
            const initials = userData.displayName ? 
                userData.displayName.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2) : 
                'U';
            
            let statusText = userData.online ? 'Online now' : 
                userData.lastOnline < 5 ? 'Just now' :
                userData.lastOnline < 60 ? `${userData.lastOnline}m ago` :
                `${Math.floor(userData.lastOnline / 60)}h ago`;
            
            contactItem.innerHTML = `
                <input type="checkbox" class="contact-checkbox always-visible" id="contact_${userData.uid}" ${!isOnline ? 'disabled' : ''}>
                <div class="call-avatar always-visible" ${userData.photoURL ? `style="background-image: url('${userData.photoURL}')"` : ''}>
                    ${userData.photoURL ? '' : `<span>${initials}</span>`}
                    <div class="call-status-icon ${userData.online ? 'incoming' : 'missed'} always-visible" style="width: 12px; height: 12px;">
                        <i class="fas fa-circle" style="font-size: 6px;"></i>
                    </div>
                </div>
                <div class="call-info" style="flex: 1;">
                    <div class="call-name always-visible">
                        <span>${userData.displayName || 'User'}</span>
                    </div>
                    <div class="call-details always-visible">
                        <span style="color: ${userData.online ? 'var(--success-color)' : 'var(--text-secondary)'}">
                            ${statusText}
                        </span>
                    </div>
                </div>
            `;
            
            const checkbox = contactItem.querySelector('.contact-checkbox');
            checkbox.addEventListener('change', function() {
                if (!isOnline) {
                    showNotification('Cannot select contacts while offline', 'error');
                    this.checked = false;
                    return;
                }
                
                if (this.checked) {
                    selectedContacts.push(userData.uid);
                    contactItem.classList.add('selected');
                } else {
                    selectedContacts = selectedContacts.filter(id => id !== userData.uid);
                    contactItem.classList.remove('selected');
                }
            });
            
            container.appendChild(contactItem);
        }
        
        function addChatMessage(message, senderId, isSent = false) {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isSent ? 'sent' : 'received'} always-visible`;
            
            let senderName = 'Unknown';
            if (senderId === currentUser.uid) {
                senderName = 'You';
            } else {
                // Try to get sender name
                const getUserName = async () => {
                    try {
                        let userData = null;
                        
                        if (db) {
                            const userDoc = await db.collection('users').doc(senderId).get();
                            if (userDoc.exists) {
                                userData = userDoc.data();
                            }
                        }
                        
                        if (!userData) {
                            const cachedUser = localStorage.getItem(`userInfo_${senderId}`);
                            if (cachedUser) {
                                userData = JSON.parse(cachedUser);
                            }
                        }
                        
                        const nameElement = messageDiv.querySelector('.message-sender');
                        if (nameElement && userData) {
                            nameElement.textContent = userData.displayName || 'User';
                        }
                    } catch (error) {
                        console.error('Error getting sender name:', error);
                    }
                };
                
                getUserName();
            }
            
            messageDiv.innerHTML = `
                <div class="message-sender always-visible">${senderName}</div>
                <div class="message-content always-visible">${message}</div>
            `;
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function showNotification(message, type = 'success') {
            const notificationText = document.getElementById('notificationText');
            if (!notificationText) return;
            
            notificationText.textContent = message;
            
            notification.className = 'notification';
            notification.classList.add(type);
            
            notification.classList.add('active');
            
            setTimeout(() => {
                notification.classList.remove('active');
            }, 3000);
        }
        
        function handleCallControlMessage(data, senderId) {
            switch(data.action) {
                case 'mute-status':
                    console.log(`User ${senderId} mute status: ${data.muted}`);
                    break;
                case 'video-status':
                    console.log(`User ${senderId} video status: ${data.videoOff}`);
                    break;
            }
        }
        
        function setupEventListeners() {
            // Store original button texts for restoration when online
            const quickActionButtons = document.querySelectorAll('.quick-action-btn');
            quickActionButtons.forEach(button => {
                const textElement = button.querySelector('.quick-action-text');
                if (textElement) {
                    const originalText = textElement.textContent;
                    textElement.setAttribute('data-original-text', originalText);
                    // FEATURE 2 & 4: Initially add offline warning if offline (but keep button visible)
                    if (!isOnline) {
                        textElement.innerHTML = originalText + '<div class="offline-warning-text">(Offline)</div>';
                    }
                    button.classList.add('always-visible');
                }
            });
            
            // Store original button titles
            const callButtons = [
                'newCallBtn',
                'voiceCallBtn',
                'videoCallBtn',
                'groupCallBtn',
                'startCallBtn',
                'createVoiceLinkBtn',
                'createVideoLinkBtn',
                'addParticipantsBtn'
            ];
            
            callButtons.forEach(buttonId => {
                const button = document.getElementById(buttonId);
                if (button) {
                    if (button.title) {
                        button.setAttribute('data-original-title', button.title);
                    }
                    // FEATURE 4: Initially disable if offline (but keep visible)
                    if (!isOnline) {
                        button.disabled = true;
                        button.classList.add('disabled-by-offline');
                    }
                    button.classList.add('always-visible');
                }
            });
            
            // Settings toggle
            settingsToggle.addEventListener('click', function() {
                if (!settingsPanel) return;
                
                settingsPanel.classList.toggle('active');
                const icon = this.querySelector('i.fa-chevron-down');
                if (icon) {
                    icon.classList.toggle('fa-chevron-down');
                    icon.classList.toggle('fa-chevron-up');
                }
            });
            
            // Settings toggles
            const reactionsToggle = document.getElementById('reactionsToggle');
            const chatToggle = document.getElementById('chatToggle');
            const whiteboardToggle = document.getElementById('whiteboardToggle');
            const pollsToggle = document.getElementById('pollsToggle');
            const notesToggle = document.getElementById('notesToggle');
            
            if (reactionsToggle) {
                reactionsToggle.addEventListener('change', function() {
                    userSettings.reactions = this.checked;
                    applyUserSettings();
                    saveUserSettings();
                });
            }
            
            if (chatToggle) {
                chatToggle.addEventListener('change', function() {
                    userSettings.chat = this.checked;
                    applyUserSettings();
                    saveUserSettings();
                });
            }
            
            if (whiteboardToggle) {
                whiteboardToggle.addEventListener('change', function() {
                    userSettings.whiteboard = this.checked;
                    applyUserSettings();
                    saveUserSettings();
                });
            }
            
            if (pollsToggle) {
                pollsToggle.addEventListener('change', function() {
                    userSettings.polls = this.checked;
                    applyUserSettings();
                    saveUserSettings();
                });
            }
            
            if (notesToggle) {
                notesToggle.addEventListener('change', function() {
                    userSettings.notes = this.checked;
                    applyUserSettings();
                    saveUserSettings();
                });
            }
            
            // Reset settings button
            const resetSettingsBtn = document.getElementById('resetSettingsBtn');
            if (resetSettingsBtn) {
                resetSettingsBtn.addEventListener('click', resetSettingsToDefault);
                resetSettingsBtn.classList.add('always-visible');
            }
            
            // New call button - FEATURE 4: Disabled when offline (but visible)
            document.getElementById('newCallBtn').addEventListener('click', () => {
                if (!isOnline) {
                    showNotification('Cannot start call while offline', 'error');
                    return;
                }
                
                newCallModal.classList.add('active');
                loadContacts();
                selectedContacts = [];
            });
            
            // Quick action buttons - FEATURE 4: Disabled when offline (but visible)
            document.getElementById('voiceCallBtn').addEventListener('click', () => {
                if (!isOnline) {
                    showNotification('Cannot start call while offline', 'error');
                    return;
                }
                
                newCallModal.classList.add('active');
                document.querySelector('.new-call-tab[data-tab="contacts"]').click();
            });
            
            document.getElementById('videoCallBtn').addEventListener('click', () => {
                if (!isOnline) {
                    showNotification('Cannot start call while offline', 'error');
                    return;
                }
                
                newCallModal.classList.add('active');
                document.querySelector('.new-call-tab[data-tab="contacts"]').click();
            });
            
            document.getElementById('groupCallBtn').addEventListener('click', () => {
                if (!isOnline) {
                    showNotification('Cannot start call while offline', 'error');
                    return;
                }
                
                newCallModal.classList.add('active');
                document.querySelector('.new-call-tab[data-tab="group"]').click();
            });
            
            // Close new call modal
            document.getElementById('closeNewCallModal').addEventListener('click', () => {
                newCallModal.classList.remove('active');
                selectedContacts = [];
            });
            
            document.getElementById('cancelNewCallBtn').addEventListener('click', () => {
                newCallModal.classList.remove('active');
                selectedContacts = [];
            });
            
            // New call tabs
            document.querySelectorAll('.new-call-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabName = this.dataset.tab;
                    
                    document.querySelectorAll('.new-call-tab').forEach(t => {
                        t.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    document.querySelectorAll('.new-call-tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    const tabContent = document.getElementById(`${tabName}Tab`);
                    if (tabContent) {
                        tabContent.classList.add('active');
                    }
                });
            });
            
            // Start call button - FEATURE 4: Disabled when offline (but visible)
            document.getElementById('startCallBtn').addEventListener('click', async () => {
                if (!isOnline) {
                    showNotification('Cannot start call while offline', 'error');
                    return;
                }
                
                const activeTab = document.querySelector('.new-call-tab.active');
                if (!activeTab) return;
                
                const activeTabName = activeTab.dataset.tab;
                
                if (activeTabName === 'contacts') {
                    if (selectedContacts.length === 0) {
                        showNotification('Please select at least one contact', 'error');
                        return;
                    }
                    
                    if (selectedContacts.length === 1) {
                        startCall(selectedContacts[0], 'video');
                    } else {
                        startGroupCall(selectedContacts);
                    }
                    
                } else if (activeTabName === 'group') {
                    if (selectedContacts.length === 0) {
                        showNotification('Please select participants', 'error');
                        return;
                    }
                    
                    startGroupCall(selectedContacts);
                    
                } else if (activeTabName === 'link') {
                    showNotification('Call link feature requires backend setup', 'warning');
                }
                
                newCallModal.classList.remove('active');
                selectedContacts = [];
            });
            
            // Incoming call buttons - FEATURE 4: Disabled when offline
            document.getElementById('declineCallBtn').addEventListener('click', function() {
                this.disabled = true;
                declineCall();
            });
            
            document.getElementById('acceptCallBtn').addEventListener('click', function() {
                this.disabled = true;
                acceptCall('voice');
            });
            
            document.getElementById('acceptVideoCallBtn').addEventListener('click', function() {
                this.disabled = true;
                acceptCall('video');
            });
            
            // Call control buttons - FEATURE 3: Always visible, even when offline
            document.getElementById('muteBtn').addEventListener('click', function() {
                if (localStream) {
                    const audioTrack = localStream.getAudioTracks()[0];
                    if (audioTrack) {
                        audioTrack.enabled = !audioTrack.enabled;
                        isMuted = !audioTrack.enabled;
                        
                        this.classList.toggle('active', isMuted);
                        const icon = this.querySelector('i');
                        if (isMuted) {
                            icon.className = 'fas fa-microphone-slash';
                        } else {
                            icon.className = 'fas fa-microphone';
                        }
                        
                        showNotification(isMuted ? 'Microphone muted' : 'Microphone unmuted', 'success');
                        
                        // Only broadcast if online and in a call
                        if (isOnline && currentCall) {
                            broadcastDataMessage({
                                type: 'call-control',
                                action: 'mute-status',
                                muted: isMuted,
                                userId: currentUser.uid
                            });
                        }
                    }
                } else if (!isOnline) {
                    // When offline, just toggle the UI state
                    isMuted = !isMuted;
                    this.classList.toggle('active', isMuted);
                    const icon = this.querySelector('i');
                    if (isMuted) {
                        icon.className = 'fas fa-microphone-slash';
                        showNotification('Microphone would be muted in a real call', 'info');
                    } else {
                        icon.className = 'fas fa-microphone';
                        showNotification('Microphone would be unmuted in a real call', 'info');
                    }
                }
            });
            
            document.getElementById('videoBtn').addEventListener('click', function() {
                if (localStream) {
                    const videoTrack = localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        videoTrack.enabled = !videoTrack.enabled;
                        isVideoOff = !videoTrack.enabled;
                        
                        this.classList.toggle('active', isVideoOff);
                        const icon = this.querySelector('i');
                        if (isVideoOff) {
                            icon.className = 'fas fa-video-slash';
                        } else {
                            icon.className = 'fas fa-video';
                        }
                        
                        showNotification(isVideoOff ? 'Video turned off' : 'Video turned on', 'success');
                        
                        // Only broadcast if online and in a call
                        if (isOnline && currentCall) {
                            broadcastDataMessage({
                                type: 'call-control',
                                action: 'video-status',
                                videoOff: isVideoOff,
                                userId: currentUser.uid
                            });
                        }
                    }
                } else if (!isOnline) {
                    // When offline, just toggle the UI state
                    isVideoOff = !isVideoOff;
                    this.classList.toggle('active', isVideoOff);
                    const icon = this.querySelector('i');
                    if (isVideoOff) {
                        icon.className = 'fas fa-video-slash';
                        showNotification('Video would be turned off in a real call', 'info');
                    } else {
                        icon.className = 'fas fa-video';
                        showNotification('Video would be turned on in a real call', 'info');
                    }
                }
            });
            
            document.getElementById('speakerBtn').addEventListener('click', function() {
                isSpeakerOn = !isSpeakerOn;
                this.classList.toggle('active', isSpeakerOn);
                
                const icon = this.querySelector('i');
                if (isSpeakerOn) {
                    icon.className = 'fas fa-volume-mute';
                    showNotification('Speaker would be muted in a real call', 'info');
                } else {
                    icon.className = 'fas fa-volume-up';
                    showNotification('Speaker would be unmuted in a real call', 'info');
                }
            });
            
            document.getElementById('screenShareBtn').addEventListener('click', function() {
                if (!isOnline) {
                    showNotification('Screen sharing requires internet connection', 'error');
                    return;
                }
                
                if (isScreenSharing) {
                    this.classList.remove('active');
                }
                shareScreen();
            });
            
            // More button - FEATURE 3: Always visible, opens side panel
            document.getElementById('moreBtn').addEventListener('click', function() {
                callSidePanel.classList.toggle('collapsed');
                // Show offline message if offline
                if (!isOnline && callSidePanel.classList.contains('collapsed')) {
                    showNotification('Call features panel opened (offline mode)', 'info');
                }
            });
            
            document.getElementById('endCallBtn').addEventListener('click', function() {
                this.disabled = true;
                endCall();
            });
            
            // Close side panel
            document.getElementById('closePanelBtn').addEventListener('click', () => {
                callSidePanel.classList.add('collapsed');
            });
            
            // Panel tabs - FEATURE 4: Disable some tabs when offline (but keep visible)
            document.querySelectorAll('.panel-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const panelName = this.dataset.panel;
                    
                    // Check if offline and trying to access features that require internet
                    if (!isOnline && panelName !== 'participants') {
                        showNotification('This feature requires internet connection', 'error');
                        return;
                    }
                    
                    let isEnabled = true;
                    switch(panelName) {
                        case 'chat':
                            isEnabled = userSettings.chat;
                            break;
                        case 'whiteboard':
                            isEnabled = userSettings.whiteboard;
                            break;
                        case 'notes':
                            isEnabled = userSettings.notes;
                            break;
                        case 'polls':
                            isEnabled = userSettings.polls;
                            break;
                    }
                    
                    if (!isEnabled) {
                        showNotification('This feature is disabled in your settings', 'warning');
                        return;
                    }
                    
                    document.querySelectorAll('.panel-tab').forEach(t => {
                        t.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    const panelTitle = document.getElementById('panelTitle');
                    if (panelTitle) {
                        panelTitle.textContent = panelName.charAt(0).toUpperCase() + panelName.slice(1);
                    }
                    
                    document.querySelectorAll('.panel-section').forEach(section => {
                        section.classList.remove('active');
                    });
                    
                    const panelElement = document.getElementById(`${panelName}Panel`);
                    if (panelElement) {
                        panelElement.classList.add('active');
                    }
                });
            });
            
            // Add participants button - FEATURE 4: Disabled when offline
            document.getElementById('addParticipantsBtn').addEventListener('click', () => {
                if (!isOnline) {
                    showNotification('Cannot add participants while offline', 'error');
                    return;
                }
                
                newCallModal.classList.add('active');
                document.querySelector('.new-call-tab[data-tab="contacts"]').click();
            });
            
            // Chat functionality
            document.getElementById('sendChatBtn').addEventListener('click', () => {
                if (!userSettings.chat) {
                    showNotification('Chat is disabled in your settings', 'warning');
                    return;
                }
                
                if (!isOnline) {
                    showNotification('Chat requires internet connection', 'error');
                    return;
                }
                
                const chatInput = document.getElementById('chatInput');
                const message = chatInput.value.trim();
                
                if (message) {
                    addChatMessage(message, currentUser.uid, true);
                    
                    broadcastDataMessage({
                        type: 'chat',
                        message: message,
                        senderId: currentUser.uid,
                        senderName: currentUser.displayName || 'User',
                        timestamp: new Date().toISOString()
                    });
                    
                    chatInput.value = '';
                }
            });
            
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('sendChatBtn').click();
                }
            });
            
            // Whiteboard tools
            document.querySelectorAll('[data-tool]').forEach(toolBtn => {
                toolBtn.addEventListener('click', function() {
                    if (!userSettings.whiteboard) {
                        showNotification('Whiteboard is disabled in your settings', 'warning');
                        return;
                    }
                    
                    if (!isOnline) {
                        showNotification('Whiteboard requires internet connection', 'error');
                        return;
                    }
                    
                    currentTool = this.dataset.tool;
                    
                    document.querySelectorAll('[data-tool]').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    this.classList.add('active');
                });
            });
            
            document.getElementById('clearWhiteboardBtn').addEventListener('click', clearWhiteboard);
            
            // Notes functionality
            document.getElementById('saveNoteBtn').addEventListener('click', () => {
                if (!userSettings.notes) {
                    showNotification('Notes are disabled in your settings', 'warning');
                    return;
                }
                
                const note = document.getElementById('notesInput').value;
                localStorage.setItem(`call_note_${Date.now()}`, note);
                showNotification('Note saved locally', 'success');
            });
            
            document.getElementById('loadNotesBtn').addEventListener('click', () => {
                if (!userSettings.notes) {
                    showNotification('Notes are disabled in your settings', 'warning');
                    return;
                }
                
                // Load previous notes from localStorage
                const notes = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('call_note_')) {
                        notes.push({
                            key: key,
                            value: localStorage.getItem(key),
                            time: new Date(parseInt(key.split('_')[2]))
                        });
                    }
                }
                
                if (notes.length === 0) {
                    showNotification('No previous notes found', 'warning');
                    return;
                }
                
                // Sort by most recent
                notes.sort((a, b) => b.time - a.time);
                
                // Show the most recent note
                const mostRecentNote = notes[0];
                document.getElementById('notesInput').value = mostRecentNote.value;
                
                // Trigger preview update
                const event = new Event('input');
                document.getElementById('notesInput').dispatchEvent(event);
                
                showNotification('Loaded previous note', 'success');
            });
            
            document.getElementById('notesInput').addEventListener('input', function() {
                const markdown = this.value;
                const html = marked.parse(markdown);
                document.getElementById('notesPreview').innerHTML = html;
            });
            
            // Reactions - FEATURE 3: Work offline for UI exploration
            document.querySelectorAll('.reaction-btn').forEach(reactionBtn => {
                reactionBtn.addEventListener('click', function() {
                    if (!userSettings.reactions) {
                        showNotification('Reactions are disabled in your settings', 'warning');
                        return;
                    }
                    
                    const reaction = this.dataset.reaction;
                    showFloatingReaction(reaction);
                    
                    // Only broadcast if online and in a call
                    if (isOnline && currentCall) {
                        broadcastDataMessage({
                            type: 'reaction',
                            reaction: reaction,
                            userId: currentUser.uid,
                            timestamp: new Date().toISOString()
                        });
                    } else if (!isOnline) {
                        showNotification('Reaction shown locally (offline mode)', 'info');
                    }
                });
            });
            
            // Category tabs - FEATURE 2 & 3: Always visible and work offline
            document.getElementById('allTab').addEventListener('click', function() {
                document.querySelectorAll('.category-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                document.querySelectorAll('.calls-section').forEach(section => {
                    section.classList.remove('active');
                });
                allCallsSection.classList.add('active');
                
                // Ensure mobile layout is correct
                setTimeout(fixMobileLayout, 10);
            });
            
            document.getElementById('missedTab').addEventListener('click', function() {
                document.querySelectorAll('.category-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                document.querySelectorAll('.calls-section').forEach(section => {
                    section.classList.remove('active');
                });
                missedCallsSection.classList.add('active');
                
                // Load missed calls if not already loaded
                if (missedCallsList.children.length === 0) {
                    if (isOnline) {
                        loadMissedCalls();
                    } else {
                        // FEATURE 2: Load missed calls from local storage when offline
                        const storedCalls = localStorage.getItem(getLocalStorageKey('history'));
                        if (storedCalls) {
                            const calls = JSON.parse(storedCalls);
                            const missedCalls = calls.filter(call => call.status === 'missed');
                            displayCallsFromArray(missedCalls, missedCallsList, 'missed');
                        }
                    }
                }
                
                // Ensure mobile layout is correct
                setTimeout(fixMobileLayout, 10);
            });
            
            document.getElementById('groupsTab').addEventListener('click', function() {
                document.querySelectorAll('.category-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                document.querySelectorAll('.calls-section').forEach(section => {
                    section.classList.remove('active');
                });
                groupCallsSection.classList.add('active');
                
                // Load group calls if not already loaded
                if (groupCallsList.children.length === 0) {
                    if (isOnline) {
                        loadGroupCalls();
                    } else {
                        // FEATURE 2: Load group calls from local storage when offline
                        const storedCalls = localStorage.getItem(getLocalStorageKey('history'));
                        if (storedCalls) {
                            const calls = JSON.parse(storedCalls);
                            const groupCalls = calls.filter(call => call.group === true || (call.participants && call.participants.length > 2));
                            displayCallsFromArray(groupCalls, groupCallsList, 'group');
                        }
                    }
                }
                
                // Ensure mobile layout is correct
                setTimeout(fixMobileLayout, 10);
            });
            
            // Window resize - FEATURE 6: Ensure responsive design
            window.addEventListener('resize', () => {
                if (whiteboardCanvas) {
                    whiteboardCanvas.width = whiteboardCanvas.offsetWidth;
                    whiteboardCanvas.height = whiteboardCanvas.offsetHeight;
                }
                updateVideoGrid();
                fixMobileLayout();
            });
            
            // Handle before unload
            window.addEventListener('beforeunload', () => {
                if (currentCall) {
                    endCall();
                }
                
                if (userPresenceRef && isOnline) {
                    userPresenceRef.update({
                        online: false,
                        lastOnline: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
                
                // Clear offline check interval
                if (offlineCheckInterval) {
                    clearInterval(offlineCheckInterval);
                }
            });
            
            setupCallInvitationListener();
            
            // Initialize call container in view-only mode when offline
            if (!isOnline) {
                // Show call container with placeholder when offline
                callContainer.classList.add('active');
                document.getElementById('callParticipants').textContent = 'Offline Mode';
                document.getElementById('callStatus').textContent = 'Call features require internet connection';
                offlineCallPlaceholder.style.display = 'flex';
                callContainer.classList.add('offline-ui-active');
            }
        }
        
        function setupCallInvitationListener() {
            if (!currentUser || !isOnline || !db) return;
            
            db.collection('callInvitations')
                .where('to', '==', currentUser.uid)
                .where('status', '==', 'ringing')
                .where('expiresAt', '>', new Date())
                .onSnapshot(snapshot => {
                    snapshot.docChanges().forEach(change => {
                        if (change.type === 'added') {
                            const invitation = change.doc.data();
                            console.log('New call invitation:', invitation);
                            
                            if (!window.incomingCall) {
                                showNotification(`Incoming call from user`, 'warning');
                                
                                db.collection('users').doc(invitation.from).get().then(doc => {
                                    if (doc.exists) {
                                        const callerData = doc.data();
                                        showNotification(`Missed call from ${callerData.displayName}`, 'warning');
                                    }
                                });
                            }
                        }
                    });
                });
        }
        
        setInterval(() => {
            if (userPresenceRef && currentUser && isOnline) {
                userPresenceRef.update({
                    lastOnline: firebase.firestore.FieldValue.serverTimestamp()
                });
            }
        }, 30000);
        
        console.log('Video call system initialized successfully');
        showNotification('Video call system ready', 'success');
    </script>
    <script>
    // Settings integration for [Page Name]
    let pageSettings = null;
    
    function initializePageSettings() {
        if (window.KYNECTA_SETTINGS) {
            window.KYNECTA_SETTINGS.registerPageCallback('[page-name]-page', applyPageSettings);
            pageSettings = window.KYNECTA_SETTINGS.currentSettings;
            applyPageSettings(pageSettings);
        }
    }
    
    function applyPageSettings(settings) {
        console.log('[Page] applying settings:', settings);
        pageSettings = settings;
        
        // Apply theme
        const container = document.getElementById('mainContainer') || document.body;
        container.className = container.className.replace(/theme-\S+/g, '');
        if (settings.appearance.theme) {
            container.classList.add(`theme-${settings.appearance.theme}`);
        }
        
        // Apply font size
        container.className = container.className.replace(/font-\S+/g, '');
        if (settings.appearance.fontSize) {
            container.classList.add(`font-${settings.appearance.fontSize}`);
        }
        
        // Apply privacy settings
        if (settings.privacy) {
            // Example: Hide last seen based on privacy settings
            const lastSeenElements = document.querySelectorAll('.last-seen');
            lastSeenElements.forEach(el => {
                if (settings.privacy.lastSeenVisibility === 'nobody') {
                    el.textContent = 'Last seen hidden';
                }
            });
        }
        
        // Apply notification settings
        if (settings.notifications) {
            // Enable/disable notification sounds
            window.notificationSoundsEnabled = settings.notifications.sound;
        }
        
        // Apply chat settings
        if (settings.chat && document.getElementById('messageInput')) {
            // Set enter to send behavior
            const messageInput = document.getElementById('messageInput');
            messageInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    if (settings.chat.enterToSend && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                }
            });
        }
    }
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        if (window.KYNECTA_SETTINGS) {
            window.KYNECTA_SETTINGS.unregisterPageCallback('[page-name]-page');
        }
    });
    
    // Initialize
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializePageSettings);
    } else {
        setTimeout(initializePageSettings, 100);
    }
</script>
</body>
</html>