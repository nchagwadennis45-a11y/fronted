<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="manifest" href="../manifest.json">
    <meta name="theme-color" content="#4F46E5">
    <link rel="icon" href="../icons/moodchat-192.png">
    <link rel="icon" href="../icons/moodchat-512.png">
    <meta name="theme-color" content="#000000">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Messages | Chat App</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-storage-compat.js"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Emoji Picker -->
    <script src="https://cdn.jsdelivr.net/npm/emoji-picker-element@1/dist/index.js"></script>
    
    <!-- WaveSurfer.js for voice messages -->
    <script src="https://unpkg.com/wavesurfer.js@7"></script>
    
    <style>
        /* INSTANT LOADING STYLES */
        .instant-load {
            transition: opacity 0.3s ease;
        }
        
        .hidden {
            display: none !important;
        }
        
        .visible {
            display: block !important;
        }
        
        /* OFFLINE INDICATOR */
        .offline-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: #ff9500;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 2000;
            display: none;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
        
        .offline-indicator.active {
            display: flex;
        }
        
        /* Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        :root {
            --primary-color: #0084ff;
            --primary-dark: #0073e6;
            --secondary-color: #f0f2f5;
            --danger-color: #ff3b30;
            --success-color: #34c759;
            --warning-color: #ff9500;
            --text-primary: #050505;
            --text-secondary: #65676b;
            --bg-color: #ffffff;
            --border-color: #dddfe2;
            --message-sent-bg: #0084ff;
            --message-received-bg: #f0f2f5;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 30px rgba(0, 0, 0, 0.2);
            --unread-badge: #ff3b30;
            --online-indicator: #34c759;
            --typing-indicator: #0084ff;
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }
        
        .app-container {
            display: flex;
            height: 100vh;
        }
        
        /* Sidebar Styles */
        .sidebar {
            width: 380px;
            background-color: var(--bg-color);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }
        
        .sidebar-header {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }
        
        .sidebar-header h2 {
            font-size: 24px;
            font-weight: 600;
        }
        
        .header-actions {
            display: flex;
            gap: 15px;
        }
        
        .header-btn {
            background: none;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s;
            font-size: 18px;
        }
        
        .header-btn:hover {
            background-color: var(--secondary-color);
            color: var(--primary-color);
        }
        
        /* Search Bar */
        .search-container {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .search-box {
            position: relative;
        }
        
        .search-input {
            width: 100%;
            padding: 12px 20px 12px 45px;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            background-color: var(--secondary-color);
            font-size: 15px;
            transition: all 0.2s;
        }
        
        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            background-color: var(--bg-color);
        }
        
        .search-icon {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }
        
        /* Chat Categories */
        .chat-categories {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            overflow-x: auto;
            background-color: var(--bg-color);
        }
        
        .category-btn {
            flex: none;
            padding: 15px 20px;
            text-align: center;
            font-weight: 500;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }
        
        .category-btn.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        
        .category-btn:hover {
            background-color: var(--secondary-color);
        }
        
        /* Chat List */
        .chat-list {
            flex: 1;
            overflow-y: auto;
        }
        
        .chat-section-title {
            padding: 15px 20px;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .clear-all-btn {
            background: none;
            border: none;
            color: var(--primary-color);
            font-size: 13px;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
        }
        
        .clear-all-btn:hover {
            background-color: var(--secondary-color);
        }
        
        .chat-item {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
            border-bottom: 1px solid var(--border-color);
        }
        
        .chat-item:hover {
            background-color: var(--secondary-color);
        }
        
        .chat-item.active {
            background-color: #e8f4ff;
            border-left: 3px solid var(--primary-color);
        }
        
        .chat-item.unread {
            background-color: #f8f9ff;
        }
        
        .chat-avatar {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
            margin-right: 15px;
            position: relative;
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }
        
        .online-status {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background-color: var(--online-indicator);
            border-radius: 50%;
            border: 2px solid var(--bg-color);
        }
        
        .offline-status {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background-color: #ccc;
            border-radius: 50%;
            border: 2px solid var(--bg-color);
        }
        
        .chat-info {
            flex: 1;
            min-width: 0;
        }
        
        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .chat-name {
            font-weight: 600;
            font-size: 16px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .chat-time {
            font-size: 12px;
            color: var(--text-secondary);
            white-space: nowrap;
        }
        
        .chat-preview {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .chat-message {
            font-size: 14px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }
        
        .message-status {
            color: var(--primary-color);
            font-size: 14px;
        }
        
        .unread-badge {
            background-color: var(--unread-badge);
            color: white;
            font-size: 12px;
            min-width: 20px;
            height: 20px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 6px;
            font-weight: 600;
        }
        
        /* Start New Chat Button */
        .start-chat-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: var(--shadow-lg);
            z-index: 100;
            transition: all 0.2s;
        }
        
        .start-chat-btn:hover {
            background-color: var(--primary-dark);
            transform: scale(1.05);
        }
        
        /* Chat Area */
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-color);
            position: relative;
        }
        
        .no-chat-selected {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            text-align: center;
            color: var(--text-secondary);
        }
        
        .no-chat-icon {
            font-size: 80px;
            color: var(--secondary-color);
            margin-bottom: 20px;
        }
        
        .no-chat-text {
            font-size: 18px;
            margin-bottom: 10px;
            color: var(--text-primary);
        }
        
        .no-chat-subtext {
            font-size: 14px;
            max-width: 300px;
        }
        
        /* Chat Header */
        .chat-header-area {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--bg-color);
            z-index: 10;
        }
        
        .chat-user-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .chat-user-avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: white;
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }
        
        .chat-user-details h4 {
            font-size: 17px;
            font-weight: 600;
            margin-bottom: 3px;
        }
        
        .chat-user-details p {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            color: var(--typing-indicator);
        }
        
        .typing-dots {
            display: flex;
            gap: 3px;
        }
        
        .typing-dots span {
            width: 6px;
            height: 6px;
            background-color: var(--typing-indicator);
            border-radius: 50%;
            animation: typing 1.4s infinite ease-in-out;
        }
        
        .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
        .typing-dots span:nth-child(2) { animation-delay: -0.16s; }
        
        @keyframes typing {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }
        
        .chat-header-actions {
            display: flex;
            gap: 10px;
        }
        
        /* Messages Container */
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background-color: #f8f9fa;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .message-date {
            text-align: center;
            margin: 20px 0;
            position: relative;
        }
        
        .date-label {
            display: inline-block;
            background-color: var(--secondary-color);
            color: var(--text-secondary);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 13px;
        }
        
        /* Message Bubbles */
        .message-row {
            display: flex;
            margin-bottom: 5px;
        }
        
        .message-row.sent {
            justify-content: flex-end;
        }
        
        .message-row.received {
            justify-content: flex-start;
        }
        
        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            position: relative;
            word-wrap: break-word;
        }
        
        .sent .message-bubble {
            background-color: var(--message-sent-bg);
            color: white;
            border-bottom-right-radius: 5px;
        }
        
        .received .message-bubble {
            background-color: var(--message-received-bg);
            color: var(--text-primary);
            border-bottom-left-radius: 5px;
        }
        
        .message-text {
            font-size: 15px;
            line-height: 1.4;
        }
        
        .message-info {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 8px;
            margin-top: 5px;
            font-size: 12px;
        }
        
        .sent .message-info {
            color: rgba(255, 255, 255, 0.8);
        }
        
        .received .message-info {
            color: var(--text-secondary);
        }
        
        .message-time {
            white-space: nowrap;
        }
        
        .message-status-icon {
            font-size: 13px;
        }
        
        /* Message Types */
        .message-image {
            max-width: 300px;
            border-radius: 15px;
            margin-top: 5px;
            cursor: pointer;
        }
        
        .message-video {
            max-width: 300px;
            border-radius: 15px;
            margin-top: 5px;
            cursor: pointer;
        }
        
        .voice-message {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 20px;
            margin-top: 5px;
        }
        
        .voice-play-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .voice-waveform {
            flex: 1;
            height: 30px;
        }
        
        .voice-duration {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .message-file {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
            margin-top: 5px;
            text-decoration: none;
            color: inherit;
        }
        
        .file-icon {
            font-size: 24px;
            color: var(--primary-color);
        }
        
        .file-info {
            flex: 1;
        }
        
        .file-name {
            font-weight: 500;
            font-size: 14px;
        }
        
        .file-size {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        /* Input Area */
        .input-area {
            padding: 20px;
            border-top: 1px solid var(--border-color);
            background-color: var(--bg-color);
        }
        
        .message-input-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .input-actions {
            display: flex;
            gap: 10px;
        }
        
        .input-action-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
        }
        
        .input-action-btn:hover {
            background-color: var(--secondary-color);
            color: var(--primary-color);
        }
        
        .message-input-wrapper {
            flex: 1;
            position: relative;
        }
        
        .message-input {
            width: 100%;
            padding: 12px 20px;
            border-radius: 25px;
            border: 1px solid var(--border-color);
            background-color: var(--secondary-color);
            font-size: 15px;
            resize: none;
            max-height: 120px;
            min-height: 40px;
            line-height: 1.4;
        }
        
        .message-input:focus {
            outline: none;
            border-color: var(--primary-color);
            background-color: var(--bg-color);
        }
        
        .send-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
        }
        
        .send-btn:hover {
            background-color: var(--primary-dark);
            transform: scale(1.05);
        }
        
        .send-btn:disabled {
            background-color: var(--border-color);
            cursor: not-allowed;
            transform: none;
        }
        
        /* Emoji Picker */
        .emoji-picker-container {
            position: absolute;
            bottom: 70px;
            left: 0;
            z-index: 1000;
            background: var(--bg-color);
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .emoji-picker-container.active {
            display: block;
        }
        
        /* Attachments Menu */
        .attachments-menu {
            position: absolute;
            bottom: 70px;
            left: 60px;
            background: var(--bg-color);
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            display: none;
            z-index: 1000;
            padding: 10px;
            min-width: 200px;
        }
        
        .attachments-menu.active {
            display: block;
        }
        
        .attachment-option {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px 15px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.2s;
        }
        
        .attachment-option:hover {
            background-color: var(--secondary-color);
        }
        
        .attachment-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: var(--primary-color);
        }
        
        .attachment-text {
            flex: 1;
        }
        
        .attachment-title {
            font-weight: 500;
            font-size: 14px;
        }
        
        .attachment-desc {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        /* New Chat Modal */
        .new-chat-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .new-chat-modal.active {
            display: flex;
        }
        
        .new-chat-container {
            width: 90%;
            max-width: 500px;
            background-color: var(--bg-color);
            border-radius: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: 90vh;
            box-shadow: var(--shadow-lg);
        }
        
        .new-chat-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(45deg, #0084ff, #00c6ff);
            color: white;
        }
        
        .new-chat-header h3 {
            font-size: 20px;
            font-weight: 600;
        }
        
        .new-chat-close {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
        }
        
        .new-chat-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .new-chat-search {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .new-chat-search-input {
            width: 100%;
            padding: 12px 20px;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            background-color: var(--secondary-color);
            font-size: 15px;
        }
        
        .new-chat-search-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        .contacts-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }
        
        .contact-item {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .contact-item:hover {
            background-color: var(--secondary-color);
        }
        
        .contact-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: white;
            margin-right: 15px;
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }
        
        .contact-info {
            flex: 1;
        }
        
        .contact-name {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 3px;
        }
        
        .contact-status {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .contact-status.online {
            color: var(--success-color);
        }
        
        /* Loading States */
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }
        
        .spinner {
            border: 3px solid var(--secondary-color);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Notifications */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--success-color);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
        }
        
        .notification.active {
            transform: translateY(0);
            opacity: 1;
        }
        
        .notification.error {
            background-color: var(--danger-color);
        }
        
        .notification.warning {
            background-color: var(--warning-color);
        }
        
        .notification.info {
            background-color: var(--primary-color);
        }
        
        /* Message Reactions */
        .message-reactions {
            position: absolute;
            bottom: -20px;
            right: 10px;
            display: flex;
            gap: 5px;
            background: var(--bg-color);
            padding: 3px 8px;
            border-radius: 12px;
            box-shadow: var(--shadow);
            font-size: 12px;
        }
        
        .reaction {
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .reaction:hover {
            transform: scale(1.2);
        }
        
        .reaction-count {
            margin-left: 3px;
            font-size: 10px;
            color: var(--text-secondary);
        }
        
        /* Message Menu */
        .message-menu {
            position: absolute;
            background: var(--bg-color);
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            z-index: 100;
            display: none;
            min-width: 150px;
            overflow: hidden;
        }
        
        .message-menu.active {
            display: block;
        }
        
        .menu-item {
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background-color 0.2s;
        }
        
        .menu-item:hover {
            background-color: var(--secondary-color);
        }
        
        /* Responsive */
        @media (max-width: 1024px) {
            .sidebar {
                width: 350px;
            }
        }
        
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 100%;
                position: absolute;
                z-index: 100;
                display: none;
            }
            
            .sidebar.active {
                display: flex;
            }
            
            .chat-area {
                display: none;
            }
            
            .chat-area.active {
                display: flex;
            }
            
            .back-to-chats {
                display: flex !important;
            }
        }
        
        .back-to-chats {
            display: none;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            margin-right: 10px;
            font-size: 20px;
        }
        
        .back-to-chats:hover {
            background-color: var(--secondary-color);
        }
        
        /* Smooth transitions */
        .chat-item-enter {
            opacity: 0;
            transform: translateY(10px);
        }
        
        .chat-item-enter-active {
            opacity: 1;
            transform: translateY(0);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .message-enter {
            opacity: 0;
            transform: translateY(10px);
        }
        
        .message-enter-active {
            opacity: 1;
            transform: translateY(0);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Offline Indicator -->
    <div class="offline-indicator" id="offlineIndicator">
        <i class="fas fa-wifi-slash"></i>
        <span>You're offline. Messages will sync when back online.</span>
    </div>
    
    <div class="app-container">
        <!-- Sidebar with chat list -->
        <div class="sidebar active" id="sidebar">
            <div class="sidebar-header">
                <h2>Messages</h2>
                <div class="header-actions">
                    <button class="header-btn" id="settingsBtn" title="Settings">
                        <i class="fas fa-cog"></i>
                    </button>
                    <button class="header-btn" id="newGroupBtn" title="Groups">
                        <i class="fas fa-users"></i>
                    </button>
                    <button class="header-btn" id="menuBtn" title="Menu">
                        <i class="fas fa-ellipsis-v"></i>
                    </button>
                </div>
            </div>
            
            <div class="search-container">
                <div class="search-box">
                    <i class="fas fa-search search-icon"></i>
                    <input type="text" class="search-input" id="searchInput" placeholder="Search messages...">
                </div>
            </div>
            
            <div class="chat-categories">
                <button class="category-btn active" id="allChatsTab">All</button>
                <button class="category-btn" id="unreadChatsTab">Unread</button>
                <button class="category-btn" id="sentChatsTab">Sent</button>
                <button class="category-btn" id="receivedChatsTab">Received</button>
                <button class="category-btn" id="groupsTab">Groups</button>
                <button class="category-btn" id="archivedTab">Archived</button>
            </div>
            
            <div class="chat-list" id="chatList">
                <!-- Chats will be loaded instantly from cache -->
                <div class="chat-section-title">
                    <span>Recent Chats</span>
                    <button class="clear-all-btn" id="clearAllBtn" style="display: none;">Clear All</button>
                </div>
                <div id="recentChatsList">
                    <!-- Recent chats will be loaded here -->
                </div>
                
                <div class="chat-section-title" style="display: none;" id="searchResultsTitle">
                    <span>Search Results</span>
                    <button class="clear-all-btn" id="clearSearchBtn">Clear</button>
                </div>
                <div id="searchResultsList" style="display: none;">
                    <!-- Search results will be loaded here -->
                </div>
            </div>
        </div>
        
        <!-- Chat Area -->
        <div class="chat-area" id="chatArea">
            <div class="no-chat-selected" id="noChatSelected">
                <div class="no-chat-icon">
                    <i class="fas fa-comments"></i>
                </div>
                <div class="no-chat-text">Your messages</div>
                <div class="no-chat-subtext">Select a chat to start messaging or start a new conversation</div>
                <button class="start-chat-btn" id="startNewChatBtn" style="position: relative; margin-top: 30px;">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
            
            <!-- Active Chat View -->
            <div class="chat-active-view" id="chatActiveView" style="display: none; flex-direction: column; height: 100%;">
                <div class="chat-header-area">
                    <div class="chat-user-info">
                        <button class="back-to-chats" id="backToChatsBtn">
                            <i class="fas fa-arrow-left"></i>
                        </button>
                        <div class="chat-user-avatar" id="chatUserAvatar">
                            <i class="fas fa-user"></i>
                        </div>
                        <div class="chat-user-details">
                            <h4 id="chatUserName">User Name</h4>
                            <p id="chatUserStatus">Online</p>
                            <div class="typing-indicator" id="typingIndicator" style="display: none;">
                                <span>typing</span>
                                <div class="typing-dots">
                                    <span></span>
                                    <span></span>
                                    <span></span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="chat-header-actions">
                        <button class="header-btn" id="voiceCallBtn" title="Voice Call">
                            <i class="fas fa-phone"></i>
                        </button>
                        <button class="header-btn" id="videoCallBtn" title="Video Call">
                            <i class="fas fa-video"></i>
                        </button>
                        <button class="header-btn" id="chatInfoBtn" title="Chat Info">
                            <i class="fas fa-info-circle"></i>
                        </button>
                    </div>
                </div>
                
                <div class="messages-container" id="messagesContainer">
                    <!-- Messages will be loaded here -->
                </div>
                
                <div class="input-area">
                    <div class="message-input-container">
                        <div class="input-actions">
                            <button class="input-action-btn" id="emojiBtn" title="Emoji">
                                <i class="far fa-smile"></i>
                            </button>
                            <button class="input-action-btn" id="attachmentBtn" title="Attachments">
                                <i class="fas fa-paperclip"></i>
                            </button>
                        </div>
                        
                        <div class="message-input-wrapper">
                            <textarea class="message-input" id="messageInput" placeholder="Type a message..." rows="1"></textarea>
                            <div class="emoji-picker-container" id="emojiPickerContainer"></div>
                        </div>
                        
                        <button class="send-btn" id="sendBtn" disabled>
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                    
                    <div class="attachments-menu" id="attachmentsMenu">
                        <div class="attachment-option" id="photoAttachmentBtn">
                            <div class="attachment-icon">
                                <i class="fas fa-camera"></i>
                            </div>
                            <div class="attachment-text">
                                <div class="attachment-title">Photo & Video</div>
                                <div class="attachment-desc">Share photos and videos</div>
                            </div>
                        </div>
                        <div class="attachment-option" id="documentAttachmentBtn">
                            <div class="attachment-icon">
                                <i class="fas fa-file"></i>
                            </div>
                            <div class="attachment-text">
                                <div class="attachment-title">Document</div>
                                <div class="attachment-desc">Share documents</div>
                            </div>
                        </div>
                        <div class="attachment-option" id="voiceAttachmentBtn">
                            <div class="attachment-icon">
                                <i class="fas fa-microphone"></i>
                            </div>
                            <div class="attachment-text">
                                <div class="attachment-title">Voice Message</div>
                                <div class="attachment-desc">Record and send voice</div>
                            </div>
                        </div>
                        <div class="attachment-option" id="locationAttachmentBtn">
                            <div class="attachment-icon">
                                <i class="fas fa-map-marker-alt"></i>
                            </div>
                            <div class="attachment-text">
                                <div class="attachment-title">Location</div>
                                <div class="attachment-desc">Share your location</div>
                            </div>
                        </div>
                        <div class="attachment-option" id="contactAttachmentBtn">
                            <div class="attachment-icon">
                                <i class="fas fa-user"></i>
                            </div>
                            <div class="attachment-text">
                                <div class="attachment-title">Contact</div>
                                <div class="attachment-desc">Share a contact</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Start New Chat Button (PERMANENT - FIXED ISSUE) -->
        <button class="start-chat-btn" id="permanentStartChatBtn" style="display: none;">
            <i class="fas fa-plus"></i>
        </button>
    </div>
    
    <!-- New Chat Modal -->
    <div class="new-chat-modal" id="newChatModal">
        <div class="new-chat-container">
            <div class="new-chat-header">
                <h3>New Chat</h3>
                <button class="new-chat-close" id="closeNewChatModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="new-chat-search">
                <input type="text" class="new-chat-search-input" id="contactSearchInput" placeholder="Search contacts...">
            </div>
            
            <div class="contacts-list" id="contactsList">
                <!-- Contacts will be loaded instantly from cache -->
            </div>
            
            <div class="no-contacts-found" id="noContactsFound" style="display: none; text-align: center; padding: 40px 20px; color: var(--text-secondary);">
                <i class="fas fa-users" style="font-size: 48px; margin-bottom: 15px; opacity: 0.5;"></i>
                <p>No contacts found</p>
                <p style="font-size: 14px; margin-top: 10px;">Try searching with a different name</p>
            </div>
        </div>
    </div>
    
    <!-- Notification -->
    <div class="notification" id="notification">
        <i class="fas fa-check-circle"></i>
        <span id="notificationText">Operation completed successfully</span>
    </div>
    
    <!-- Hidden file inputs -->
    <input type="file" id="photoUploadInput" accept="image/*,video/*" multiple style="display: none;">
    <input type="file" id="videoUploadInput" accept="video/*" style="display: none;">
    <input type="file" id="documentUploadInput" accept="*/*" style="display: none;">
    
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDHHyGgsSV18BcXrGgzi4C8frzDAE1C1zo",
            authDomain: "uniconnect-ee95c.firebaseapp.com",
            projectId: "uniconnect-ee95c",
            storageBucket: "uniconnect-ee95c.firebasestorage.app",
            messagingSenderId: "1003264444309",
            appId: "1:1003264444309:web:9f0307516e44d21e97d89c"
        };
        
        // Initialize Firebase
        try {
            if (!firebase.apps.length) {
                firebase.initializeApp(firebaseConfig);
            }
        } catch (error) {
            console.log('Firebase already initialized');
        }
        
        const db = firebase.firestore();
        const auth = firebase.auth();
        const storage = firebase.storage();
        
        // Global variables
        let currentUser = null;
        let currentChatId = null;
        let currentChatUser = null;
        let currentChatType = 'individual'; // 'individual' or 'group'
        let allChats = [];
        let filteredChats = [];
        let cachedContacts = [];
        let userContacts = [];
        let onlineUsers = [];
        let typingUsers = {};
        let messagesListener = null;
        let chatListener = null;
        let typingTimeout = null;
        let isOnline = navigator.onLine;
        let currentCategory = 'all';
        let messageMenu = null;
        let selectedMessageId = null;
        let wavesurfer = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingTime = 0;
        let recordingTimer = null;
        
        // OFFLINE SUPPORT
        let cachedChats = [];
        let pendingMessages = [];
        let isSyncing = false;
        let backgroundSyncInterval = null;
        let realTimeListener = null;
        
        // DOM Elements
        const sidebar = document.getElementById('sidebar');
        const chatArea = document.getElementById('chatArea');
        const chatActiveView = document.getElementById('chatActiveView');
        const noChatSelected = document.getElementById('noChatSelected');
        const newChatModal = document.getElementById('newChatModal');
        const notification = document.getElementById('notification');
        const offlineIndicator = document.getElementById('offlineIndicator');
        const permanentStartChatBtn = document.getElementById('permanentStartChatBtn');
        
        // ============================================
        // CORE FUNCTIONS - Optimized for instant loading
        // ============================================
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Load cached data immediately - NO AUTH DEPENDENCY
            instantLoadFromCache();
            
            // Setup event listeners
            setupEventListeners();
            setupMessageInput();
            setupEmojiPicker();
            setupResponsiveBehavior();
            
            // Initialize offline support
            setupOfflineSupport();
            
            // Show permanent start chat button
            if (permanentStartChatBtn) {
                permanentStartChatBtn.style.display = 'flex';
            }
            
            // Check auth state in background (non-blocking)
            setTimeout(() => {
                checkAuthState();
            }, 100);
        });
        
        // INSTANT LOAD FUNCTION - Shows cached data immediately without auth
        function instantLoadFromCache() {
            try {
                // Load cached user data WITHOUT waiting for Firebase auth
                const cachedUserData = localStorage.getItem('currentUser');
                if (cachedUserData) {
                    try {
                        const user = JSON.parse(cachedUserData);
                        if (user && user.uid) {
                            currentUser = user;
                            console.log('Using cached user data for offline rendering');
                        }
                    } catch (e) {
                        console.log('No valid cached user data');
                    }
                }
                
                // Load cached chats
                loadCachedChats();
                
                // Load cached contacts
                loadCachedContacts();
                
                // Update UI with cached data immediately
                if (cachedChats.length > 0) {
                    updateChatListWithCache();
                }
                
                // Show cached contacts in new chat modal if available
                if (cachedContacts.length > 0) {
                    populateContactsList(cachedContacts);
                }
                
                // Load pending messages
                loadPendingMessages();
                
                // Check if we have any offline data to display
                if (cachedChats.length === 0 && cachedContacts.length === 0) {
                    console.log('No cached data found for offline rendering');
                }
                
            } catch (error) {
                console.error('Error in instant load:', error);
            }
        }
        
        // Check auth state without blocking UI
        function checkAuthState() {
            auth.onAuthStateChanged(user => {
                if (user) {
                    // User is signed in
                    currentUser = {
                        uid: user.uid,
                        displayName: user.displayName,
                        photoURL: user.photoURL,
                        email: user.email
                    };
                    
                    // Update cached user data
                    localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    
                    console.log('User authenticated:', user.uid);
                    
                    // Update user online status
                    updateUserOnlineStatus(true);
                    
                    // Load fresh data if online
                    if (isOnline) {
                        loadUserData();
                        loadOnlineUsers();
                        loadChats();
                        loadContacts();
                    }
                    
                } else {
                    // User is not signed in but we might have cached data
                    console.log('No authenticated user, using cached data if available');
                    
                    // Don't redirect if we have cached data (offline mode)
                    const cachedUserData = localStorage.getItem('currentUser');
                    if (!cachedUserData && isOnline) {
                        // Only redirect if online and no cached data
                        console.log('No cached user data, redirecting to login');
                        window.location.href = 'index.html';
                    }
                }
            }, error => {
                console.error('Auth state change error:', error);
                // Don't redirect on auth errors - continue with cached data
            });
        }
        
        // Update user online status in Firestore
        async function updateUserOnlineStatus(isOnlineStatus) {
            if (!currentUser || !currentUser.uid) return;
            
            try {
                const userStatusRef = db.collection('users').doc(currentUser.uid);
                await userStatusRef.set({
                    isOnline: isOnlineStatus,
                    lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
            } catch (error) {
                console.error('Error updating online status:', error);
            }
        }
        
        // OFFLINE SUPPORT FUNCTIONS
        function setupOfflineSupport() {
            // Listen for online/offline events
            window.addEventListener('online', handleOnlineStatusChange);
            window.addEventListener('offline', handleOnlineStatusChange);
            
            // Initial check
            handleOnlineStatusChange();
            
            // Start background sync interval
            startBackgroundSync();
            
            // Update online status when page is about to close
            window.addEventListener('beforeunload', () => {
                if (currentUser && currentUser.uid) {
                    updateUserOnlineStatus(false);
                }
            });
        }
        
        function handleOnlineStatusChange() {
            const wasOnline = isOnline;
            isOnline = navigator.onLine;
            
            if (isOnline && !wasOnline) {
                // Just came online
                offlineIndicator.classList.remove('active');
                showNotification('You are back online. Syncing messages...', 'success');
                
                // Update online status
                if (currentUser && currentUser.uid) {
                    updateUserOnlineStatus(true);
                }
                
                // Process pending messages in background
                setTimeout(() => {
                    processPendingMessages();
                }, 2000);
                
                // Start real-time listener if user is authenticated
                if (currentUser && currentUser.uid) {
                    setupRealTimeListener();
                }
                
                // Load fresh data in background if authenticated
                if (currentUser && currentUser.uid) {
                    setTimeout(() => {
                        loadChats();
                        loadContacts();
                    }, 1000);
                }
                
            } else if (!isOnline && wasOnline) {
                // Just went offline
                offlineIndicator.classList.add('active');
                
                // Update online status
                if (currentUser && currentUser.uid) {
                    updateUserOnlineStatus(false);
                }
                
                // Stop real-time listener
                stopRealTimeListener();
                
                // Show cached data
                updateChatListWithCache();
            }
        }
        
        function loadCachedChats() {
            try {
                // Try to load from localStorage using currentUser ID or generic cache
                let cachedData = null;
                
                if (currentUser && currentUser.uid) {
                    cachedData = localStorage.getItem(`cachedChats_${currentUser.uid}`);
                }
                
                // Fallback to generic cache if user-specific not found
                if (!cachedData) {
                    cachedData = localStorage.getItem('cachedChats');
                }
                
                if (cachedData) {
                    cachedChats = JSON.parse(cachedData);
                    console.log(`Loaded ${cachedChats.length} cached chats`);
                    
                    // Update timestamp to ensure freshness
                    cachedChats.forEach(chat => {
                        if (chat.lastMessageTimestamp && typeof chat.lastMessageTimestamp === 'string') {
                            // Ensure timestamp is a Date object
                            chat.lastMessageTimestamp = new Date(chat.lastMessageTimestamp);
                        }
                    });
                    
                } else {
                    cachedChats = [];
                }
            } catch (error) {
                console.error('Error loading cached chats:', error);
                cachedChats = [];
            }
        }
        
        function saveChatToCache(chat) {
            try {
                // Save to both user-specific and generic cache for offline access
                const cacheKey = currentUser && currentUser.uid ? 
                    `cachedChats_${currentUser.uid}` : 'cachedChats';
                
                // Check if chat already exists in cache
                const existingIndex = cachedChats.findIndex(c => 
                    c.chatId === chat.chatId
                );
                
                if (existingIndex !== -1) {
                    // Update existing cache entry
                    cachedChats[existingIndex] = chat;
                } else {
                    // Add to cache
                    cachedChats.unshift(chat);
                }
                
                // Keep only last 100 chats in cache
                if (cachedChats.length > 100) {
                    cachedChats = cachedChats.slice(0, 100);
                }
                
                // Save to localStorage
                localStorage.setItem(cacheKey, JSON.stringify(cachedChats));
                
                // Also save to generic cache for offline access
                if (currentUser && currentUser.uid) {
                    localStorage.setItem('cachedChats', JSON.stringify(cachedChats));
                }
                
                // Update UI with cached chat if offline
                if (!isOnline) {
                    updateChatListWithCache();
                }
                
            } catch (error) {
                console.error('Error saving chat to cache:', error);
            }
        }
        
        function loadCachedContacts() {
            try {
                // Try to load from localStorage using currentUser ID or generic cache
                let cachedData = null;
                
                if (currentUser && currentUser.uid) {
                    cachedData = localStorage.getItem(`cachedContacts_${currentUser.uid}`);
                }
                
                // Fallback to generic cache if user-specific not found
                if (!cachedData) {
                    cachedData = localStorage.getItem('cachedContacts');
                }
                
                if (cachedData) {
                    cachedContacts = JSON.parse(cachedData);
                    console.log(`Loaded ${cachedContacts.length} cached contacts`);
                } else {
                    cachedContacts = [];
                }
            } catch (error) {
                console.error('Error loading cached contacts:', error);
                cachedContacts = [];
            }
        }
        
        function saveContactsToCache(contacts) {
            try {
                // Save to both user-specific and generic cache
                const cacheKey = currentUser && currentUser.uid ? 
                    `cachedContacts_${currentUser.uid}` : 'cachedContacts';
                
                cachedContacts = contacts;
                localStorage.setItem(cacheKey, JSON.stringify(cachedContacts));
                
                // Also save to generic cache for offline access
                if (currentUser && currentUser.uid) {
                    localStorage.setItem('cachedContacts', JSON.stringify(cachedContacts));
                }
                
            } catch (error) {
                console.error('Error saving contacts to cache:', error);
            }
        }
        
        function updateChatListWithCache() {
            const recentChatsList = document.getElementById('recentChatsList');
            const searchResultsList = document.getElementById('searchResultsList');
            const searchResultsTitle = document.getElementById('searchResultsTitle');
            const clearAllBtn = document.getElementById('clearAllBtn');
            
            if (!recentChatsList) return;
            
            // Clear current list
            recentChatsList.innerHTML = '';
            
            // Combine cached chats with online chats
            const allCombinedChats = [...allChats, ...cachedChats];
            
            // Remove duplicates - prefer cached version for offline freshness
            const uniqueChats = [];
            const seenIds = new Set();
            
            allCombinedChats.forEach(chat => {
                if (!seenIds.has(chat.chatId)) {
                    seenIds.add(chat.chatId);
                    uniqueChats.push(chat);
                }
            });
            
            // Filter chats based on current category
            filteredChats = filterChatsByCategory(uniqueChats);
            
            // Sort by last message timestamp (newest first)
            filteredChats.sort((a, b) => {
                const timeA = a.lastMessageTimestamp ? new Date(a.lastMessageTimestamp) : new Date(0);
                const timeB = b.lastMessageTimestamp ? new Date(b.lastMessageTimestamp) : new Date(0);
                return timeB - timeA;
            });
            
            // Add chat items
            filteredChats.forEach(chat => {
                const chatItem = createChatItem(chat);
                recentChatsList.appendChild(chatItem);
            });
            
            // Show empty state if no chats
            if (filteredChats.length === 0) {
                showEmptyChatState(recentChatsList);
            }
            
            // Show/hide clear all button
            if (clearAllBtn) {
                clearAllBtn.style.display = filteredChats.length > 0 ? 'block' : 'none';
            }
            
            // Hide search results if showing
            if (searchResultsList) searchResultsList.style.display = 'none';
            if (searchResultsTitle) searchResultsTitle.style.display = 'none';
            
            // Show cache info if offline and have cached chats
            if (!isOnline && cachedChats.length > 0) {
                showCacheInfo(recentChatsList);
            }
        }
        
        function filterChatsByCategory(chats) {
            let filteredChats = [];
            const userId = currentUser ? currentUser.uid : null;
            
            switch(currentCategory) {
                case 'all':
                    filteredChats = chats.filter(chat => !chat.isArchived);
                    break;
                    
                case 'unread':
                    filteredChats = chats.filter(chat => 
                        !chat.isArchived && 
                        chat.unreadCount > 0 &&
                        (!chat.lastMessageSender || chat.lastMessageSender !== userId)
                    );
                    break;
                    
                case 'sent':
                    filteredChats = chats.filter(chat => 
                        !chat.isArchived && 
                        chat.lastMessageSender === userId
                    );
                    break;
                    
                case 'received':
                    filteredChats = chats.filter(chat => 
                        !chat.isArchived && 
                        chat.lastMessageSender && 
                        chat.lastMessageSender !== userId
                    );
                    break;
                    
                case 'groups':
                    filteredChats = chats.filter(chat => 
                        !chat.isArchived && 
                        chat.type === 'group'
                    );
                    break;
                    
                case 'archived':
                    filteredChats = chats.filter(chat => chat.isArchived);
                    break;
            }
            
            return filteredChats;
        }
        
        function createChatItem(chat) {
            const timeAgo = getTimeAgo(chat.lastMessageTimestamp);
            const isUnread = chat.unreadCount > 0;
            const isSentByMe = chat.lastMessageSender === (currentUser ? currentUser.uid : null);
            const isCached = chat.isCached || chat.isPending;
            const isGroup = chat.type === 'group';
            
            const chatItem = document.createElement('div');
            chatItem.className = 'chat-item';
            if (isUnread) chatItem.classList.add('unread');
            if (chat.chatId === currentChatId) chatItem.classList.add('active');
            if (isCached) chatItem.classList.add('cached');
            
            chatItem.dataset.chatId = chat.chatId;
            chatItem.dataset.chatType = chat.type;
            chatItem.dataset.userId = chat.userId || '';
            chatItem.dataset.groupId = chat.groupId || '';
            
            // Add enter animation
            chatItem.classList.add('chat-item-enter');
            setTimeout(() => {
                chatItem.classList.add('chat-item-enter-active');
            }, 10);
            
            let avatarContent = '';
            let chatName = '';
            let chatStatus = '';
            
            if (isGroup) {
                avatarContent = `<i class="fas fa-users"></i>`;
                chatName = chat.groupName || 'Group Chat';
                chatStatus = `${chat.memberCount || 0} members`;
            } else {
                const otherUser = chat.otherUser || {};
                const initials = otherUser.name ? 
                    otherUser.name.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2) : 
                    'U';
                
                if (otherUser.photoURL) {
                    avatarContent = `style="background-image: url('${otherUser.photoURL}')"`;
                } else {
                    avatarContent = `<span>${initials}</span>`;
                }
                
                chatName = otherUser.name || 'User';
                chatStatus = otherUser.status || 'Online';
            }
            
            const lastMessagePreview = getLastMessagePreview(chat.lastMessage, isSentByMe);
            
            chatItem.innerHTML = `
                <div class="chat-avatar" ${avatarContent}>
                    ${isGroup ? '<i class="fas fa-users"></i>' : ''}
                    ${!isGroup && onlineUsers.includes(chat.userId) ? '<div class="online-status"></div>' : ''}
                    ${!isGroup && !onlineUsers.includes(chat.userId) ? '<div class="offline-status"></div>' : ''}
                    ${isCached ? '<div class="pending-indicator" title="Pending"><i class="fas fa-clock"></i></div>' : ''}
                </div>
                <div class="chat-info">
                    <div class="chat-header">
                        <div class="chat-name">${chatName}</div>
                        <div class="chat-time">${timeAgo}</div>
                    </div>
                    <div class="chat-preview">
                        ${isSentByMe ? '<span class="message-status"><i class="fas fa-check"></i></span>' : ''}
                        <div class="chat-message">${lastMessagePreview}</div>
                        ${isUnread ? `<div class="unread-badge">${chat.unreadCount}</div>` : ''}
                    </div>
                </div>
            `;
            
            // Add event listener
            chatItem.addEventListener('click', () => {
                openChat(chat);
            });
            
            return chatItem;
        }
        
        function getLastMessagePreview(message, isSentByMe) {
            if (!message) return 'No messages yet';
            
            let prefix = isSentByMe ? 'You: ' : '';
            
            if (message.type === 'text') {
                return prefix + (message.text || '').substring(0, 50) + ((message.text || '').length > 50 ? '...' : '');
            } else if (message.type === 'image') {
                return prefix + ' Photo';
            } else if (message.type === 'video') {
                return prefix + ' Video';
            } else if (message.type === 'voice') {
                return prefix + ' Voice message';
            } else if (message.type === 'file') {
                return prefix + ' File';
            } else if (message.type === 'location') {
                return prefix + ' Location';
            }
            
            return prefix + 'Message';
        }
        
        function showEmptyChatState(container) {
            let emptyMessage = '';
            switch(currentCategory) {
                case 'all':
                    emptyMessage = 'No conversations yet';
                    break;
                case 'unread':
                    emptyMessage = 'No unread messages';
                    break;
                case 'sent':
                    emptyMessage = 'No sent messages';
                    break;
                case 'received':
                    emptyMessage = 'No received messages';
                    break;
                case 'groups':
                    emptyMessage = 'No group chats';
                    break;
                case 'archived':
                    emptyMessage = 'No archived chats';
                    break;
            }
            
            container.innerHTML = `
                <div style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
                    <i class="fas fa-comments" style="font-size: 48px; margin-bottom: 15px; opacity: 0.5;"></i>
                    <p>${emptyMessage}</p>
                    ${currentCategory === 'all' ? '<button class="start-chat-btn" id="startChatFromEmpty" style="position: relative; margin-top: 20px; width: 50px; height: 50px; font-size: 20px;"><i class="fas fa-plus"></i></button>' : ''}
                </div>
            `;
            
            const startChatBtn = document.getElementById('startChatFromEmpty');
            if (startChatBtn) {
                startChatBtn.addEventListener('click', () => {
                    openNewChatModal();
                });
            }
        }
        
        function showCacheInfo(container) {
            const cacheInfo = document.createElement('div');
            cacheInfo.className = 'offline-cache-info';
            cacheInfo.innerHTML = `<i class="fas fa-database"></i> Showing ${cachedChats.length} cached conversations`;
            container.insertBefore(cacheInfo, container.firstChild);
        }
        
        function loadPendingMessages() {
            try {
                let pendingData = null;
                
                if (currentUser && currentUser.uid) {
                    pendingData = localStorage.getItem(`pendingMessages_${currentUser.uid}`);
                }
                
                // Fallback to generic cache
                if (!pendingData) {
                    pendingData = localStorage.getItem('pendingMessages');
                }
                
                if (pendingData) {
                    pendingMessages = JSON.parse(pendingData);
                    console.log(`Loaded ${pendingMessages.length} pending messages`);
                } else {
                    pendingMessages = [];
                }
            } catch (error) {
                console.error('Error loading pending messages:', error);
                pendingMessages = [];
            }
        }
        
        function savePendingMessage(message) {
            try {
                // Save to both user-specific and generic cache
                const cacheKey = currentUser && currentUser.uid ? 
                    `pendingMessages_${currentUser.uid}` : 'pendingMessages';
                
                // Generate a temporary ID for offline message
                const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                message.tempId = tempId;
                message.isPending = true;
                message.timestamp = new Date().toISOString();
                
                // Add to pending messages
                pendingMessages.push(message);
                
                // Save to localStorage
                localStorage.setItem(cacheKey, JSON.stringify(pendingMessages));
                
                // Also save to generic cache
                if (currentUser && currentUser.uid) {
                    localStorage.setItem('pendingMessages', JSON.stringify(pendingMessages));
                }
                
                console.log(`Saved pending message with tempId: ${tempId}`);
                
                return tempId;
            } catch (error) {
                console.error('Error saving pending message:', error);
                return null;
            }
        }
        
        function removePendingMessage(tempId) {
            try {
                pendingMessages = pendingMessages.filter(msg => msg.tempId !== tempId);
                
                const cacheKey = currentUser && currentUser.uid ? 
                    `pendingMessages_${currentUser.uid}` : 'pendingMessages';
                
                localStorage.setItem(cacheKey, JSON.stringify(pendingMessages));
                
                // Also update generic cache
                if (currentUser && currentUser.uid) {
                    localStorage.setItem('pendingMessages', JSON.stringify(pendingMessages));
                }
            } catch (error) {
                console.error('Error removing pending message:', error);
            }
        }
        
        async function processPendingMessages() {
            if (isSyncing || pendingMessages.length === 0 || !isOnline || !currentUser) return;
            
            isSyncing = true;
            
            // Process each pending message
            for (let i = 0; i < pendingMessages.length; i++) {
                const pendingMessage = pendingMessages[i];
                
                try {
                    // Upload media files if needed
                    let mediaUrl = pendingMessage.content;
                    let thumbnailUrl = pendingMessage.thumbnail;
                    
                    if (pendingMessage.type === 'image' || pendingMessage.type === 'video' || pendingMessage.type === 'file') {
                        if (pendingMessage.content && pendingMessage.content.startsWith('data:')) {
                            const response = await fetch(pendingMessage.content);
                            const blob = await response.blob();
                            const fileType = pendingMessage.type === 'image' ? 'jpg' : pendingMessage.type === 'video' ? 'mp4' : 'bin';
                            const file = new File([blob], `message_${Date.now()}.${fileType}`, {
                                type: blob.type
                            });
                            
                            mediaUrl = await uploadToFirebaseStorage(file, 'messages');
                            
                            // If video, upload thumbnail if exists
                            if (pendingMessage.type === 'video' && pendingMessage.thumbnail) {
                                const thumbResponse = await fetch(pendingMessage.thumbnail);
                                const thumbBlob = await thumbResponse.blob();
                                const thumbFile = new File([thumbBlob], `thumb_${Date.now()}.jpg`, {
                                    type: 'image/jpeg'
                                });
                                
                                thumbnailUrl = await uploadToFirebaseStorage(thumbFile, 'thumbnails');
                            }
                        }
                    } else if (pendingMessage.type === 'voice') {
                        if (pendingMessage.content && pendingMessage.content.startsWith('data:')) {
                            const response = await fetch(pendingMessage.content);
                            const blob = await response.blob();
                            const file = new File([blob], `voice_${Date.now()}.wav`, {
                                type: 'audio/wav'
                            });
                            
                            mediaUrl = await uploadToFirebaseStorage(file, 'voice_messages');
                        }
                    }
                    
                    // Prepare message data for Firestore
                    const messageData = {
                        ...pendingMessage,
                        content: mediaUrl,
                        thumbnail: thumbnailUrl,
                        senderId: currentUser.uid,
                        senderName: currentUser.displayName || 'User',
                        senderPhoto: currentUser.photoURL || '',
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        readBy: [currentUser.uid],
                        reactions: {},
                        isEdited: false,
                        isDeleted: false
                    };
                    
                    // Remove temporary fields
                    delete messageData.tempId;
                    delete messageData.isPending;
                    
                    // Save to Firestore
                    await db.collection('messages').add(messageData);
                    
                    // Update chat document
                    await updateChatDocument(pendingMessage.chatId, {
                        lastMessage: messageData,
                        lastMessageTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        lastMessageSender: currentUser.uid,
                        unreadCount: firebase.firestore.FieldValue.increment(1)
                    });
                    
                    // Remove from pending messages
                    removePendingMessage(pendingMessage.tempId);
                    
                } catch (error) {
                    console.error(`Error uploading pending message ${pendingMessage.tempId}:`, error);
                }
            }
            
            isSyncing = false;
            
            // Reload chats in background
            setTimeout(() => {
                loadChats();
            }, 1000);
        }
        
        function startBackgroundSync() {
            if (backgroundSyncInterval) {
                clearInterval(backgroundSyncInterval);
            }
            
            // Sync every 30 seconds when online
            backgroundSyncInterval = setInterval(() => {
                if (isOnline && currentUser) {
                    syncOfflineData();
                }
            }, 30000);
        }
        
        function setupRealTimeListener() {
            if (!isOnline || !currentUser || !currentUser.uid) return;
            
            // Stop any existing listener
            stopRealTimeListener();
            
            try {
                // Listen for new messages
                realTimeListener = db.collection('messages')
                    .where('participants', 'array-contains', currentUser.uid)
                    .orderBy('timestamp', 'desc')
                    .limit(50)
                    .onSnapshot(snapshot => {
                        const changes = snapshot.docChanges();
                        
                        changes.forEach(change => {
                            if (change.type === 'added' || change.type === 'modified') {
                                const messageData = change.doc.data();
                                const message = {
                                    id: change.doc.id,
                                    ...messageData,
                                    timestamp: messageData.timestamp ? messageData.timestamp.toDate() : new Date()
                                };
                                
                                // Update chat list if this is a new message
                                if (change.type === 'added' && message.senderId !== currentUser.uid) {
                                    updateChatFromMessage(message);
                                }
                                
                                // If this message is in the current chat, add it
                                if (currentChatId && message.chatId === currentChatId) {
                                    addMessageToUI(message);
                                }
                            }
                        });
                    }, error => {
                        console.error('Real-time listener error:', error);
                    });
                    
            } catch (error) {
                console.error('Error setting up real-time listener:', error);
            }
        }
        
        function stopRealTimeListener() {
            if (realTimeListener) {
                realTimeListener();
                realTimeListener = null;
            }
        }
        
        async function syncOfflineData() {
            if (!isOnline || !currentUser) return;
            
            // Sync read receipts
            await syncReadReceipts();
            
            // Sync typing status
            await syncTypingStatus();
            
            // Sync message reactions
            await syncMessageReactions();
        }
        
        async function syncReadReceipts() {
            // Implementation for syncing read receipts
            // This would mark messages as read when coming online
        }
        
        async function syncTypingStatus() {
            // Implementation for syncing typing status
        }
        
        async function syncMessageReactions() {
            // Implementation for syncing message reactions
        }
        
        // ============================================
        // CHAT MANAGEMENT FUNCTIONS
        // ============================================
        
        async function loadChats() {
            try {
                if (!currentUser || !currentUser.uid || !isOnline) {
                    // Use cached data when offline or no user
                    updateChatListWithCache();
                    return;
                }
                
                // Load chats from Firestore
                const chatsSnapshot = await db.collection('chats')
                    .where('participants', 'array-contains', currentUser.uid)
                    .orderBy('lastMessageTimestamp', 'desc')
                    .limit(50)
                    .get();
                
                // Process chats
                allChats = [];
                
                chatsSnapshot.forEach(doc => {
                    const chatData = doc.data();
                    const chat = {
                        chatId: doc.id,
                        ...chatData,
                        lastMessageTimestamp: chatData.lastMessageTimestamp ? chatData.lastMessageTimestamp.toDate() : new Date()
                    };
                    
                    // Determine chat type and extract other user info for individual chats
                    if (chatData.type === 'individual') {
                        const otherParticipant = chatData.participants.find(p => p !== currentUser.uid);
                        chat.userId = otherParticipant;
                        
                        // Try to get user info from chat data or fetch it
                        if (chatData.participantInfo && chatData.participantInfo[otherParticipant]) {
                            chat.otherUser = chatData.participantInfo[otherParticipant];
                        } else {
                            // We'll load this separately
                            chat.otherUser = { uid: otherParticipant };
                        }
                    }
                    
                    allChats.push(chat);
                    
                    // Cache the chat
                    saveChatToCache(chat);
                });
                
                console.log(`Loaded ${allChats.length} chats from Firestore`);
                
                // Update the chat list
                updateChatListWithCache();
                
                // Load user info for individual chats
                await loadUserInfoForChats();
                
            } catch (error) {
                console.error('Error loading chats:', error);
                
                // Fallback to cache on error
                updateChatListWithCache();
            }
        }
        
        async function loadUserInfoForChats() {
            if (!currentUser || !currentUser.uid || !isOnline) return;
            
            const userIds = new Set();
            
            // Collect all unique user IDs from individual chats
            allChats.forEach(chat => {
                if (chat.type === 'individual' && chat.userId && chat.userId !== currentUser.uid) {
                    userIds.add(chat.userId);
                }
            });
            
            // Load user info in batches
            const userIdArray = Array.from(userIds);
            for (let i = 0; i < userIdArray.length; i += 10) {
                const batch = userIdArray.slice(i, i + 10);
                await Promise.all(batch.map(async userId => {
                    try {
                        const userDoc = await db.collection('users').doc(userId).get();
                        if (userDoc.exists) {
                            const userData = userDoc.data();
                            
                            // Update chat with user info
                            const chatIndex = allChats.findIndex(chat => chat.userId === userId);
                            if (chatIndex !== -1) {
                                allChats[chatIndex].otherUser = {
                                    uid: userId,
                                    name: userData.displayName,
                                    photoURL: userData.photoURL,
                                    status: userData.status || 'Hey there! I am using MoodChat'
                                };
                                
                                // Update cache
                                saveChatToCache(allChats[chatIndex]);
                            }
                        }
                    } catch (error) {
                        console.error(`Error loading user info for ${userId}:`, error);
                    }
                }));
            }
            
            // Update UI
            updateChatListWithCache();
        }
        
        async function loadContacts() {
            try {
                if (!currentUser || !currentUser.uid || !isOnline) {
                    // Use cached contacts when offline
                    populateContactsList(cachedContacts);
                    return;
                }
                
                // Load contacts from Firestore
                const contactsSnapshot = await db.collection('users')
                    .where('uid', '!=', currentUser.uid)
                    .limit(100)
                    .get();
                
                userContacts = [];
                contactsSnapshot.forEach(doc => {
                    const userData = doc.data();
                    userContacts.push({
                        uid: userData.uid,
                        name: userData.displayName,
                        photoURL: userData.photoURL,
                        status: userData.status || 'Hey there! I am using MoodChat',
                        email: userData.email,
                        isOnline: userData.isOnline || false,
                        lastSeen: userData.lastSeen ? userData.lastSeen.toDate() : null
                    });
                });
                
                console.log(`Loaded ${userContacts.length} contacts from Firestore`);
                
                // Save to cache
                saveContactsToCache(userContacts);
                
                // Populate contacts list
                populateContactsList(userContacts);
                
            } catch (error) {
                console.error('Error loading contacts:', error);
                
                // Fallback to cached contacts
                populateContactsList(cachedContacts);
            }
        }
        
        function populateContactsList(contacts) {
            const contactsList = document.getElementById('contactsList');
            const noContactsFound = document.getElementById('noContactsFound');
            
            if (!contactsList) return;
            
            contactsList.innerHTML = '';
            
            if (contacts.length === 0) {
                if (noContactsFound) noContactsFound.style.display = 'block';
                return;
            }
            
            if (noContactsFound) noContactsFound.style.display = 'none';
            
            // Sort contacts alphabetically
            contacts.sort((a, b) => {
                const nameA = a.name || '';
                const nameB = b.name || '';
                return nameA.localeCompare(nameB);
            });
            
            // Add contact items
            contacts.forEach(contact => {
                const contactItem = createContactItem(contact);
                contactsList.appendChild(contactItem);
            });
        }
        
        function createContactItem(contact) {
            const initials = contact.name ? 
                contact.name.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2) : 
                'U';
            
            const contactItem = document.createElement('div');
            contactItem.className = 'contact-item';
            contactItem.dataset.userId = contact.uid;
            
            // Determine status text
            let statusText = 'Offline';
            if (contact.isOnline) {
                statusText = 'Online';
            } else if (contact.lastSeen) {
                const lastSeenDate = new Date(contact.lastSeen);
                const now = new Date();
                const diffHours = Math.floor((now - lastSeenDate) / (1000 * 60 * 60));
                
                if (diffHours < 1) {
                    statusText = 'Last seen recently';
                } else if (diffHours < 24) {
                    statusText = `Last seen ${diffHours}h ago`;
                } else {
                    statusText = `Last seen ${Math.floor(diffHours / 24)}d ago`;
                }
            }
            
            contactItem.innerHTML = `
                <div class="contact-avatar" ${contact.photoURL ? `style="background-image: url('${contact.photoURL}')"` : ''}>
                    ${contact.photoURL ? '' : `<span>${initials}</span>`}
                    ${contact.isOnline ? '<div class="online-status"></div>' : ''}
                </div>
                <div class="contact-info">
                    <div class="contact-name">${contact.name || 'User'}</div>
                    <div class="contact-status ${contact.isOnline ? 'online' : ''}">
                        ${statusText}
                    </div>
                </div>
            `;
            
            // Add event listener
            contactItem.addEventListener('click', () => {
                startChatWithUser(contact);
            });
            
            return contactItem;
        }
        
        async function startChatWithUser(user) {
            try {
                // Close new chat modal
                if (newChatModal) newChatModal.classList.remove('active');
                
                // Check if chat already exists
                let existingChat = null;
                for (const chat of allChats) {
                    if (chat.type === 'individual' && chat.userId === user.uid) {
                        existingChat = chat;
                        break;
                    }
                }
                
                if (existingChat) {
                    // Open existing chat
                    openChat(existingChat);
                } else {
                    // Create new chat
                    const chatId = [currentUser.uid, user.uid].sort().join('_');
                    
                    const chatData = {
                        type: 'individual',
                        participants: [currentUser.uid, user.uid],
                        participantInfo: {
                            [currentUser.uid]: {
                                uid: currentUser.uid,
                                name: currentUser.displayName,
                                photoURL: currentUser.photoURL
                            },
                            [user.uid]: {
                                uid: user.uid,
                                name: user.name,
                                photoURL: user.photoURL
                            }
                        },
                        lastMessage: null,
                        lastMessageTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        lastMessageSender: null,
                        unreadCount: 0,
                        isArchived: false,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    
                    // Save to Firestore if online and authenticated
                    if (isOnline && currentUser && currentUser.uid) {
                        await db.collection('chats').doc(chatId).set(chatData);
                    }
                    
                    // Create chat object for UI
                    const newChat = {
                        chatId: chatId,
                        ...chatData,
                        otherUser: user,
                        userId: user.uid
                    };
                    
                    // Add to chats list
                    allChats.unshift(newChat);
                    
                    // Cache the chat
                    saveChatToCache(newChat);
                    
                    // Update UI
                    updateChatListWithCache();
                    
                    // Open the new chat
                    openChat(newChat);
                    
                    showNotification(`Started chat with ${user.name}`, 'success');
                }
                
            } catch (error) {
                console.error('Error starting chat:', error);
                showNotification('Failed to start chat', 'error');
            }
        }
        
        function openChat(chat) {
            // Update current chat info
            currentChatId = chat.chatId;
            currentChatType = chat.type;
            
            if (chat.type === 'individual') {
                currentChatUser = chat.otherUser;
                
                // Update chat header
                document.getElementById('chatUserName').textContent = currentChatUser.name || 'User';
                
                // Update status (FIXED: Show real status, not fake typing)
                if (currentChatUser.isOnline) {
                    document.getElementById('chatUserStatus').textContent = 'Online';
                    document.getElementById('chatUserStatus').style.color = 'var(--success-color)';
                } else {
                    document.getElementById('chatUserStatus').textContent = 'Offline';
                    document.getElementById('chatUserStatus').style.color = 'var(--text-secondary)';
                }
                
                // Hide typing indicator initially
                const typingIndicator = document.getElementById('typingIndicator');
                if (typingIndicator) {
                    typingIndicator.style.display = 'none';
                }
                
                // Update avatar
                const chatUserAvatar = document.getElementById('chatUserAvatar');
                const initials = currentChatUser.name ? 
                    currentChatUser.name.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2) : 
                    'U';
                
                if (currentChatUser.photoURL) {
                    chatUserAvatar.style.backgroundImage = `url('${currentChatUser.photoURL}')`;
                    chatUserAvatar.innerHTML = '';
                } else {
                    chatUserAvatar.style.backgroundImage = '';
                    chatUserAvatar.innerHTML = `<span>${initials}</span>`;
                }
                
                // Show chat user info in header actions
                document.getElementById('voiceCallBtn').style.display = 'flex';
                document.getElementById('videoCallBtn').style.display = 'flex';
                
            } else {
                // Group chat
                currentChatUser = {
                    name: chat.groupName,
                    photoURL: chat.groupPhoto
                };
                
                // Update chat header
                document.getElementById('chatUserName').textContent = chat.groupName || 'Group';
                document.getElementById('chatUserStatus').textContent = `${chat.memberCount || 0} members`;
                
                // Update avatar
                const chatUserAvatar = document.getElementById('chatUserAvatar');
                chatUserAvatar.style.backgroundImage = chat.groupPhoto ? `url('${chat.groupPhoto}')` : '';
                chatUserAvatar.innerHTML = chat.groupPhoto ? '' : '<i class="fas fa-users"></i>';
                
                // Hide call buttons for groups
                document.getElementById('voiceCallBtn').style.display = 'none';
                document.getElementById('videoCallBtn').style.display = 'none';
            }
            
            // Update UI
            noChatSelected.style.display = 'none';
            chatActiveView.style.display = 'flex';
            
            // Update chat list active state
            document.querySelectorAll('.chat-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.chatId === currentChatId) {
                    item.classList.add('active');
                }
            });
            
            // Load messages
            loadMessages();
            
            // Mark chat as read
            markChatAsRead(chat.chatId);
            
            // Setup typing listener
            setupTypingListener();
            
            // Setup message listener
            setupMessageListener();
            
            // On mobile, switch to chat view
            if (window.innerWidth <= 768) {
                sidebar.classList.remove('active');
                chatArea.classList.add('active');
            }
        }
        
        async function loadMessages() {
            if (!currentChatId) return;
            
            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.innerHTML = '';
            
            try {
                // Load cached messages first for instant display
                loadCachedMessagesForChat(currentChatId);
                
                if (isOnline && currentUser && currentUser.uid) {
                    // Load from Firestore
                    const messagesSnapshot = await db.collection('messages')
                        .where('chatId', '==', currentChatId)
                        .orderBy('timestamp', 'asc')
                        .limit(100)
                        .get();
                    
                    // Clear and reload with fresh data
                    messagesContainer.innerHTML = '';
                    
                    messagesSnapshot.forEach(doc => {
                        const messageData = doc.data();
                        const message = {
                            id: doc.id,
                            ...messageData,
                            timestamp: messageData.timestamp ? messageData.timestamp.toDate() : new Date()
                        };
                        addMessageToUI(message);
                    });
                    
                    // Scroll to bottom
                    setTimeout(() => {
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    }, 100);
                }
                
            } catch (error) {
                console.error('Error loading messages:', error);
            }
        }
        
        function loadCachedMessagesForChat(chatId) {
            const messagesContainer = document.getElementById('messagesContainer');
            
            // Try to load cached messages for this specific chat
            try {
                const cachedMessagesKey = `cachedMessages_${chatId}`;
                const cachedMessagesData = localStorage.getItem(cachedMessagesKey);
                
                if (cachedMessagesData) {
                    const cachedMessages = JSON.parse(cachedMessagesData);
                    
                    // Clear container
                    messagesContainer.innerHTML = '';
                    
                    // Add cached messages
                    cachedMessages.forEach(message => {
                        addMessageToUI(message);
                    });
                    
                    // Scroll to bottom
                    setTimeout(() => {
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    }, 100);
                    
                    return;
                }
            } catch (error) {
                console.error('Error loading cached messages:', error);
            }
            
            // Fallback to generic loading state
            messagesContainer.innerHTML = `
                <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                    <div class="spinner"></div>
                    <p style="margin-top: 10px;">Loading messages...</p>
                </div>
            `;
        }
        
        function addMessageToUI(message) {
            const messagesContainer = document.getElementById('messagesContainer');
            if (!messagesContainer) return;
            
            // Remove loading state if present
            if (messagesContainer.innerHTML.includes('Loading messages')) {
                messagesContainer.innerHTML = '';
            }
            
            // Check if message already exists
            const existingMessage = document.querySelector(`[data-message-id="${message.id}"]`);
            if (existingMessage) return;
            
            const messageRow = document.createElement('div');
            messageRow.className = `message-row ${message.senderId === currentUser.uid ? 'sent' : 'received'}`;
            messageRow.dataset.messageId = message.id || message.tempId;
            
            // Add enter animation
            messageRow.classList.add('message-enter');
            setTimeout(() => {
                messageRow.classList.add('message-enter-active');
            }, 10);
            
            const messageBubble = document.createElement('div');
            messageBubble.className = 'message-bubble';
            
            // Add message content based on type
            let messageContent = '';
            let messageTime = getMessageTime(message.timestamp);
            let statusIcon = '';
            
            if (message.senderId === currentUser.uid) {
                if (message.isPending) {
                    statusIcon = '<i class="fas fa-clock message-status-icon"></i>';
                } else if (message.readBy && message.readBy.length > 1) {
                    statusIcon = '<i class="fas fa-check-double message-status-icon"></i>';
                } else {
                    statusIcon = '<i class="fas fa-check message-status-icon"></i>';
                }
            }
            
            switch (message.type) {
                case 'text':
                    messageContent = `
                        <div class="message-text">${formatMessageText(message.text || '')}</div>
                    `;
                    break;
                    
                case 'image':
                    messageContent = `
                        <img src="${message.content || ''}" alt="Image" class="message-image" onclick="viewImage('${message.content}')">
                        ${message.caption ? `<div class="message-text" style="margin-top: 8px;">${message.caption}</div>` : ''}
                    `;
                    break;
                    
                case 'video':
                    messageContent = `
                        <video class="message-video" controls onclick="this.paused ? this.play() : this.pause()">
                            <source src="${message.content || ''}" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        ${message.caption ? `<div class="message-text" style="margin-top: 8px;">${message.caption}</div>` : ''}
                    `;
                    break;
                    
                case 'voice':
                    messageContent = `
                        <div class="voice-message">
                            <button class="voice-play-btn" onclick="playVoiceMessage('${message.content}')">
                                <i class="fas fa-play"></i>
                            </button>
                            <div class="voice-waveform" id="waveform-${message.id || message.tempId}"></div>
                            <div class="voice-duration">${message.duration || 0}s</div>
                        </div>
                    `;
                    break;
                    
                case 'file':
                    messageContent = `
                        <a href="${message.content || '#'}" class="message-file" download="${message.fileName || 'file'}">
                            <div class="file-icon">
                                <i class="fas fa-file"></i>
                            </div>
                            <div class="file-info">
                                <div class="file-name">${message.fileName || 'File'}</div>
                                <div class="file-size">${formatFileSize(message.fileSize || 0)}</div>
                            </div>
                            <i class="fas fa-download"></i>
                        </a>
                    `;
                    break;
                    
                case 'location':
                    messageContent = `
                        <div class="message-text">
                            <i class="fas fa-map-marker-alt"></i> Location shared
                        </div>
                        <div style="margin-top: 8px;">
                            <a href="https://maps.google.com/?q=${message.latitude},${message.longitude}" target="_blank" style="color: inherit; text-decoration: none;">
                                <div style="background: #f0f0f0; padding: 10px; border-radius: 8px;">
                                    <div style="font-weight: 500;">${message.locationName || 'Location'}</div>
                                    <div style="font-size: 12px; color: #666;">${message.address || ''}</div>
                                </div>
                            </a>
                        </div>
                    `;
                    break;
                    
                default:
                    messageContent = `<div class="message-text">${message.text || 'Unsupported message type'}</div>`;
            }
            
            messageBubble.innerHTML = `
                ${messageContent}
                <div class="message-info">
                    <div class="message-time">${messageTime}</div>
                    ${statusIcon}
                </div>
                ${message.reactions && Object.keys(message.reactions).length > 0 ? createReactionsHTML(message.reactions) : ''}
            `;
            
            // Add context menu for messages
            messageBubble.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showMessageMenu(e, message);
            });
            
            // Add click for reactions
            messageBubble.addEventListener('click', (e) => {
                if (e.target.classList.contains('reaction')) {
                    addReactionToMessage(message.id || message.tempId, e.target.dataset.emoji);
                }
            });
            
            messageRow.appendChild(messageBubble);
            messagesContainer.appendChild(messageRow);
            
            // Scroll to bottom if this is a new message
            if (message.senderId === currentUser.uid || !message.readBy || !message.readBy.includes(currentUser.uid)) {
                setTimeout(() => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }, 50);
            }
            
            // Cache this message for offline access
            cacheMessageForChat(currentChatId, message);
        }
        
        function cacheMessageForChat(chatId, message) {
            try {
                const cacheKey = `cachedMessages_${chatId}`;
                let cachedMessages = [];
                
                // Load existing cached messages
                const cachedData = localStorage.getItem(cacheKey);
                if (cachedData) {
                    cachedMessages = JSON.parse(cachedData);
                }
                
                // Check if message already exists in cache
                const existingIndex = cachedMessages.findIndex(m => 
                    (m.id && m.id === message.id) || (m.tempId && m.tempId === message.tempId)
                );
                
                if (existingIndex !== -1) {
                    // Update existing message
                    cachedMessages[existingIndex] = message;
                } else {
                    // Add new message
                    cachedMessages.push(message);
                }
                
                // Keep only last 200 messages per chat
                if (cachedMessages.length > 200) {
                    cachedMessages = cachedMessages.slice(-200);
                }
                
                // Save to cache
                localStorage.setItem(cacheKey, JSON.stringify(cachedMessages));
                
            } catch (error) {
                console.error('Error caching message:', error);
            }
        }
        
        function formatMessageText(text) {
            // Simple formatting - in a real app, you'd want more sophisticated parsing
            return (text || '')
                .replace(/\n/g, '<br>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>');
        }
        
        function getMessageTime(timestamp) {
            if (!timestamp) return '';
            
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m`;
            
            const diffHours = Math.floor(diffMs / 3600000);
            if (diffHours < 24) return `${diffHours}h`;
            
            // If today, show time
            if (date.getDate() === now.getDate() && 
                date.getMonth() === now.getMonth() && 
                date.getFullYear() === now.getFullYear()) {
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }
            
            // If this year, show date without year
            if (date.getFullYear() === now.getFullYear()) {
                return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
            }
            
            // Otherwise show full date
            return date.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' });
        }
        
        function createReactionsHTML(reactions) {
            const reactionCounts = {};
            Object.values(reactions).forEach(emoji => {
                reactionCounts[emoji] = (reactionCounts[emoji] || 0) + 1;
            });
            
            const reactionsHTML = Object.entries(reactionCounts).map(([emoji, count]) => {
                return `<span class="reaction" data-emoji="${emoji}">${emoji}<span class="reaction-count">${count}</span></span>`;
            }).join('');
            
            return `<div class="message-reactions">${reactionsHTML}</div>`;
        }
        
        async function sendMessage(text, type = 'text', extraData = {}) {
            if (!currentChatId || !text.trim()) return;
            
            try {
                const messageData = {
                    chatId: currentChatId,
                    type: type,
                    text: text.trim(),
                    ...extraData,
                    senderId: currentUser.uid,
                    senderName: currentUser.displayName || 'User',
                    senderPhoto: currentUser.photoURL || '',
                    timestamp: new Date().toISOString(),
                    readBy: [currentUser.uid],
                    reactions: {},
                    isEdited: false,
                    isDeleted: false
                };
                
                let messageId;
                
                if (isOnline && currentUser && currentUser.uid) {
                    // Send immediately if online
                    const messageRef = await db.collection('messages').add({
                        ...messageData,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    messageId = messageRef.id;
                    
                    // Update chat document
                    await updateChatDocument(currentChatId, {
                        lastMessage: messageData,
                        lastMessageTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        lastMessageSender: currentUser.uid,
                        unreadCount: firebase.firestore.FieldValue.increment(1)
                    });
                    
                } else {
                    // Save to pending messages if offline
                    messageId = savePendingMessage(messageData);
                    showNotification('Message saved offline. Will send when you\'re back online.', 'success');
                }
                
                // Add message to UI immediately
                const uiMessage = {
                    ...messageData,
                    id: messageId,
                    isPending: !isOnline
                };
                addMessageToUI(uiMessage);
                
                // Clear input
                const messageInput = document.getElementById('messageInput');
                if (messageInput) {
                    messageInput.value = '';
                    messageInput.style.height = 'auto';
                    updateSendButton();
                }
                
                // Stop typing indicator
                stopTyping();
                
            } catch (error) {
                console.error('Error sending message:', error);
                showNotification('Failed to send message', 'error');
            }
        }
        
        async function sendMediaMessage(file, type, caption = '') {
            if (!currentChatId || !file) return;
            
            try {
                showNotification(`Uploading ${type}...`, 'success');
                
                let content = '';
                let thumbnail = '';
                let extraData = {
                    caption: caption.trim() || null
                };
                
                if (isOnline && currentUser && currentUser.uid) {
                    // Upload to Firebase Storage
                    const fileType = type === 'image' ? 'images' : type === 'video' ? 'videos' : 'files';
                    content = await uploadToFirebaseStorage(file, fileType);
                    
                    // Generate thumbnail for video
                    if (type === 'video') {
                        thumbnail = await generateVideoThumbnail(file);
                        if (thumbnail) {
                            const thumbFile = dataURLtoFile(thumbnail, `thumb_${Date.now()}.jpg`);
                            extraData.thumbnail = await uploadToFirebaseStorage(thumbFile, 'thumbnails');
                        }
                    }
                    
                    if (type === 'file') {
                        extraData.fileName = file.name;
                        extraData.fileSize = file.size;
                    }
                    
                    if (type === 'video') {
                        extraData.duration = await getVideoDuration(file);
                    }
                    
                } else {
                    // Convert to base64 for offline storage
                    content = await fileToBase64(file);
                    
                    if (type === 'file') {
                        extraData.fileName = file.name;
                        extraData.fileSize = file.size;
                    }
                    
                    if (type === 'video') {
                        // Try to get duration and thumbnail even offline
                        try {
                            extraData.duration = await getVideoDuration(file);
                            thumbnail = await generateVideoThumbnail(file);
                            if (thumbnail) {
                                extraData.thumbnail = thumbnail;
                            }
                        } catch (error) {
                            console.error('Error processing video offline:', error);
                        }
                    }
                }
                
                // Send message
                await sendMessage('', type, {
                    ...extraData,
                    content: content
                });
                
            } catch (error) {
                console.error(`Error sending ${type} message:`, error);
                showNotification(`Failed to send ${type}`, 'error');
            }
        }
        
        async function sendVoiceMessage(blob, duration) {
            if (!currentChatId || !blob) return;
            
            try {
                showNotification('Sending voice message...', 'success');
                
                let content = '';
                
                if (isOnline && currentUser && currentUser.uid) {
                    // Upload to Firebase Storage
                    const file = new File([blob], `voice_${Date.now()}.wav`, { type: 'audio/wav' });
                    content = await uploadToFirebaseStorage(file, 'voice_messages');
                } else {
                    // Convert to base64 for offline storage
                    content = await blobToBase64(blob);
                }
                
                // Send message
                await sendMessage('', 'voice', {
                    content: content,
                    duration: duration
                });
                
            } catch (error) {
                console.error('Error sending voice message:', error);
                showNotification('Failed to send voice message', 'error');
            }
        }
        
        function setupTypingListener() {
            if (!currentChatId || !isOnline || !currentUser) return;
            
            // Clear any existing listener
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
            
            // Listen for typing status
            const typingRef = db.collection('typing').doc(currentChatId);
            
            typingRef.onSnapshot((doc) => {
                if (doc.exists) {
                    const typingData = doc.data();
                    const otherUserTyping = Object.entries(typingData)
                        .find(([userId, isTyping]) => userId !== currentUser.uid && isTyping);
                    
                    const typingIndicator = document.getElementById('typingIndicator');
                    if (typingIndicator) {
                        if (otherUserTyping) {
                            // Show typing indicator only if user is actually typing
                            typingIndicator.style.display = 'flex';
                            document.getElementById('chatUserStatus').style.display = 'none';
                        } else {
                            // Hide typing indicator
                            typingIndicator.style.display = 'none';
                            document.getElementById('chatUserStatus').style.display = 'block';
                        }
                    }
                }
            }, error => {
                console.error('Error in typing listener:', error);
            });
        }
        
        function startTyping() {
            if (!currentChatId || !isOnline || !currentUser) return;
            
            // Update typing status
            const typingRef = db.collection('typing').doc(currentChatId);
            typingRef.set({
                [currentUser.uid]: true,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true });
            
            // Clear previous timeout
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
            
            // Set timeout to stop typing after 3 seconds
            typingTimeout = setTimeout(() => {
                stopTyping();
            }, 3000);
        }
        
        function stopTyping() {
            if (!currentChatId || !isOnline || !currentUser) return;
            
            // Clear timeout
            if (typingTimeout) {
                clearTimeout(typingTimeout);
                typingTimeout = null;
            }
            
            // Update typing status
            const typingRef = db.collection('typing').doc(currentChatId);
            typingRef.set({
                [currentUser.uid]: false,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true });
        }
        
        function setupMessageListener() {
            if (!currentChatId || !currentUser) return;
            
            // Clear existing listener
            if (messagesListener) {
                messagesListener();
            }
            
            // Only set up listener if online
            if (isOnline && currentUser.uid) {
                // Set up new listener
                messagesListener = db.collection('messages')
                    .where('chatId', '==', currentChatId)
                    .orderBy('timestamp', 'asc')
                    .onSnapshot((snapshot) => {
                        snapshot.docChanges().forEach((change) => {
                            if (change.type === 'added') {
                                const messageData = change.doc.data();
                                const message = {
                                    id: change.doc.id,
                                    ...messageData,
                                    timestamp: messageData.timestamp ? messageData.timestamp.toDate() : new Date()
                                };
                                
                                // Don't add if it's our own pending message
                                if (!message.isPending || message.senderId !== currentUser.uid) {
                                    addMessageToUI(message);
                                }
                                
                                // Mark as read if it's not our message
                                if (message.senderId !== currentUser.uid) {
                                    markMessageAsRead(change.doc.id);
                                }
                            } else if (change.type === 'modified') {
                                // Update message (e.g., reactions, read status)
                                updateMessageInUI(change.doc.data());
                            }
                        });
                    }, error => {
                        console.error('Message listener error:', error);
                    });
            }
        }
        
        async function markChatAsRead(chatId) {
            if (!chatId || !isOnline || !currentUser) return;
            
            try {
                // Reset unread count
                await db.collection('chats').doc(chatId).update({
                    unreadCount: 0
                });
                
                // Update chat list
                const chatIndex = allChats.findIndex(chat => chat.chatId === chatId);
                if (chatIndex !== -1) {
                    allChats[chatIndex].unreadCount = 0;
                    updateChatListWithCache();
                }
                
            } catch (error) {
                console.error('Error marking chat as read:', error);
            }
        }
        
        async function markMessageAsRead(messageId) {
            if (!messageId || !isOnline || !currentUser) return;
            
            try {
                await db.collection('messages').doc(messageId).update({
                    readBy: firebase.firestore.FieldValue.arrayUnion(currentUser.uid)
                });
            } catch (error) {
                console.error('Error marking message as read:', error);
            }
        }
        
        async function addReactionToMessage(messageId, emoji) {
            if (!messageId || !emoji || !isOnline || !currentUser) return;
            
            try {
                await db.collection('messages').doc(messageId).update({
                    [`reactions.${currentUser.uid}`]: emoji
                });
            } catch (error) {
                console.error('Error adding reaction:', error);
            }
        }
        
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        
        function showNotification(message, type = 'success') {
            const notificationText = document.getElementById('notificationText');
            if (notificationText) {
                notificationText.textContent = message;
            }
            
            if (notification) {
                notification.className = 'notification';
                notification.classList.add(type);
                notification.classList.add('active');
                
                setTimeout(() => {
                    notification.classList.remove('active');
                }, 3000);
            }
        }
        
        function getTimeAgo(timestamp) {
            if (!timestamp) return '';
            
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m`;
            if (diffHours < 24) return `${diffHours}h`;
            if (diffDays < 7) return `${diffDays}d`;
            return `${Math.floor(diffDays / 7)}w`;
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        async function uploadToFirebaseStorage(file, folder) {
            return new Promise((resolve, reject) => {
                const storageRef = storage.ref();
                const fileRef = storageRef.child(`${folder}/${Date.now()}_${file.name}`);
                
                const uploadTask = fileRef.put(file);
                
                uploadTask.on('state_changed',
                    (snapshot) => {
                        // Progress monitoring
                        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                        console.log(`Upload is ${progress}% done`);
                    },
                    (error) => {
                        reject(error);
                    },
                    () => {
                        uploadTask.snapshot.ref.getDownloadURL().then((downloadURL) => {
                            resolve(downloadURL);
                        });
                    }
                );
            });
        }
        
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }
        
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(blob);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }
        
        function dataURLtoFile(dataurl, filename) {
            const arr = dataurl.split(',');
            const mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            
            return new File([u8arr], filename, { type: mime });
        }
        
        function generateVideoThumbnail(videoFile) {
            return new Promise((resolve) => {
                const video = document.createElement('video');
                video.preload = 'metadata';
                
                video.onloadedmetadata = function() {
                    video.currentTime = 1; // Capture at 1 second
                };
                
                video.onseeked = function() {
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    resolve(canvas.toDataURL('image/jpeg'));
                };
                
                video.src = URL.createObjectURL(videoFile);
            });
        }
        
        function getVideoDuration(videoFile) {
            return new Promise((resolve) => {
                const video = document.createElement('video');
                video.preload = 'metadata';
                
                video.onloadedmetadata = function() {
                    resolve(Math.round(video.duration));
                    URL.revokeObjectURL(video.src);
                };
                
                video.src = URL.createObjectURL(videoFile);
            });
        }
        
        function updateChatFromMessage(message) {
            // Update chat in allChats array
            const chatIndex = allChats.findIndex(chat => chat.chatId === message.chatId);
            
            if (chatIndex !== -1) {
                // Update existing chat
                allChats[chatIndex].lastMessage = message;
                allChats[chatIndex].lastMessageTimestamp = message.timestamp;
                allChats[chatIndex].lastMessageSender = message.senderId;
                
                if (message.senderId !== currentUser.uid) {
                    allChats[chatIndex].unreadCount = (allChats[chatIndex].unreadCount || 0) + 1;
                }
                
                // Move to top
                const updatedChat = allChats.splice(chatIndex, 1)[0];
                allChats.unshift(updatedChat);
                
            } else {
                // Create new chat entry
                // This would require fetching chat details
                // For now, we'll just reload chats
                loadChats();
            }
            
            // Update UI
            updateChatListWithCache();
        }
        
        function updateChatDocument(chatId, updates) {
            if (!currentUser || !currentUser.uid) return Promise.reject('No user authenticated');
            return db.collection('chats').doc(chatId).update(updates);
        }
        
        function updateMessageInUI(messageData) {
            // Implementation for updating message UI (reactions, read status, etc.)
            const messageElement = document.querySelector(`[data-message-id="${messageData.id}"]`);
            if (messageElement) {
                // Update message reactions, read status, etc.
                // This is a simplified implementation
            }
        }
        
        // ============================================
        // UI SETUP FUNCTIONS
        // ============================================
        
        function setupEventListeners() {
            // Permanent start new chat button (FIXED: Now always visible)
            if (permanentStartChatBtn) {
                permanentStartChatBtn.addEventListener('click', openNewChatModal);
            }
            
            // Original start new chat button in no-chat view
            const startNewChatBtn = document.getElementById('startNewChatBtn');
            if (startNewChatBtn) {
                startNewChatBtn.addEventListener('click', openNewChatModal);
            }
            
            // Chat category tabs
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const category = this.id.replace('Tab', '');
                    switchChatCategory(category);
                });
            });
            
            // Clear all button
            const clearAllBtn = document.getElementById('clearAllBtn');
            if (clearAllBtn) {
                clearAllBtn.addEventListener('click', clearAllChats);
            }
            
            // Clear search button
            const clearSearchBtn = document.getElementById('clearSearchBtn');
            if (clearSearchBtn) {
                clearSearchBtn.addEventListener('click', clearSearch);
            }
            
            // Search input
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', handleSearch);
            }
            
            // Contact search input
            const contactSearchInput = document.getElementById('contactSearchInput');
            if (contactSearchInput) {
                contactSearchInput.addEventListener('input', handleContactSearch);
            }
            
            // Close new chat modal
            const closeNewChatModal = document.getElementById('closeNewChatModal');
            if (closeNewChatModal) {
                closeNewChatModal.addEventListener('click', () => {
                    newChatModal.classList.remove('active');
                });
            }
            
            // Back to chats button (mobile)
            const backToChatsBtn = document.getElementById('backToChatsBtn');
            if (backToChatsBtn) {
                backToChatsBtn.addEventListener('click', () => {
                    if (window.innerWidth <= 768) {
                        sidebar.classList.add('active');
                        chatArea.classList.remove('active');
                        noChatSelected.style.display = 'flex';
                        chatActiveView.style.display = 'none';
                        currentChatId = null;
                    }
                });
            }
            
            // Send button
            const sendBtn = document.getElementById('sendBtn');
            if (sendBtn) {
                sendBtn.addEventListener('click', handleSendMessage);
            }
            
            // Emoji button
            const emojiBtn = document.getElementById('emojiBtn');
            if (emojiBtn) {
                emojiBtn.addEventListener('click', toggleEmojiPicker);
            }
            
            // Attachment button
            const attachmentBtn = document.getElementById('attachmentBtn');
            if (attachmentBtn) {
                attachmentBtn.addEventListener('click', toggleAttachmentsMenu);
            }
            
            // Attachment options
            document.querySelectorAll('.attachment-option').forEach(option => {
                option.addEventListener('click', function() {
                    const type = this.id.replace('AttachmentBtn', '').toLowerCase();
                    handleAttachment(type);
                });
            });
            
            // File upload inputs
            setupFileUploads();
            
            // Close emoji picker when clicking outside
            document.addEventListener('click', (e) => {
                const emojiPicker = document.getElementById('emojiPickerContainer');
                if (emojiPicker && !emojiBtn.contains(e.target) && !emojiPicker.contains(e.target)) {
                    emojiPicker.classList.remove('active');
                }
                
                const attachmentsMenu = document.getElementById('attachmentsMenu');
                if (attachmentsMenu && !attachmentBtn.contains(e.target) && !attachmentsMenu.contains(e.target)) {
                    attachmentsMenu.classList.remove('active');
                }
            });
            
            // Settings button
            const settingsBtn = document.getElementById('settingsBtn');
            if (settingsBtn) {
                settingsBtn.addEventListener('click', () => {
                    window.location.href = 'settings.html';
                });
            }
            
            // NEW GROUP BUTTON - Updated to navigate to group.html
            const newGroupBtn = document.getElementById('newGroupBtn');
            if (newGroupBtn) {
                newGroupBtn.addEventListener('click', () => {
                    // Navigate to the groups page
                    window.location.href = 'group.html';
                });
            }
            
            // Chat info button
            const chatInfoBtn = document.getElementById('chatInfoBtn');
            if (chatInfoBtn) {
                chatInfoBtn.addEventListener('click', () => {
                    showChatInfo();
                });
            }
            
            // Voice call button
            const voiceCallBtn = document.getElementById('voiceCallBtn');
            if (voiceCallBtn) {
                voiceCallBtn.addEventListener('click', () => {
                    showNotification('Voice call feature coming soon!', 'info');
                });
            }
            
            // Video call button
            const videoCallBtn = document.getElementById('videoCallBtn');
            if (videoCallBtn) {
                videoCallBtn.addEventListener('click', () => {
                    showNotification('Video call feature coming soon!', 'info');
                });
            }
            
            // Menu button (ellipsis)
            const menuBtn = document.getElementById('menuBtn');
            if (menuBtn) {
                menuBtn.addEventListener('click', showMenuOptions);
            }
        }
        
        function showChatInfo() {
            if (!currentChatId || !currentChatUser) return;
            
            // Create chat info overlay
            const chatInfoOverlay = document.createElement('div');
            chatInfoOverlay.id = 'chatInfoOverlay';
            chatInfoOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                z-index: 2000;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
            `;
            
            const chatInfoContainer = document.createElement('div');
            chatInfoContainer.style.cssText = `
                background: #1a1a1a;
                border-radius: 12px;
                padding: 20px;
                min-width: 300px;
                max-width: 500px;
                width: 90%;
                max-height: 90vh;
                overflow-y: auto;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            `;
            
            const initials = currentChatUser.name ? 
                currentChatUser.name.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2) : 
                'U';
            
            chatInfoContainer.innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="width: 100px; height: 100px; border-radius: 50%; background: #333; margin: 0 auto 15px; display: flex; align-items: center; justify-content: center; font-size: 36px; color: white; overflow: hidden; background-size: cover; background-position: center; ${currentChatUser.photoURL ? `background-image: url('${currentChatUser.photoURL}')` : ''}">
                        ${currentChatUser.photoURL ? '' : initials}
                    </div>
                    <h3 style="margin-bottom: 5px; color: white;">${currentChatUser.name || 'User'}</h3>
                    <p style="color: #aaa; margin-bottom: 20px;">${currentChatUser.status || 'Hey there! I am using MoodChat'}</p>
                </div>
                
                <div style="background: #2a2a2a; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span style="color: #aaa;">Status:</span>
                        <span style="color: ${currentChatUser.isOnline ? '#34c759' : '#ff9500'}">
                            ${currentChatUser.isOnline ? 'Online' : 'Offline'}
                        </span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span style="color: #aaa;">Chat ID:</span>
                        <span style="color: #aaa; font-size: 12px;">${currentChatId}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #aaa;">Chat Type:</span>
                        <span style="color: #aaa;">${currentChatType}</span>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <button id="clearChatHistoryBtn" style="width: 100%; padding: 12px; background: #333; color: white; border: none; border-radius: 8px; cursor: pointer; margin-bottom: 10px; transition: background 0.2s;">
                        <i class="fas fa-trash"></i> Clear Chat History
                    </button>
                    <button id="blockUserBtn" style="width: 100%; padding: 12px; background: #ff3b30; color: white; border: none; border-radius: 8px; cursor: pointer; margin-bottom: 10px; transition: background 0.2s;">
                        <i class="fas fa-ban"></i> Block User
                    </button>
                    <button id="reportUserBtn" style="width: 100%; padding: 12px; background: #ff9500; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background 0.2s;">
                        <i class="fas fa-flag"></i> Report User
                    </button>
                </div>
                
                <button id="closeChatInfoBtn" style="width: 100%; padding: 12px; background: #0084ff; color: white; border: none; border-radius: 8px; cursor: pointer; margin-top: 10px;">Close</button>
            `;
            
            chatInfoOverlay.appendChild(chatInfoContainer);
            document.body.appendChild(chatInfoOverlay);
            
            // Add event listeners
            document.getElementById('closeChatInfoBtn').addEventListener('click', () => {
                chatInfoOverlay.remove();
            });
            
            document.getElementById('clearChatHistoryBtn').addEventListener('click', () => {
                if (confirm('Are you sure you want to clear all messages in this chat? This action cannot be undone.')) {
                    clearChatHistory();
                    chatInfoOverlay.remove();
                }
            });
            
            document.getElementById('blockUserBtn').addEventListener('click', () => {
                if (confirm('Are you sure you want to block this user? You will no longer receive messages from them.')) {
                    blockUser();
                    chatInfoOverlay.remove();
                }
            });
            
            document.getElementById('reportUserBtn').addEventListener('click', () => {
                reportUser();
                chatInfoOverlay.remove();
            });
            
            // Close when clicking outside
            chatInfoOverlay.addEventListener('click', (e) => {
                if (e.target === chatInfoOverlay) {
                    chatInfoOverlay.remove();
                }
            });
        }
        
        function clearChatHistory() {
            if (!currentChatId) return;
            
            showNotification('Clearing chat history...', 'success');
            // In a real app, you would delete messages from Firestore
            // For now, just clear local messages
            const messagesContainer = document.getElementById('messagesContainer');
            if (messagesContainer) {
                messagesContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);"><i class="fas fa-trash"></i><p>Chat history cleared</p></div>';
            }
        }
        
        function blockUser() {
            if (!currentChatId || !currentChatUser) return;
            
            showNotification(`Blocked ${currentChatUser.name}`, 'success');
            // In a real app, you would update blocked users in Firestore
        }
        
        function reportUser() {
            if (!currentChatId || !currentChatUser) return;
            
            showNotification(`Reported ${currentChatUser.name}`, 'success');
            // In a real app, you would send a report to the server
        }
        
        function showMenuOptions() {
            // Create menu overlay
            const menuOverlay = document.createElement('div');
            menuOverlay.id = 'menuOverlay';
            menuOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 2000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const menuContainer = document.createElement('div');
            menuContainer.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 20px;
                min-width: 250px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            `;
            
            menuContainer.innerHTML = `
                <h3 style="margin-bottom: 15px; color: var(--text-primary);">Menu</h3>
                <div class="menu-option" style="padding: 12px 15px; cursor: pointer; border-radius: 8px; transition: background 0.2s; margin-bottom: 5px; display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-user-friends"></i> New Group
                </div>
                <div class="menu-option" style="padding: 12px 15px; cursor: pointer; border-radius: 8px; transition: background 0.2s; margin-bottom: 5px; display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-archive"></i> Archived Chats
                </div>
                <div class="menu-option" style="padding: 12px 15px; cursor: pointer; border-radius: 8px; transition: background 0.2s; margin-bottom: 5px; display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-star"></i> Starred Messages
                </div>
                <div class="menu-option" style="padding: 12px 15px; cursor: pointer; border-radius: 8px; transition: background 0.2s; margin-bottom: 5px; display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-cog"></i> Settings
                </div>
                <div class="menu-option" style="padding: 12px 15px; cursor: pointer; border-radius: 8px; transition: background 0.2s; margin-bottom: 5px; display: flex; align-items: center; gap: 10px; color: var(--danger-color);">
                    <i class="fas fa-sign-out-alt"></i> Logout
                </div>
                <button id="closeMenuBtn" style="margin-top: 15px; padding: 10px 20px; background: var(--secondary-color); border: none; border-radius: 8px; cursor: pointer; width: 100%;">Close</button>
            `;
            
            menuOverlay.appendChild(menuContainer);
            document.body.appendChild(menuOverlay);
            
            // Add event listeners to menu options
            const menuOptions = menuContainer.querySelectorAll('.menu-option');
            menuOptions[0].addEventListener('click', () => {
                window.location.href = 'group.html';
                menuOverlay.remove();
            });
            
            menuOptions[1].addEventListener('click', () => {
                switchChatCategory('archived');
                menuOverlay.remove();
            });
            
            menuOptions[2].addEventListener('click', () => {
                showStarredMessages();
                menuOverlay.remove();
            });
            
            menuOptions[3].addEventListener('click', () => {
                window.location.href = 'settings.html';
                menuOverlay.remove();
            });
            
            menuOptions[4].addEventListener('click', () => {
                if (confirm('Are you sure you want to logout?')) {
                    logoutUser();
                }
                menuOverlay.remove();
            });
            
            // Close menu button
            document.getElementById('closeMenuBtn').addEventListener('click', () => {
                menuOverlay.remove();
            });
            
            // Close menu when clicking outside
            menuOverlay.addEventListener('click', (e) => {
                if (e.target === menuOverlay) {
                    menuOverlay.remove();
                }
            });
        }
        
        function showStarredMessages() {
            // Create starred messages overlay
            const starredOverlay = document.createElement('div');
            starredOverlay.id = 'starredOverlay';
            starredOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                z-index: 2000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const starredContainer = document.createElement('div');
            starredContainer.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 20px;
                min-width: 300px;
                max-width: 500px;
                width: 90%;
                max-height: 90vh;
                overflow-y: auto;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            `;
            
            starredContainer.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="color: var(--text-primary);">Starred Messages</h3>
                    <button id="closeStarredBtn" style="background: none; border: none; font-size: 20px; cursor: pointer; color: var(--text-secondary);"></button>
                </div>
                <div style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
                    <i class="fas fa-star" style="font-size: 48px; margin-bottom: 15px; opacity: 0.5;"></i>
                    <p>No starred messages yet</p>
                    <p style="font-size: 14px; margin-top: 10px;">Long press on any message to star it</p>
                </div>
            `;
            
            starredOverlay.appendChild(starredContainer);
            document.body.appendChild(starredOverlay);
            
            // Close button
            document.getElementById('closeStarredBtn').addEventListener('click', () => {
                starredOverlay.remove();
            });
            
            // Close when clicking outside
            starredOverlay.addEventListener('click', (e) => {
                if (e.target === starredOverlay) {
                    starredOverlay.remove();
                }
            });
        }
        
        function logoutUser() {
            // Clear local storage
            localStorage.removeItem('currentUser');
            if (currentUser && currentUser.uid) {
                localStorage.removeItem(`cachedChats_${currentUser.uid}`);
                localStorage.removeItem(`cachedContacts_${currentUser.uid}`);
                localStorage.removeItem(`pendingMessages_${currentUser.uid}`);
            }
            // Clear generic caches
            localStorage.removeItem('cachedChats');
            localStorage.removeItem('cachedContacts');
            localStorage.removeItem('pendingMessages');
            
            // Update online status to offline
            updateUserOnlineStatus(false);
            
            // Sign out from Firebase
            auth.signOut().then(() => {
                window.location.href = 'index.html';
            }).catch(error => {
                console.error('Error signing out:', error);
                window.location.href = 'index.html';
            });
        }
        
        function setupMessageInput() {
            const messageInput = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            
            if (!messageInput || !sendBtn) return;
            
            // Auto-resize textarea
            messageInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 120) + 'px';
                
                updateSendButton();
                
                // Start typing indicator
                if (this.value.trim() && currentUser && currentUser.uid) {
                    startTyping();
                }
            });
            
            // Send on Enter (Shift+Enter for new line)
            messageInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (this.value.trim()) {
                        handleSendMessage();
                    }
                }
            });
            
            // Stop typing when input loses focus
            messageInput.addEventListener('blur', stopTyping);
        }
        
        function updateSendButton() {
            const messageInput = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            
            if (messageInput && sendBtn) {
                const hasText = messageInput.value.trim().length > 0;
                sendBtn.disabled = !hasText;
                sendBtn.style.opacity = hasText ? '1' : '0.5';
                sendBtn.style.cursor = hasText ? 'pointer' : 'not-allowed';
            }
        }
        
        function setupEmojiPicker() {
            try {
                const pickerContainer = document.getElementById('emojiPickerContainer');
                if (pickerContainer) {
                    const picker = document.createElement('emoji-picker');
                    picker.addEventListener('emoji-click', event => {
                        const emoji = event.detail.unicode;
                        const messageInput = document.getElementById('messageInput');
                        if (messageInput) {
                            messageInput.value += emoji;
                            messageInput.focus();
                            updateSendButton();
                            if (currentUser && currentUser.uid) {
                                startTyping();
                            }
                        }
                        pickerContainer.classList.remove('active');
                    });
                    
                    pickerContainer.appendChild(picker);
                }
            } catch (error) {
                console.error('Error setting up emoji picker:', error);
            }
        }
        
        function setupFileUploads() {
            // Photo upload
            const photoUploadInput = document.getElementById('photoUploadInput');
            const photoAttachmentBtn = document.getElementById('photoAttachmentBtn');
            
            if (photoUploadInput && photoAttachmentBtn) {
                photoAttachmentBtn.addEventListener('click', () => {
                    photoUploadInput.click();
                });
                
                photoUploadInput.addEventListener('change', function(e) {
                    if (e.target.files && e.target.files.length > 0) {
                        const files = Array.from(e.target.files);
                        files.forEach(file => {
                            const type = file.type.startsWith('image/') ? 'image' : 'video';
                            sendMediaMessage(file, type);
                        });
                    }
                    this.value = ''; // Reset input
                });
            }
            
            // Video upload
            const videoUploadInput = document.getElementById('videoUploadInput');
            
            if (videoUploadInput) {
                // Video is handled through the photo attachment for now
                // since we accept both image and video
            }
            
            // Document upload
            const documentUploadInput = document.getElementById('documentUploadInput');
            const documentAttachmentBtn = document.getElementById('documentAttachmentBtn');
            
            if (documentUploadInput && documentAttachmentBtn) {
                documentAttachmentBtn.addEventListener('click', () => {
                    documentUploadInput.click();
                });
                
                documentUploadInput.addEventListener('change', function(e) {
                    if (e.target.files && e.target.files.length > 0) {
                        const file = e.target.files[0];
                        sendMediaMessage(file, 'file');
                    }
                    this.value = ''; // Reset input
                });
            }
        }
        
        function setupResponsiveBehavior() {
            // Handle window resize
            window.addEventListener('resize', handleResize);
            handleResize(); // Initial check
            
            // Close sidebar when clicking on chat item on mobile
            document.addEventListener('click', (e) => {
                if (window.innerWidth <= 768) {
                    if (e.target.closest('.chat-item')) {
                        setTimeout(() => {
                            sidebar.classList.remove('active');
                            chatArea.classList.add('active');
                        }, 50);
                    }
                }
            });
        }
        
        function handleResize() {
            const backToChatsBtn = document.getElementById('backToChatsBtn');
            if (backToChatsBtn) {
                backToChatsBtn.style.display = window.innerWidth <= 768 ? 'flex' : 'none';
            }
            
            // On desktop, always show sidebar and chat area
            if (window.innerWidth > 768) {
                sidebar.classList.add('active');
                chatArea.classList.add('active');
                
                // If no chat selected, show no chat view
                if (!currentChatId) {
                    noChatSelected.style.display = 'flex';
                    chatActiveView.style.display = 'none';
                }
            }
        }
        
        // ============================================
        // EVENT HANDLERS
        // ============================================
        
        function switchChatCategory(category) {
            currentCategory = category;
            
            // Update active tab
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`${category}Tab`).classList.add('active');
            
            // Update chat list
            updateChatListWithCache();
        }
        
        function openNewChatModal() {
            if (newChatModal) {
                newChatModal.classList.add('active');
                
                // Focus search input
                const contactSearchInput = document.getElementById('contactSearchInput');
                if (contactSearchInput) {
                    contactSearchInput.focus();
                }
            }
        }
        
        function handleSearch() {
            const searchInput = document.getElementById('searchInput');
            const searchTerm = searchInput.value.trim().toLowerCase();
            
            if (!searchTerm) {
                // Show normal chat list
                updateChatListWithCache();
                return;
            }
            
            const recentChatsList = document.getElementById('recentChatsList');
            const searchResultsList = document.getElementById('searchResultsList');
            const searchResultsTitle = document.getElementById('searchResultsTitle');
            const clearAllBtn = document.getElementById('clearAllBtn');
            
            if (!recentChatsList || !searchResultsList || !searchResultsTitle) return;
            
            // Hide recent chats
            recentChatsList.style.display = 'none';
            if (clearAllBtn) clearAllBtn.style.display = 'none';
            
            // Show search results
            searchResultsList.style.display = 'block';
            searchResultsTitle.style.display = 'flex';
            
            // Filter chats
            const searchResults = filteredChats.filter(chat => {
                if (chat.type === 'individual') {
                    const userName = chat.otherUser?.name || '';
                    const lastMessage = chat.lastMessage?.text || '';
                    return userName.toLowerCase().includes(searchTerm) || 
                           lastMessage.toLowerCase().includes(searchTerm);
                } else {
                    const groupName = chat.groupName || '';
                    const lastMessage = chat.lastMessage?.text || '';
                    return groupName.toLowerCase().includes(searchTerm) || 
                           lastMessage.toLowerCase().includes(searchTerm);
                }
            });
            
            // Display search results
            searchResultsList.innerHTML = '';
            
            if (searchResults.length === 0) {
                searchResultsList.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
                        <i class="fas fa-search" style="font-size: 48px; margin-bottom: 15px; opacity: 0.5;"></i>
                        <p>No results found for "${searchTerm}"</p>
                    </div>
                `;
            } else {
                searchResults.forEach(chat => {
                    const chatItem = createChatItem(chat);
                    searchResultsList.appendChild(chatItem);
                });
            }
        }
        
        function handleContactSearch() {
            const searchInput = document.getElementById('contactSearchInput');
            const searchTerm = searchInput.value.trim().toLowerCase();
            
            const contactsList = document.getElementById('contactsList');
            const noContactsFound = document.getElementById('noContactsFound');
            
            if (!contactsList) return;
            
            if (!searchTerm) {
                // Show all contacts
                populateContactsList(userContacts.length > 0 ? userContacts : cachedContacts);
                return;
            }
            
            // Filter contacts
            const filteredContacts = (userContacts.length > 0 ? userContacts : cachedContacts).filter(contact => {
                const userName = contact.name || '';
                const userEmail = contact.email || '';
                return userName.toLowerCase().includes(searchTerm) || 
                       userEmail.toLowerCase().includes(searchTerm);
            });
            
            // Display filtered contacts
            contactsList.innerHTML = '';
            
            if (filteredContacts.length === 0) {
                if (noContactsFound) noContactsFound.style.display = 'block';
            } else {
                if (noContactsFound) noContactsFound.style.display = 'none';
                filteredContacts.forEach(contact => {
                    const contactItem = createContactItem(contact);
                    contactsList.appendChild(contactItem);
                });
            }
        }
        
        function clearAllChats() {
            if (!confirm('Are you sure you want to clear all chats? This will remove all chat history.')) {
                return;
            }
            
            // This would typically archive all chats
            showNotification('All chats cleared', 'success');
            // In a real app, you would update Firestore to mark chats as archived
        }
        
        function clearSearch() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.value = '';
            }
            updateChatListWithCache();
        }
        
        function handleSendMessage() {
            const messageInput = document.getElementById('messageInput');
            if (!messageInput || !messageInput.value.trim()) return;
            
            sendMessage(messageInput.value, 'text');
        }
        
        function toggleEmojiPicker() {
            const emojiPicker = document.getElementById('emojiPickerContainer');
            if (emojiPicker) {
                emojiPicker.classList.toggle('active');
                
                // Hide attachments menu if open
                const attachmentsMenu = document.getElementById('attachmentsMenu');
                if (attachmentsMenu) {
                    attachmentsMenu.classList.remove('active');
                }
            }
        }
        
        function toggleAttachmentsMenu() {
            const attachmentsMenu = document.getElementById('attachmentsMenu');
            if (attachmentsMenu) {
                attachmentsMenu.classList.toggle('active');
                
                // Hide emoji picker if open
                const emojiPicker = document.getElementById('emojiPickerContainer');
                if (emojiPicker) {
                    emojiPicker.classList.remove('active');
                }
            }
        }
        
        function handleAttachment(type) {
            // Hide attachments menu
            const attachmentsMenu = document.getElementById('attachmentsMenu');
            if (attachmentsMenu) {
                attachmentsMenu.classList.remove('active');
            }
            
            switch(type) {
                case 'photo':
                    // Photo and video
                    const photoUploadInput = document.getElementById('photoUploadInput');
                    if (photoUploadInput) {
                        photoUploadInput.accept = 'image/*,video/*';
                        photoUploadInput.click();
                    }
                    break;
                    
                case 'document':
                    // Document
                    const documentUploadInput = document.getElementById('documentUploadInput');
                    if (documentUploadInput) {
                        documentUploadInput.click();
                    }
                    break;
                    
                case 'voice':
                    // Voice message
                    startVoiceRecording();
                    break;
                    
                case 'location':
                    // Location
                    shareLocation();
                    break;
                    
                case 'contact':
                    // Contact
                    shareContact();
                    break;
            }
        }
        
        function startVoiceRecording() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showNotification('Microphone access not available', 'error');
                return;
            }
            
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    recordingTime = 0;
                    
                    mediaRecorder.ondataavailable = event => {
                        audioChunks.push(event.data);
                    };
                    
                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        sendVoiceMessage(audioBlob, recordingTime);
                        
                        // Stop all tracks
                        stream.getTracks().forEach(track => track.stop());
                        
                        // Reset UI
                        isRecording = false;
                        clearInterval(recordingTimer);
                    };
                    
                    mediaRecorder.start();
                    isRecording = true;
                    
                    // Start timer
                    recordingTimer = setInterval(() => {
                        recordingTime++;
                        // Max 2 minutes
                        if (recordingTime >= 120) {
                            stopVoiceRecording();
                        }
                    }, 1000);
                    
                    // Show recording UI
                    showRecordingUI();
                    
                })
                .catch(error => {
                    console.error('Error accessing microphone:', error);
                    showNotification('Microphone access denied', 'error');
                });
        }
        
        function stopVoiceRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                hideRecordingUI();
            }
        }
        
        function showRecordingUI() {
            // Create recording overlay
            const recordingOverlay = document.createElement('div');
            recordingOverlay.id = 'recordingOverlay';
            recordingOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 2000;
                color: white;
            `;
            
            recordingOverlay.innerHTML = `
                <div style="text-align: center;">
                    <div style="width: 80px; height: 80px; border-radius: 50%; background: #ff3b30; margin: 0 auto 20px; display: flex; align-items: center; justify-content: center; animation: pulse 1.5s infinite;">
                        <i class="fas fa-microphone" style="font-size: 30px;"></i>
                    </div>
                    <div style="font-size: 24px; margin-bottom: 10px;">Recording...</div>
                    <div id="recordingTimeDisplay" style="font-size: 18px; margin-bottom: 30px;">00:00</div>
                    <button id="stopRecordingBtn" style="padding: 15px 30px; background: #ff3b30; color: white; border: none; border-radius: 25px; font-size: 16px; cursor: pointer;">
                        Stop Recording
                    </button>
                </div>
            `;
            
            document.body.appendChild(recordingOverlay);
            
            // Update timer display
            const timeDisplay = document.getElementById('recordingTimeDisplay');
            const timerInterval = setInterval(() => {
                const minutes = Math.floor(recordingTime / 60).toString().padStart(2, '0');
                const seconds = (recordingTime % 60).toString().padStart(2, '0');
                if (timeDisplay) {
                    timeDisplay.textContent = `${minutes}:${seconds}`;
                }
            }, 1000);
            
            // Stop recording button
            document.getElementById('stopRecordingBtn').addEventListener('click', () => {
                clearInterval(timerInterval);
                stopVoiceRecording();
            });
            
            // Add CSS for pulse animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes pulse {
                    0% { transform: scale(1); opacity: 1; }
                    50% { transform: scale(1.1); opacity: 0.8; }
                    100% { transform: scale(1); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
        }
        
        function hideRecordingUI() {
            const recordingOverlay = document.getElementById('recordingOverlay');
            if (recordingOverlay) {
                recordingOverlay.remove();
            }
        }
        
        function shareLocation() {
            if (!navigator.geolocation) {
                showNotification('Geolocation is not supported by your browser', 'error');
                return;
            }
            
            showNotification('Getting your location...', 'success');
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const { latitude, longitude } = position.coords;
                    
                    // Get location name using reverse geocoding
                    fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}`)
                        .then(response => response.json())
                        .then(data => {
                            const locationName = data.display_name || 'Unknown Location';
                            const address = data.address || {};
                            
                            sendMessage('', 'location', {
                                latitude: latitude,
                                longitude: longitude,
                                locationName: locationName,
                                address: `${address.road || ''} ${address.city || ''} ${address.country || ''}`.trim()
                            });
                        })
                        .catch(error => {
                            console.error('Error getting location name:', error);
                            sendMessage('', 'location', {
                                latitude: latitude,
                                longitude: longitude,
                                locationName: 'My Location'
                            });
                        });
                },
                (error) => {
                    console.error('Error getting location:', error);
                    showNotification('Failed to get location', 'error');
                }
            );
        }
        
        function shareContact() {
            showNotification('Contact sharing feature coming soon!', 'info');
        }
        
        function showMessageMenu(e, message) {
            e.preventDefault();
            
            // Remove existing menu
            if (messageMenu) {
                messageMenu.remove();
            }
            
            // Create menu
            messageMenu = document.createElement('div');
            messageMenu.className = 'message-menu';
            messageMenu.style.top = e.clientY + 'px';
            messageMenu.style.left = e.clientX + 'px';
            
            selectedMessageId = message.id || message.tempId;
            
            const isMyMessage = message.senderId === currentUser.uid;
            
            let menuItems = [];
            
            if (isMyMessage) {
                menuItems = [
                    { icon: 'fas fa-reply', text: 'Reply', action: () => replyToMessage(message) },
                    { icon: 'fas fa-edit', text: 'Edit', action: () => editMessage(message) },
                    { icon: 'fas fa-trash', text: 'Delete', action: () => deleteMessage(message) },
                    { icon: 'fas fa-copy', text: 'Copy', action: () => copyMessageText(message) },
                    { icon: 'fas fa-star', text: 'Star', action: () => starMessage(message) }
                ];
            } else {
                menuItems = [
                    { icon: 'fas fa-reply', text: 'Reply', action: () => replyToMessage(message) },
                    { icon: 'fas fa-copy', text: 'Copy', action: () => copyMessageText(message) },
                    { icon: 'fas fa-star', text: 'Star', action: () => starMessage(message) },
                    { icon: 'fas fa-flag', text: 'Report', action: () => reportMessage(message) }
                ];
            }
            
            menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.className = 'menu-item';
                menuItem.innerHTML = `<i class="${item.icon}"></i> ${item.text}`;
                menuItem.addEventListener('click', () => {
                    item.action();
                    messageMenu.remove();
                    messageMenu = null;
                });
                messageMenu.appendChild(menuItem);
            });
            
            // Add reaction options
            const reactionsDiv = document.createElement('div');
            reactionsDiv.className = 'menu-item';
            reactionsDiv.innerHTML = '<i class="fas fa-smile"></i> React';
            
            const reactions = ['', '', '', '', '', ''];
            const reactionsSubmenu = document.createElement('div');
            reactionsSubmenu.className = 'message-menu';
            reactionsSubmenu.style.display = 'none';
            reactionsSubmenu.style.position = 'absolute';
            reactionsSubmenu.style.left = '100%';
            reactionsSubmenu.style.top = '0';
            
            reactions.forEach(emoji => {
                const reactionItem = document.createElement('div');
                reactionItem.className = 'menu-item';
                reactionItem.textContent = emoji;
                reactionItem.addEventListener('click', () => {
                    addReactionToMessage(selectedMessageId, emoji);
                    messageMenu.remove();
                    messageMenu = null;
                });
                reactionsSubmenu.appendChild(reactionItem);
            });
            
            reactionsDiv.addEventListener('mouseenter', () => {
                reactionsSubmenu.style.display = 'block';
            });
            
            reactionsDiv.addEventListener('mouseleave', () => {
                setTimeout(() => {
                    if (!reactionsSubmenu.matches(':hover')) {
                        reactionsSubmenu.style.display = 'none';
                    }
                }, 100);
            });
            
            reactionsSubmenu.addEventListener('mouseleave', () => {
                reactionsSubmenu.style.display = 'none';
            });
            
            messageMenu.appendChild(reactionsDiv);
            messageMenu.appendChild(reactionsSubmenu);
            
            document.body.appendChild(messageMenu);
            
            // Close menu when clicking outside
            setTimeout(() => {
                const closeMenu = (e) => {
                    if (messageMenu && !messageMenu.contains(e.target)) {
                        messageMenu.remove();
                        messageMenu = null;
                        document.removeEventListener('click', closeMenu);
                    }
                };
                document.addEventListener('click', closeMenu);
            }, 10);
        }
        
        function starMessage(message) {
            showNotification('Message starred', 'success');
            // In a real app, you would save starred messages to Firestore
        }
        
        function replyToMessage(message) {
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                const senderName = message.senderId === currentUser.uid ? 'You' : message.senderName;
                const preview = message.type === 'text' ? message.text : 
                              message.type === 'image' ? ' Photo' :
                              message.type === 'voice' ? ' Voice message' : 'Message';
                
                messageInput.value = `Replying to ${senderName}: ${preview}\n`;
                messageInput.focus();
                updateSendButton();
            }
        }
        
        function editMessage(message) {
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.value = message.text || '';
                messageInput.focus();
                updateSendButton();
                
                // Change send button to edit
                const sendBtn = document.getElementById('sendBtn');
                if (sendBtn) {
                    sendBtn.innerHTML = '<i class="fas fa-check"></i>';
                    sendBtn.onclick = () => {
                        updateMessage(message.id, messageInput.value);
                        messageInput.value = '';
                        sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
                        sendBtn.onclick = handleSendMessage;
                        updateSendButton();
                    };
                }
            }
        }
        
        async function updateMessage(messageId, newText) {
            if (!messageId || !newText.trim() || !isOnline || !currentUser) return;
            
            try {
                await db.collection('messages').doc(messageId).update({
                    text: newText.trim(),
                    isEdited: true,
                    editedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                showNotification('Message updated', 'success');
            } catch (error) {
                console.error('Error updating message:', error);
                showNotification('Failed to update message', 'error');
            }
        }
        
        async function deleteMessage(message) {
            if (!confirm('Are you sure you want to delete this message?')) {
                return;
            }
            
            if (isOnline && message.id && currentUser) {
                try {
                    await db.collection('messages').doc(message.id).update({
                        isDeleted: true,
                        deletedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    showNotification('Message deleted', 'success');
                } catch (error) {
                    console.error('Error deleting message:', error);
                    showNotification('Failed to delete message', 'error');
                }
            } else {
                // For offline or pending messages, just remove from UI
                const messageElement = document.querySelector(`[data-message-id="${message.id || message.tempId}"]`);
                if (messageElement) {
                    messageElement.remove();
                }
                showNotification('Message deleted', 'success');
            }
        }
        
        function copyMessageText(message) {
            const text = message.text || '';
            if (text) {
                navigator.clipboard.writeText(text).then(() => {
                    showNotification('Message copied to clipboard', 'success');
                }).catch(err => {
                    console.error('Failed to copy text: ', err);
                    showNotification('Failed to copy message', 'error');
                });
            }
        }
        
        function reportMessage(message) {
            showNotification('Message reported', 'success');
            // In a real app, you would send a report to the server
        }
        
        // ============================================
        // LOAD USER DATA FUNCTIONS
        // ============================================
        
        function loadUserData() {
            if (!currentUser) return;
            
            // Update user avatar in header if needed
            console.log('User data loaded:', currentUser.displayName);
        }
        
        async function loadOnlineUsers() {
            if (!isOnline || !currentUser) return;
            
            try {
                // Listen for online users
                db.collection('users').where('isOnline', '==', true)
                    .onSnapshot((snapshot) => {
                        onlineUsers = [];
                        snapshot.forEach(doc => {
                            if (doc.id !== currentUser.uid) {
                                onlineUsers.push(doc.id);
                            }
                        });
                        
                        // Update chat list to show online status
                        updateChatListWithCache();
                        
                        // Update current chat user status if in a chat
                        if (currentChatId && currentChatUser) {
                            const isOnline = onlineUsers.includes(currentChatUser.uid);
                            const statusElement = document.getElementById('chatUserStatus');
                            if (statusElement) {
                                if (isOnline) {
                                    statusElement.textContent = 'Online';
                                    statusElement.style.color = 'var(--success-color)';
                                } else {
                                    statusElement.textContent = 'Offline';
                                    statusElement.style.color = 'var(--text-secondary)';
                                }
                            }
                        }
                    }, error => {
                        console.error('Error loading online users:', error);
                    });
            } catch (error) {
                console.error('Error loading online users:', error);
            }
        }
        
        // ============================================
        // GLOBAL FUNCTIONS FOR MESSAGE INTERACTIONS
        // ============================================
        
        // These functions are called from inline event handlers in messages
        window.viewImage = function(imageUrl) {
            // Create image viewer modal
            const imageViewer = document.createElement('div');
            imageViewer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 2000;
                cursor: pointer;
            `;
            
            imageViewer.innerHTML = `
                <img src="${imageUrl}" style="max-width: 90%; max-height: 90%; object-fit: contain;">
                <button style="position: absolute; top: 20px; right: 20px; background: rgba(255,255,255,0.2); color: white; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 20px; cursor: pointer;">
                    <i class="fas fa-times"></i>
                </button>
            `;
            
            document.body.appendChild(imageViewer);
            
            // Close on click
            imageViewer.addEventListener('click', (e) => {
                if (e.target === imageViewer || e.target.closest('button')) {
                    imageViewer.remove();
                }
            });
        };
        
        window.playVoiceMessage = function(audioUrl) {
            const audio = new Audio(audioUrl);
            audio.play().catch(error => {
                console.error('Error playing audio:', error);
                showNotification('Failed to play voice message', 'error');
            });
        };
        
        // Initialize when page loads
        window.addEventListener('load', () => {
            console.log('Messages page loaded with offline support');
            
            // Ensure permanent start chat button is always visible
            if (permanentStartChatBtn) {
                permanentStartChatBtn.style.display = 'flex';
            }
        });
    </script>
</body>
</html>