<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="manifest" href="../manifest.json">
    <meta name="theme-color" content="#4F46E5">
    <link rel="icon" href="../icons/moodchat-192.png">
    <link rel="icon" href="../icons/moodchat-512.png">
    <meta name="theme-color" content="#000000">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Status | Chat App</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-storage-compat.js"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Cloudinary Widget -->
    <script src="https://upload-widget.cloudinary.com/global/all.js" type="text/javascript"></script>
    
    <!-- Emoji Picker - Corrected CDN -->
    <script src="https://cdn.jsdelivr.net/npm/emoji-picker-element@1/dist/index.js"></script>
    
    <!-- Canvas Tools for Drawing -->
    <script src="https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js"></script>
    
    <!-- Video.js for video trimming -->
    <link href="https://vjs.zencdn.net/8.6.1/video-js.css" rel="stylesheet">
    <script src="https://vjs.zencdn.net/8.6.1/video.min.js"></script>
    
    <!-- WaveSurfer.js for voice status -->
    <script src="https://unpkg.com/wavesurfer.js@7"></script>
    
    <style>
        /* OFFLINE STATUS INDICATOR - Enhanced */
        .offline-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: #ff9500;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 2000;
            display: none;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
        
        .offline-indicator.active {
            display: flex;
        }
        
        .offline-status-tag {
            display: inline-block;
            background-color: #666;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 5px;
            vertical-align: middle;
        }
        
        .pending-upload-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: #ff9500;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            z-index: 2;
            animation: spin 2s linear infinite;
        }
        
        .retry-upload-btn {
            background-color: #0084ff;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            margin-left: 5px;
        }
        
        .retry-upload-btn:hover {
            background-color: #0073e6;
        }
        
        /* Offline User Status */
        .offline-user-avatar {
            position: relative;
        }
        
        .offline-user-avatar::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 10px;
            height: 10px;
            background-color: #ff9500;
            border-radius: 50%;
            border: 2px solid var(--bg-color);
        }
        
        /* Existing CSS remains unchanged */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        :root {
            --primary-color: #0084ff;
            --secondary-color: #f0f2f5;
            --danger-color: #ff3b30;
            --success-color: #34c759;
            --warning-color: #ff9500;
            --text-primary: #050505;
            --text-secondary: #65676b;
            --bg-color: #ffffff;
            --border-color: #dddfe2;
            --status-gradient: linear-gradient(45deg, #0084ff, #00c6ff);
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 30px rgba(0, 0, 0, 0.2);
            --unviewed-ring: #0084ff;
            --viewed-ring: #65676b;
        }
        
        body {
            background-color: #000;
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }
        
        .app-container {
            display: flex;
            height: 100vh;
            background-color: var(--bg-color);
        }
        
        /* Sidebar Styles */
        .sidebar {
            width: 380px;
            background-color: var(--bg-color);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }
        
        .sidebar-header {
            padding: 20px;
            background: var(--status-gradient);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .sidebar-header h2 {
            font-size: 24px;
            font-weight: 600;
        }
        
        .new-status-btn {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 45px;
            height: 45px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }
        
        .new-status-btn:hover {
            background-color: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .status-categories {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-color);
        }
        
        .category-btn {
            flex: 1;
            padding: 15px;
            text-align: center;
            font-weight: 500;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }
        
        .category-btn.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        
        .category-btn:hover {
            background-color: var(--secondary-color);
        }
        
        .status-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }
        
        .section-title {
            padding: 15px 20px;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .recent-updates {
            padding: 0 20px;
            margin-bottom: 20px;
        }
        
        .my-status-item {
            display: flex;
            align-items: center;
            padding: 15px;
            background-color: var(--secondary-color);
            border-radius: 12px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            position: relative;
        }
        
        .my-status-item:hover {
            background-color: #e4e6e9;
            border-color: var(--primary-color);
        }
        
        .my-status-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--status-gradient);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            margin-right: 15px;
            position: relative;
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }
        
        .my-status-avatar.has-status {
            border: 3px solid var(--unviewed-ring);
        }
        
        .my-status-avatar.viewed {
            border: 3px solid var(--viewed-ring);
        }
        
        .add-status-indicator {
            position: absolute;
            bottom: 0;
            right: 0;
            background-color: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px solid var(--bg-color);
        }
        
        .my-status-info {
            flex: 1;
        }
        
        .my-status-title {
            font-weight: 600;
            font-size: 17px;
            margin-bottom: 5px;
        }
        
        .my-status-desc {
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        .status-options {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .status-option-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .status-option-btn:hover {
            background-color: var(--secondary-color);
            color: var(--primary-color);
        }
        
        .contacts-status-list {
            padding: 0 20px;
        }
        
        .contact-status-item {
            display: flex;
            align-items: center;
            padding: 12px 0;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 8px;
            padding-left: 10px;
            position: relative;
        }
        
        .contact-status-item:hover {
            background-color: var(--secondary-color);
        }
        
        .contact-status-item.has-status {
            position: relative;
        }
        
        .contact-status-item.has-status::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 60%;
            background: var(--status-gradient);
            border-radius: 0 4px 4px 0;
        }
        
        .contact-status-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: white;
            margin-right: 15px;
            position: relative;
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }
        
        .status-ring {
            position: absolute;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: 2px solid var(--unviewed-ring);
            top: -3px;
            left: -3px;
        }
        
        .status-ring.viewed {
            border-color: var(--viewed-ring);
        }
        
        .contact-status-info {
            flex: 1;
        }
        
        .contact-status-name {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 3px;
        }
        
        .contact-status-time {
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        .contact-status-count {
            background-color: var(--primary-color);
            color: white;
            font-size: 12px;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
        }
        
        /* Main Content - Status Viewer */
        .status-viewer {
            flex: 1;
            background-color: #000;
            position: relative;
            display: none;
            touch-action: pan-x pan-y;
        }
        
        .status-viewer.active {
            display: block;
        }
        
        .status-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 10;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%);
        }
        
        .status-user-info {
            display: flex;
            align-items: center;
            color: white;
        }
        
        .status-user-avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: white;
            margin-right: 12px;
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }
        
        .status-user-details h4 {
            font-size: 17px;
            font-weight: 600;
            margin-bottom: 3px;
        }
        
        .status-user-details p {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .status-close-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }
        
        .status-close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .status-progress-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px;
            display: flex;
            gap: 5px;
            z-index: 5;
        }
        
        .status-progress-bar {
            flex: 1;
            height: 3px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .status-progress-fill {
            height: 100%;
            background-color: white;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .status-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .status-media {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .text-status {
            font-size: 32px;
            color: white;
            text-align: center;
            padding: 40px;
            max-width: 800px;
            text-shadow: 2px 2px 10px rgba(0,0,0,0.5);
            word-wrap: break-word;
        }
        
        .status-footer {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 30px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 10;
            background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%);
        }
        
        .status-reply-input {
            flex: 1;
            padding: 12px 20px;
            border-radius: 25px;
            border: none;
            font-size: 15px;
            margin-right: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            backdrop-filter: blur(10px);
        }
        
        .status-reply-input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }
        
        .status-action-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            margin: 0 5px;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }
        
        .status-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        /* Chat Button in Status Info */
        .chat-user-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            margin-top: 10px;
        }
        
        .chat-user-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        /* Create Status Modal */
        .create-status-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .create-status-modal.active {
            display: flex;
        }
        
        .create-status-container {
            width: 90%;
            max-width: 600px;
            background-color: var(--bg-color);
            border-radius: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: 90vh;
            box-shadow: var(--shadow-lg);
        }
        
        .create-status-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--status-gradient);
            color: white;
        }
        
        .create-status-header h3 {
            font-size: 20px;
            font-weight: 600;
        }
        
        .create-status-close {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
        }
        
        .create-status-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .create-status-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            overflow-x: auto;
        }
        
        .create-status-tab {
            flex: none;
            padding: 15px 20px;
            text-align: center;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }
        
        .create-status-tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        
        .create-status-tab:hover {
            background-color: var(--secondary-color);
        }
        
        .create-status-content {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
        }
        
        .status-type-container {
            display: none;
        }
        
        .status-type-container.active {
            display: block;
        }
        
        .text-editor-container {
            width: 100%;
            min-height: 300px;
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            background-color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        .text-editor {
            width: 100%;
            min-height: 200px;
            background: none;
            border: none;
            font-size: 28px;
            color: var(--text-primary);
            resize: none;
            text-align: center;
            outline: none;
            font-weight: 500;
            padding: 20px;
        }
        
        .emoji-only-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            margin-bottom: 20px;
            background-color: var(--secondary-color);
            padding: 20px;
        }
        
        .emoji-only-display {
            font-size: 80px;
            margin-bottom: 20px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .emoji-only-display:hover {
            transform: scale(1.2);
        }
        
        .emoji-picker-container {
            position: absolute;
            bottom: 100%;
            left: 0;
            z-index: 1000;
            background: var(--bg-color);
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .emoji-picker-container.active {
            display: block;
        }
        
        .text-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .text-tool-btn {
            padding: 10px 15px;
            background-color: var(--secondary-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }
        
        .text-tool-btn:hover {
            background-color: #e4e6e9;
        }
        
        .text-tool-btn.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .color-palette {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .color-option {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.2s;
        }
        
        .color-option:hover {
            transform: scale(1.1);
        }
        
        .color-option.active {
            border-color: var(--text-primary);
            transform: scale(1.1);
        }
        
        .font-options {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .font-option {
            padding: 8px 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .font-option:hover {
            background-color: var(--secondary-color);
        }
        
        .font-option.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .media-upload-area {
            width: 100%;
            min-height: 300px;
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.2s;
            background-color: var(--secondary-color);
            position: relative;
            overflow: hidden;
        }
        
        .media-upload-area:hover {
            border-color: var(--primary-color);
            background-color: #e8f4ff;
        }
        
        .media-upload-icon {
            font-size: 60px;
            color: var(--text-secondary);
            margin-bottom: 15px;
        }
        
        .media-upload-text {
            font-size: 18px;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }
        
        .media-upload-subtext {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .media-preview {
            width: 100%;
            height: 300px;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 20px;
            position: relative;
            display: none;
        }
        
        .media-preview.active {
            display: block;
        }
        
        .media-preview-img, .media-preview-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .media-edit-tools {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .media-edit-btn {
            padding: 10px 15px;
            background-color: var(--secondary-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }
        
        .media-edit-btn:hover {
            background-color: #e4e6e9;
        }
        
        /* Voice Status Styles */
        .voice-recorder-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 30px;
        }
        
        .waveform-container {
            width: 100%;
            height: 100px;
            background: var(--secondary-color);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .recording-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .record-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background-color: var(--danger-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.2s;
        }
        
        .record-btn.recording {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .recording-timer {
            font-size: 24px;
            font-weight: bold;
            color: var(--text-primary);
        }
        
        .voice-playback {
            display: flex;
            align-items: center;
            gap: 15px;
            width: 100%;
        }
        
        .play-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        /* Poll Container */
        .poll-container {
            width: 100%;
            padding: 20px;
            background: var(--secondary-color);
            border-radius: 12px;
            margin-bottom: 20px;
        }
        
        .poll-question-input {
            width: 100%;
            padding: 15px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 15px;
            background: var(--bg-color);
        }
        
        .poll-option {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .poll-option-input {
            flex: 1;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-color);
        }
        
        .add-option-btn {
            padding: 8px 15px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }
        
        /* Question Sticker */
        .question-container {
            width: 100%;
            padding: 20px;
            background: var(--secondary-color);
            border-radius: 12px;
            margin-bottom: 20px;
        }
        
        .question-input {
            width: 100%;
            padding: 15px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 15px;
            background: var(--bg-color);
        }
        
        /* Music Sticker */
        .music-container {
            width: 100%;
            padding: 20px;
            background: var(--secondary-color);
            border-radius: 12px;
            margin-bottom: 20px;
        }
        
        .music-search {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 15px;
            background: var(--bg-color);
        }
        
        .music-results {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-color);
        }
        
        .music-result {
            padding: 10px 15px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .music-result:hover {
            background: var(--secondary-color);
        }
        
        /* Video Trimmer */
        .video-trimmer-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1200;
            flex-direction: column;
        }
        
        .video-trimmer-container.active {
            display: flex;
        }
        
        .video-trimmer-preview {
            flex: 1;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .trim-controls {
            padding: 20px;
            background: var(--bg-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .trim-range {
            flex: 1;
            margin: 0 20px;
        }
        
        .trim-time {
            font-weight: bold;
            color: var(--text-primary);
        }
        
        /* AI Features */
        .ai-suggestions {
            background: var(--secondary-color);
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
        }
        
        .ai-suggestion {
            padding: 10px;
            background: var(--bg-color);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .ai-suggestion:hover {
            background: #e4e6e9;
        }
        
        .auto-caption {
            padding: 10px 15px;
            background: var(--primary-color);
            color: white;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 14px;
        }
        
        /* Schedule Status */
        .schedule-container {
            padding: 15px;
            background: var(--secondary-color);
            border-radius: 12px;
            margin-bottom: 20px;
        }
        
        .schedule-input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            margin-top: 10px;
            background: var(--bg-color);
        }
        
        /* Group Status */
        .group-status-selector {
            padding: 15px;
            background: var(--secondary-color);
            border-radius: 12px;
            margin-bottom: 20px;
        }
        
        .group-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--bg-color);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
        }
        
        .group-option.active {
            background: var(--primary-color);
            color: white;
        }
        
        .drawing-canvas-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1100;
            flex-direction: column;
        }
        
        .drawing-canvas-container.active {
            display: flex;
        }
        
        .drawing-canvas {
            flex: 1;
            background-color: white;
            cursor: crosshair;
        }
        
        .drawing-tools {
            padding: 15px;
            background-color: var(--bg-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .drawing-colors {
            display: flex;
            gap: 10px;
        }
        
        .drawing-color {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
        }
        
        .drawing-color.active {
            border-color: var(--text-primary);
        }
        
        .drawing-brushes {
            display: flex;
            gap: 10px;
        }
        
        .drawing-brush {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: #333;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }
        
        .drawing-brush.active {
            background-color: var(--primary-color);
        }
        
        .create-status-footer {
            padding: 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .privacy-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .privacy-btn {
            padding: 8px 15px;
            background-color: var(--secondary-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }
        
        .privacy-btn.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        /* Duration Selector */
        .duration-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .duration-btn {
            padding: 8px 15px;
            background-color: var(--secondary-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .duration-btn.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        /* Privacy Settings Modal */
        .privacy-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .privacy-modal.active {
            display: flex;
        }
        
        .privacy-modal-content {
            width: 90%;
            max-width: 400px;
            background-color: var(--bg-color);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: var(--shadow-lg);
        }
        
        .privacy-modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .privacy-modal-header h3 {
            font-size: 18px;
            font-weight: 600;
        }
        
        .privacy-options {
            padding: 20px;
        }
        
        .privacy-option {
            display: flex;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
        }
        
        .privacy-option:last-child {
            border-bottom: none;
        }
        
        .privacy-option-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            color: var(--primary-color);
        }
        
        .privacy-option-info {
            flex: 1;
        }
        
        .privacy-option-title {
            font-weight: 500;
            margin-bottom: 3px;
        }
        
        .privacy-option-desc {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .privacy-option-check {
            color: var(--primary-color);
            font-size: 20px;
            opacity: 0;
        }
        
        .privacy-option.active .privacy-option-check {
            opacity: 1;
        }
        
        /* Status Info Modal */
        .status-info-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .status-info-modal.active {
            display: flex;
        }
        
        .status-info-content {
            width: 90%;
            max-width: 400px;
            background-color: var(--bg-color);
            border-radius: 12px;
            overflow: hidden;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        
        .status-info-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .status-info-header h3 {
            font-size: 18px;
            font-weight: 600;
        }
        
        .viewers-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }
        
        .viewer-item {
            display: flex;
            align-items: center;
            padding: 12px 20px;
        }
        
        .viewer-avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: white;
            margin-right: 15px;
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }
        
        .viewer-info {
            flex: 1;
        }
        
        .viewer-name {
            font-weight: 500;
            margin-bottom: 3px;
        }
        
        .viewer-time {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        /* Loading States - HIDDEN */
        .loading {
            opacity: 0.7;
            pointer-events: none;
            display: none !important;
        }
        
        .spinner {
            border: 3px solid var(--secondary-color);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
            display: none !important;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Notifications */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--success-color);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
        }
        
        .notification.active {
            transform: translateY(0);
            opacity: 1;
        }
        
        .notification.error {
            background-color: var(--danger-color);
        }
        
        .notification.warning {
            background-color: var(--warning-color);
        }
        
        /* Swipe Zones */
        .swipe-zone {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100px;
            z-index: 5;
            cursor: pointer;
        }
        
        .swipe-left {
            left: 0;
        }
        
        .swipe-right {
            right: 0;
        }
        
        /* Pause Overlay */
        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 15;
        }
        
        .pause-overlay.active {
            display: flex;
        }
        
        .pause-icon {
            font-size: 60px;
            color: white;
            opacity: 0.8;
        }
        
        /* Poll Display */
        .poll-display {
            position: absolute;
            bottom: 120px;
            left: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 15px;
            z-index: 20;
        }
        
        .poll-option-result {
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .poll-option-result:hover {
            background: var(--secondary-color);
        }
        
        .poll-bar {
            height: 5px;
            background: var(--primary-color);
            border-radius: 3px;
            margin-top: 5px;
            transition: width 0.3s;
        }
        
        /* Question Display */
        .question-display {
            position: absolute;
            bottom: 120px;
            left: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 15px;
            z-index: 20;
            display: flex;
            flex-direction: column;
        }
        
        .answer-input {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-top: 10px;
        }
        
        /* Music Display */
        .music-display {
            position: absolute;
            bottom: 120px;
            left: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 15px;
            z-index: 20;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .music-info {
            flex: 1;
        }
        
        .music-controls {
            display: flex;
            gap: 10px;
        }
        
        /* Responsive */
        @media (max-width: 1024px) {
            .sidebar {
                width: 350px;
            }
        }
        
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 60vh;
            }
            
            .status-viewer {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 100;
            }
            
            .create-status-container {
                width: 95%;
                max-height: 95vh;
            }
        }
        
        /* Emoji Reactions */
        .emoji-reactions {
            position: absolute;
            bottom: 100px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 20;
        }
        
        .emoji-reaction {
            background: rgba(255, 255, 255, 0.9);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .emoji-reaction:hover {
            transform: scale(1.1);
        }
        
        /* Text Formatting Preview */
        .text-bold {
            font-weight: bold;
        }
        
        .text-italic {
            font-style: italic;
        }
        
        .text-strikethrough {
            text-decoration: line-through;
        }
        
        .text-monospace {
            font-family: monospace;
        }
        
        /* Share Status Button */
        .share-status-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            margin-top: 10px;
        }
        
        .share-status-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        /* Screenshot Detection Overlay */
        .screenshot-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .screenshot-overlay.active {
            display: flex;
        }
        
        .screenshot-message {
            background-color: var(--bg-color);
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
            box-shadow: var(--shadow-lg);
        }
        
        /* Highlight Status */
        .highlight-btn {
            position: absolute;
            top: 20px;
            right: 70px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 10;
        }
        
        .highlighted-status {
            border: 3px solid gold !important;
        }
        
        /* Archive Styles */
        .archived-status {
            opacity: 0.7;
        }
        
        .restore-btn {
            padding: 5px 10px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
        }
        
        /* Offline Cache Status */
        .offline-cache-info {
            background-color: var(--secondary-color);
            padding: 10px 15px;
            border-radius: 8px;
            margin: 10px 20px;
            font-size: 12px;
            color: var(--text-secondary);
            text-align: center;
        }
        
        .offline-cache-info i {
            margin-right: 5px;
        }
        
        /* INSTANT LOADING STYLES */
        .instant-load {
            transition: opacity 0.3s ease;
        }
        
        .hidden {
            display: none !important;
        }
        
        .visible {
            display: block !important;
        }
        
        /* Smooth transitions */
        .status-item-enter {
            opacity: 0;
            transform: translateY(10px);
        }
        
        .status-item-enter-active {
            opacity: 1;
            transform: translateY(0);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Offline Indicator -->
    <div class="offline-indicator" id="offlineIndicator">
        <i class="fas fa-wifi-slash"></i>
        <span>You're offline. Showing cached statuses.</span>
    </div>
    
    <div class="app-container">
        <!-- Sidebar with status updates -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h2>Status</h2>
                <button class="new-status-btn" id="newStatusBtn">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
            
            <div class="status-categories">
                <button class="category-btn active" id="recentTab">Recent</button>
                <button class="category-btn" id="viewedTab">Viewed</button>
                <button class="category-btn" id="mutedTab">Muted</button>
                <button class="category-btn" id="archiveTab">Archive</button>
                <button class="category-btn" id="highlightsTab">Highlights</button>
            </div>
            
            <div class="status-list">
                <div class="recent-updates">
                    <div class="section-title">My Status</div>
                    <div class="my-status-item" id="myStatusItem">
                        <div class="my-status-avatar" id="myStatusAvatar">
                            <i class="fas fa-user"></i>
                            <div class="add-status-indicator">
                                <i class="fas fa-plus"></i>
                            </div>
                        </div>
                        <div class="my-status-info">
                            <div class="my-status-title">My Status</div>
                            <div class="my-status-desc">Tap to add status update</div>
                        </div>
                        <div class="status-options" id="myStatusOptions" style="display: none;">
                            <button class="status-option-btn" id="deleteMyStatusBtn" title="Delete my status">
                                <i class="fas fa-trash"></i>
                            </button>
                            <button class="status-option-btn" id="archiveMyStatusBtn" title="Archive my status">
                                <i class="fas fa-archive"></i>
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="contacts-status-list">
                    <div class="section-title" id="sectionTitle">Recent Updates</div>
                    <div id="recentStatusList">
                        <!-- Statuses will be loaded instantly from cache -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Status Viewer (Full Screen) -->
        <div class="status-viewer" id="statusViewer">
            <div class="swipe-zone swipe-left" id="swipeLeft"></div>
            <div class="swipe-zone swipe-right" id="swipeRight"></div>
            
            <div class="pause-overlay" id="pauseOverlay">
                <i class="fas fa-pause pause-icon"></i>
            </div>
            
            <div class="status-progress-container" id="statusProgressContainer">
                <!-- Progress bars will be added dynamically -->
            </div>
            
            <div class="status-header">
                <div class="status-user-info" id="statusUserInfo">
                    <div class="status-user-avatar">
                        <i class="fas fa-user"></i>
                    </div>
                    <div class="status-user-details">
                        <h4 id="statusUserName">User Name</h4>
                        <p id="statusTime">Just now</p>
                    </div>
                </div>
                <div>
                    <button class="highlight-btn" id="highlightStatusBtn" style="display: none;">
                        <i class="fas fa-star"></i> Highlight
                    </button>
                    <button class="status-close-btn" id="closeStatusViewer">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            
            <div class="status-content" id="statusContent">
                <!-- Status content will be loaded here -->
            </div>
            
            <!-- Poll Display -->
            <div class="poll-display" id="pollDisplay" style="display: none;">
                <!-- Poll will be displayed here -->
            </div>
            
            <!-- Question Display -->
            <div class="question-display" id="questionDisplay" style="display: none;">
                <!-- Question will be displayed here -->
            </div>
            
            <!-- Music Display -->
            <div class="music-display" id="musicDisplay" style="display: none;">
                <!-- Music will be displayed here -->
            </div>
            
            <div class="emoji-reactions" id="emojiReactions">
                <div class="emoji-reaction" data-emoji=""></div>
                <div class="emoji-reaction" data-emoji=""></div>
                <div class="emoji-reaction" data-emoji=""></div>
                <div class="emoji-reaction" data-emoji=""></div>
                <div class="emoji-reaction" data-emoji=""></div>
            </div>
            
            <div class="status-footer">
                <input type="text" class="status-reply-input" id="statusReplyInput" placeholder="Type a reply...">
                <button class="status-action-btn" id="statusReplyBtn">
                    <i class="fas fa-paper-plane"></i>
                </button>
                <button class="status-action-btn" id="shareStatusBtn" title="Share Status">
                    <i class="fas fa-share"></i>
                </button>
                <button class="status-action-btn" id="muteUserBtn" title="Mute User">
                    <i class="fas fa-volume-mute"></i>
                </button>
                <button class="status-action-btn" id="statusInfoBtn" title="View Info">
                    <i class="fas fa-info-circle"></i>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Create Status Modal -->
    <div class="create-status-modal" id="createStatusModal">
        <div class="create-status-container">
            <div class="create-status-header">
                <h3>Create Status Update</h3>
                <button class="create-status-close" id="closeCreateStatusModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="create-status-tabs">
                <button class="create-status-tab active" data-type="text">Text</button>
                <button class="create-status-tab" data-type="emoji">Emoji</button>
                <button class="create-status-tab" data-type="photo">Photo</button>
                <button class="create-status-tab" data-type="video">Video</button>
                <button class="create-status-tab" data-type="voice">Voice</button>
                <button class="create-status-tab" data-type="poll">Poll</button>
                <button class="create-status-tab" data-type="question">Question</button>
                <button class="create-status-tab" data-type="music">Music</button>
                <button class="create-status-tab" data-type="group">Group</button>
            </div>
            
            <div class="create-status-content">
                <!-- All status type containers will be added dynamically -->
                <div id="statusTypeContainers"></div>
                
                <!-- AI Suggestions -->
                <div class="ai-suggestions" id="aiSuggestions" style="display: none;">
                    <h4>AI Suggestions</h4>
                    <div class="ai-suggestion" data-suggestion="Great day! ">Great day! </div>
                    <div class="ai-suggestion" data-suggestion="Feeling blessed ">Feeling blessed </div>
                    <div class="ai-suggestion" data-suggestion="What a view! ">What a view! </div>
                </div>
                
                <!-- Offline Posting Indicator -->
                <div class="offline-cache-info" id="offlinePostingIndicator" style="display: none;">
                    <i class="fas fa-wifi-slash"></i> You're offline. Status will be queued for upload when you're back online.
                </div>
            </div>
            
            <div class="create-status-footer">
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <div class="privacy-selector">
                        <button class="privacy-btn" id="privacyBtn">
                            <i class="fas fa-users"></i>
                            <span id="privacyText">My Contacts</span>
                        </button>
                    </div>
                    <div class="duration-selector" id="durationSelector" style="display: none;">
                        <button class="duration-btn" data-hours="24">24h</button>
                        <button class="duration-btn" data-hours="48">48h</button>
                        <button class="duration-btn active" data-hours="72">72h</button>
                    </div>
                    <div class="schedule-container" id="scheduleContainer" style="display: none;">
                        <label>Schedule:</label>
                        <input type="datetime-local" class="schedule-input" id="scheduleInput">
                    </div>
                </div>
                <div>
                    <button class="text-tool-btn" id="cancelStatusBtn">Cancel</button>
                    <button class="text-tool-btn" id="postStatusBtn" style="background-color: var(--primary-color); color: white;">Post Status</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Video Trimmer -->
    <div class="video-trimmer-container" id="videoTrimmerContainer">
        <div class="video-trimmer-preview">
            <video id="trimVideoPreview" controls style="max-width: 100%; max-height: 100%;"></video>
        </div>
        <div class="trim-controls">
            <button class="text-tool-btn" id="cancelTrimBtn">Cancel</button>
            <div class="trim-time" id="trimTime">0:00 / 0:00</div>
            <input type="range" class="trim-range" id="trimRange" min="0" max="100" value="0">
            <button class="text-tool-btn" id="saveTrimBtn" style="background-color: var(--primary-color); color: white;">Save</button>
        </div>
    </div>
    
    <!-- Drawing Canvas -->
    <div class="drawing-canvas-container" id="drawingCanvasContainer">
        <canvas class="drawing-canvas" id="drawingCanvas"></canvas>
        <div class="drawing-tools">
            <div class="drawing-colors" id="drawingColors"></div>
            <div class="drawing-brushes" id="drawingBrushes"></div>
            <div>
                <button class="text-tool-btn" id="clearDrawingBtn">Clear</button>
                <button class="text-tool-btn" id="saveDrawingBtn" style="background-color: var(--primary-color); color: white;">Done</button>
            </div>
        </div>
    </div>
    
    <!-- Privacy Settings Modal -->
    <div class="privacy-modal" id="privacyModal">
        <div class="privacy-modal-content">
            <div class="privacy-modal-header">
                <h3>Status Privacy</h3>
            </div>
            <div class="privacy-options">
                <div class="privacy-option active" data-privacy="contacts">
                    <div class="privacy-option-icon">
                        <i class="fas fa-users"></i>
                    </div>
                    <div class="privacy-option-info">
                        <div class="privacy-option-title">My Contacts</div>
                        <div class="privacy-option-desc">All your contacts can see your status</div>
                    </div>
                    <div class="privacy-option-check">
                        <i class="fas fa-check"></i>
                    </div>
                </div>
                
                <div class="privacy-option" data-privacy="contacts-except">
                    <div class="privacy-option-icon">
                        <i class="fas fa-user-minus"></i>
                    </div>
                    <div class="privacy-option-info">
                        <div class="privacy-option-title">My Contacts Except...</div>
                        <div class="privacy-option-desc">Exclude specific contacts</div>
                    </div>
                    <div class="privacy-option-check">
                        <i class="fas fa-check"></i>
                    </div>
                </div>
                
                <div class="privacy-option" data-privacy="only-share">
                    <div class="privacy-option-icon">
                        <i class="fas fa-user-check"></i>
                    </div>
                    <div class="privacy-option-info">
                        <div class="privacy-option-title">Only Share With...</div>
                        <div class="privacy-option-desc">Share with selected contacts only</div>
                    </div>
                    <div class="privacy-option-check">
                        <i class="fas fa-check"></i>
                    </div>
                </div>
                
                <div class="privacy-option" data-privacy="public">
                    <div class="privacy-option-icon">
                        <i class="fas fa-globe"></i>
                    </div>
                    <div class="privacy-option-info">
                        <div class="privacy-option-title">Public</div>
                        <div class="privacy-option-desc">Anyone can see your status</div>
                    </div>
                    <div class="privacy-option-check">
                        <i class="fas fa-check"></i>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Status Info Modal -->
    <div class="status-info-modal" id="statusInfoModal">
        <div class="status-info-content">
            <div class="status-info-header">
                <h3>Status Info</h3>
                <button class="create-status-close" id="closeStatusInfoModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="viewers-list" id="viewersList">
                <!-- Viewers will be listed here -->
            </div>
            <div class="status-info-actions" id="statusInfoActions" style="padding: 20px; border-top: 1px solid var(--border-color); display: none;">
                <button class="chat-user-btn" id="chatUserBtn">
                    <i class="fas fa-comment"></i> Chat with User
                </button>
                <button class="share-status-btn" id="shareStatusInfoBtn" style="margin-top: 10px;">
                    <i class="fas fa-share"></i> Share This Status
                </button>
                <button class="share-status-btn" id="muteStatusUserBtn" style="margin-top: 10px; background-color: var(--warning-color);">
                    <i class="fas fa-volume-mute"></i> Mute User's Status
                </button>
            </div>
            <div class="status-info-actions" id="ownStatusActions" style="padding: 20px; border-top: 1px solid var(--border-color); display: none;">
                <button class="chat-user-btn" id="deleteStatusBtn" style="background-color: var(--danger-color);">
                    <i class="fas fa-trash"></i> Delete Status
                </button>
                <button class="chat-user-btn" id="editStatusBtn" style="margin-top: 10px; background-color: var(--primary-color);">
                    <i class="fas fa-edit"></i> Edit Status
                </button>
                <button class="chat-user-btn" id="highlightStatusActionBtn" style="margin-top: 10px; background-color: #FFD700; color: #000;">
                    <i class="fas fa-star"></i> Add to Highlights
                </button>
                <button class="chat-user-btn" id="pinStatusBtn" style="margin-top: 10px; background-color: var(--success-color);">
                    <i class="fas fa-thumbtack"></i> Pin Status
                </button>
            </div>
        </div>
    </div>
    
    <!-- Screenshot Detection Overlay -->
    <div class="screenshot-overlay" id="screenshotOverlay">
        <div class="screenshot-message">
            <h3>Screenshot Detected!</h3>
            <p>You took a screenshot of this status.</p>
            <p style="color: var(--danger-color); font-size: 12px; margin-top: 10px;">
                Note: The status owner will be notified about this screenshot.
            </p>
            <button class="text-tool-btn" id="closeScreenshotOverlay" style="margin-top: 20px;">
                OK
            </button>
        </div>
    </div>
    
    <!-- Notification -->
    <div class="notification" id="notification">
        <i class="fas fa-check-circle"></i>
        <span id="notificationText">Operation completed successfully</span>
    </div>
    
    <!-- Settings Manager -->
    <script type="module">
        import { initializeSettings } from './js/settingsManager.js';
        
        // Initialize settings on page load
        document.addEventListener('DOMContentLoaded', () => {
            initializeSettings();
        });
    </script>
    
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDHHyGgsSV18BcXrGgzi4C8frzDAE1C1zo",
            authDomain: "uniconnect-ee95c.firebaseapp.com",
            projectId: "uniconnect-ee95c",
            storageBucket: "uniconnect-ee95c.firebasestorage.app",
            messagingSenderId: "1003264444309",
            appId: "1:1003264444309:web:9f0307516e44d21e97d89c"
        };
        
        // Cloudinary Configuration
        const CLOUDINARY_CLOUD_NAME = 'dhjnxa5rh';
        const CLOUDINARY_API_KEY = '817591969559894';
        const CLOUDINARY_UPLOAD_PRESET = 'status_uploads';
        
        // Initialize Firebase
        try {
            if (!firebase.apps.length) {
                firebase.initializeApp(firebaseConfig);
            }
        } catch (error) {
            console.log('Firebase already initialized');
        }
        
        const db = firebase.firestore();
        const auth = firebase.auth();
        const storage = firebase.storage();
        
        // Global variables
        let currentUser = null;
        let currentStatusIndex = 0;
        let currentStatusUser = null;
        let userStatuses = [];
        let statusInterval = null;
        let currentMediaType = null;
        let currentMediaFile = null;
        let canvas = null;
        let fabricCanvas = null;
        let selectedPrivacy = 'contacts';
        let allStatuses = [];
        let viewedStatuses = [];
        let mutedUsers = [];
        let archivedStatuses = [];
        let highlightedStatuses = [];
        let currentCategory = 'recent';
        let selectedStatusType = 'text';
        let selectedEmoji = '';
        let currentStatusId = null;
        let screenshotDetected = false;
        let userMood = null;
        let wavesurfer = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingTime = 0;
        let recordingTimer = null;
        let selectedDuration = 24; // STATUSES NOW EXPIRE AFTER 24 HOURS
        let scheduledTime = null;
        let selectedGroup = null;
        let isPaused = false;
        let touchStartX = 0;
        let touchEndX = 0;
        
        // OFFLINE SUPPORT VARIABLES
        let isOnline = navigator.onLine;
        let cachedStatuses = [];
        let pendingUploads = [];
        let isSyncing = false;
        let isInitialLoadComplete = false;
        let backgroundSyncInterval = null;
        let realTimeListener = null;
        
        // Color palettes
        const textColors = [
            '#ffffff', '#000000', '#0084ff', '#34c759', '#ff3b30',
            '#ff9500', '#5856d6', '#af52de', '#ff2d55', '#007aff'
        ];
        
        const backgroundColors = [
            '#0084ff', '#34c759', '#ff3b30', '#ff9500', '#5856d6',
            '#af52de', '#ff2d55', '#5ac8fa', '#4cd964', '#ffcc00'
        ];
        
        const fonts = [
            { name: 'Default', value: 'Segoe UI, sans-serif' },
            { name: 'Serif', value: 'Georgia, serif' },
            { name: 'Monospace', value: 'Courier New, monospace' },
            { name: 'Cursive', value: 'cursive' },
            { name: 'Impact', value: 'Impact, sans-serif' }
        ];
        
        // Drawing colors
        const drawingColors = [
            '#000000', '#ffffff', '#ff3b30', '#ff9500', '#ffcc00',
            '#34c759', '#0084ff', '#5856d6', '#af52de', '#ff2d55'
        ];
        
        // Drawing brush sizes
        const brushSizes = [2, 5, 10, 15, 20];
        
        // Poll options
        let pollOptions = ['', ''];
        
        // Music tracks (demo)
        const musicTracks = [
            { id: 1, title: 'Chill Vibes', artist: 'LoFi Beats', duration: '3:45' },
            { id: 2, title: 'Summer Energy', artist: 'Pop Mix', duration: '2:30' },
            { id: 3, title: 'Focus Mode', artist: 'Study Beats', duration: '4:15' },
            { id: 4, title: 'Workout Pump', artist: 'Energy Mix', duration: '3:20' }
        ];
        
        // Groups (demo)
        let userGroups = [];
        
        // DOM Elements
        const statusViewer = document.getElementById('statusViewer');
        const createStatusModal = document.getElementById('createStatusModal');
        const privacyModal = document.getElementById('privacyModal');
        const statusInfoModal = document.getElementById('statusInfoModal');
        const drawingCanvasContainer = document.getElementById('drawingCanvasContainer');
        const videoTrimmerContainer = document.getElementById('videoTrimmerContainer');
        const notification = document.getElementById('notification');
        const screenshotOverlay = document.getElementById('screenshotOverlay');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const offlineIndicator = document.getElementById('offlineIndicator');
        const offlinePostingIndicator = document.getElementById('offlinePostingIndicator');
        
        // ============================================
        // CORE FUNCTIONS - Optimized for instant loading
        // ============================================
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // INSTANT LOAD: Show cached data immediately
            instantLoadFromCache();
            
            // Load current user from app.js or localStorage
            loadCurrentUser();
            loadUserMood();
            
            // Initialize app in background
            setTimeout(() => {
                initializeApp();
            }, 100);
            
            setupEventListeners();
            initializeStatusTypeContainers();
            initializeColorPalettes();
            initializeFontOptions();
            initializeDrawingTools();
            initializeEmojiPicker();
            setupScreenshotDetection();
            setupTouchGestures();
            setupOfflineSupport();
        });

        // INSTANT LOAD FUNCTION - Shows cached data immediately
        function instantLoadFromCache() {
            try {
                // Try to load user from localStorage first
                const userData = localStorage.getItem('currentUser');
                if (userData) {
                    const user = JSON.parse(userData);
                    if (user && user.uid) {
                        // Load cached statuses
                        loadCachedStatuses();
                        
                        // Update UI with cached data immediately
                        if (cachedStatuses.length > 0) {
                            updateStatusListWithCache();
                        }
                        
                        // Update my status avatar
                        const myStatusAvatar = document.getElementById('myStatusAvatar');
                        const userInitials = user.displayName ? 
                            user.displayName.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2) : 
                            'ME';
                        
                        if (user.photoURL) {
                            myStatusAvatar.style.backgroundImage = `url('${user.photoURL}')`;
                            myStatusAvatar.innerHTML = '';
                        } else {
                            myStatusAvatar.innerHTML = `<span>${userInitials}<\/span>`;
                        }
                    }
                }
                
                // Remove any loading placeholders
                const loadingPlaceholders = document.querySelectorAll('.loading-placeholder');
                loadingPlaceholders.forEach(el => el.style.display = 'none');
                
            } catch (error) {
                console.error('Error in instant load:', error);
            }
        }
        
        // Load current user from app.js data
        function loadCurrentUser() {
            try {
                // Check if user data is available from app.js
                if (typeof window.currentUser !== 'undefined' && window.currentUser) {
                    currentUser = window.currentUser;
                    console.log('User loaded from app.js:', currentUser.uid);
                } else {
                    // Fallback to localStorage
                    const userData = localStorage.getItem('currentUser');
                    if (userData) {
                        currentUser = JSON.parse(userData);
                        console.log('User loaded from localStorage:', currentUser.uid);
                    } else {
                        // Check Firebase auth state
                        auth.onAuthStateChanged(user => {
                            if (user) {
                                currentUser = user;
                                localStorage.setItem('currentUser', JSON.stringify({
                                    uid: user.uid,
                                    displayName: user.displayName,
                                    photoURL: user.photoURL,
                                    email: user.email
                                }));
                                console.log('User loaded from Firebase auth:', user.uid);
                                
                                // Now that we have user, load cached data
                                loadCachedStatuses();
                                updateStatusListWithCache();
                            } else {
                                console.log('No user found, redirecting to login');
                                window.location.href = 'index.html';
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error loading current user:', error);
            }
        }
        
        // Load user mood only (theme is handled by settingsManager.js)
        function loadUserMood() {
            try {
                // Load mood from localStorage
                const savedMood = localStorage.getItem('selectedMood');
                userMood = savedMood || 'happy';
            } catch (error) {
                console.error('Error loading user mood:', error);
                userMood = 'happy';
            }
        }
        
        // OFFLINE SUPPORT FUNCTIONS - Optimized
        function setupOfflineSupport() {
            // Listen for online/offline events
            window.addEventListener('online', handleOnlineStatusChange);
            window.addEventListener('offline', handleOnlineStatusChange);
            
            // Initial check
            handleOnlineStatusChange();
            
            // Load cached statuses if not already loaded
            if (cachedStatuses.length === 0) {
                loadCachedStatuses();
            }
            
            // Load pending uploads
            loadPendingUploads();
            
            // Start background sync interval
            startBackgroundSync();
            
            // Setup real-time listener if online
            if (isOnline && currentUser && currentUser.uid) {
                setupRealTimeListener();
            }
        }
        
        function handleOnlineStatusChange() {
            const wasOnline = isOnline;
            isOnline = navigator.onLine;
            
            if (isOnline && !wasOnline) {
                // Just came online
                offlineIndicator.classList.remove('active');
                showNotification('You are back online. Syncing in background...', 'success');
                
                // Process pending uploads in background
                setTimeout(() => {
                    processPendingUploads();
                }, 2000);
                
                // Start real-time listener
                setupRealTimeListener();
                
                // Load fresh data in background
                setTimeout(() => {
                    loadStatusUpdates();
                }, 1000);
                
            } else if (!isOnline && wasOnline) {
                // Just went offline
                offlineIndicator.classList.add('active');
                
                // Stop real-time listener
                stopRealTimeListener();
                
                // Show cached data
                updateStatusListWithCache();
            }
            
            // Update create status modal indicator
            if (offlinePostingIndicator) {
                offlinePostingIndicator.style.display = isOnline ? 'none' : 'block';
            }
        }
        
        function loadCachedStatuses() {
            try {
                if (!currentUser || !currentUser.uid) {
                    console.log('No user ID available for loading cached statuses');
                    cachedStatuses = [];
                    return;
                }
                
                const cachedData = localStorage.getItem(`cachedStatuses_${currentUser.uid}`);
                if (cachedData) {
                    cachedStatuses = JSON.parse(cachedData);
                    
                    // Filter out expired statuses (24 hours)
                    const now = new Date();
                    cachedStatuses = cachedStatuses.filter(status => {
                        if (!status.expiresAt) return true;
                        const expiresAt = new Date(status.expiresAt);
                        return expiresAt > now;
                    });
                    
                    // Save filtered cache back
                    localStorage.setItem(`cachedStatuses_${currentUser.uid}`, JSON.stringify(cachedStatuses));
                    
                    console.log(`Loaded ${cachedStatuses.length} cached statuses`);
                } else {
                    cachedStatuses = [];
                }
            } catch (error) {
                console.error('Error loading cached statuses:', error);
                cachedStatuses = [];
            }
        }
        
        function saveStatusToCache(status) {
            try {
                if (!currentUser || !currentUser.uid) {
                    console.log('No user ID available for saving cache');
                    return;
                }
                
                // Check if status already exists in cache
                const existingIndex = cachedStatuses.findIndex(s => 
                    s.id === status.id || 
                    s.tempId === status.tempId ||
                    (s.content === status.content && s.userId === status.userId && s.type === status.type)
                );
                
                if (existingIndex !== -1) {
                    // Update existing cache entry
                    cachedStatuses[existingIndex] = status;
                } else {
                    // Add to cache
                    cachedStatuses.unshift(status);
                }
                
                // Keep only last 100 statuses in cache
                if (cachedStatuses.length > 100) {
                    cachedStatuses = cachedStatuses.slice(0, 100);
                }
                
                // Save to localStorage
                localStorage.setItem(`cachedStatuses_${currentUser.uid}`, JSON.stringify(cachedStatuses));
                
                // Update UI with cached status if offline
                if (!isOnline) {
                    updateStatusListWithCache();
                }
                
            } catch (error) {
                console.error('Error saving status to cache:', error);
            }
        }
        
        function updateStatusListWithCache() {
            const recentStatusList = document.getElementById('recentStatusList');
            const sectionTitle = document.getElementById('sectionTitle');
            
            if (!recentStatusList || !sectionTitle) return;
            
            // Clear current list
            recentStatusList.innerHTML = '';
            
            // Combine cached statuses with online statuses
            const allCombinedStatuses = [...allStatuses, ...cachedStatuses];
            
            // Remove duplicates
            const uniqueStatuses = [];
            const seenIds = new Set();
            
            allCombinedStatuses.forEach(status => {
                const statusId = status.id || status.tempId;
                if (!seenIds.has(statusId)) {
                    seenIds.add(statusId);
                    uniqueStatuses.push(status);
                }
            });
            
            // Sort by date (newest first)
            uniqueStatuses.sort((a, b) => {
                const dateA = a.createdAt ? new Date(a.createdAt) : new Date();
                const dateB = b.createdAt ? new Date(b.createdAt) : new Date();
                return dateB - dateA;
            });
            
            // Filter statuses based on current category
            let filteredStatuses = filterStatusesByCategory(uniqueStatuses);
            
            // Group by user (except for archive and highlights)
            const statusesByUser = groupStatusesByUser(filteredStatuses);
            
            // Add status items
            Object.keys(statusesByUser).forEach(userKey => {
                const userStatuses = statusesByUser[userKey];
                const latestStatus = userStatuses[0];
                const userStatusCount = userStatuses.length;
                
                const statusItem = createStatusItem(latestStatus, userStatusCount);
                recentStatusList.appendChild(statusItem);
            });
            
            // Show empty state if no statuses
            if (Object.keys(statusesByUser).length === 0) {
                showEmptyState(recentStatusList);
            }
            
            // Show cache info if offline and have cached statuses
            if (!isOnline && cachedStatuses.length > 0) {
                showCacheInfo(recentStatusList);
            }
        }
        
        function filterStatusesByCategory(statuses) {
            let filteredStatuses = [];
            const now = new Date();
            
            switch(currentCategory) {
                case 'recent':
                    filteredStatuses = statuses.filter(status => 
                        !viewedStatuses.includes(status.id || status.tempId) && 
                        !mutedUsers.includes(status.userId) &&
                        (!status.expiresAt || new Date(status.expiresAt) > now)
                    );
                    break;
                    
                case 'viewed':
                    filteredStatuses = statuses.filter(status => 
                        viewedStatuses.includes(status.id || status.tempId) &&
                        !mutedUsers.includes(status.userId) &&
                        (!status.expiresAt || new Date(status.expiresAt) > now)
                    );
                    break;
                    
                case 'muted':
                    filteredStatuses = statuses.filter(status => 
                        mutedUsers.includes(status.userId) &&
                        (!status.expiresAt || new Date(status.expiresAt) > now)
                    );
                    break;
                    
                case 'archive':
                    filteredStatuses = archivedStatuses;
                    break;
                    
                case 'highlights':
                    filteredStatuses = highlightedStatuses.filter(status => 
                        (!status.expiresAt || new Date(status.expiresAt) > now)
                    );
                    break;
            }
            
            return filteredStatuses;
        }
        
        function groupStatusesByUser(statuses) {
            const statusesByUser = {};
            const showArchived = currentCategory === 'archive';
            const isHighlights = currentCategory === 'highlights';
            
            if (!showArchived && !isHighlights) {
                // Group by user for normal categories
                statuses.forEach(status => {
                    if (!statusesByUser[status.userId]) {
                        statusesByUser[status.userId] = [];
                    }
                    statusesByUser[status.userId].push(status);
                });
            } else {
                // For archive and highlights, show individual statuses
                statuses.forEach((status, index) => {
                    statusesByUser[`status_${index}`] = [status];
                });
            }
            
            return statusesByUser;
        }
        
        function createStatusItem(status, count) {
            const timeAgo = getTimeAgo(status.createdAt);
            const initials = status.userName ? 
                status.userName.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2) : 
                'U';
            
            const isViewed = viewedStatuses.includes(status.id || status.tempId) || status.userId === currentUser?.uid;
            const ringColor = isViewed ? 'viewed' : '';
            const isCached = status.tempId || status.isCached;
            const isPending = status.isPending;
            const isArchived = currentCategory === 'archive';
            
            const statusItem = document.createElement('div');
            statusItem.className = 'contact-status-item has-status status-item-enter';
            if (isArchived) statusItem.classList.add('archived-status');
            statusItem.dataset.statusId = status.id || status.tempId;
            statusItem.dataset.userId = status.userId;
            statusItem.dataset.userName = status.userName || 'User';
            
            setTimeout(() => {
                statusItem.classList.add('status-item-enter-active');
            }, 10);
            
            statusItem.innerHTML = `
                <div class="contact-status-avatar" ${status.userAvatar ? `style="background-image: url('${status.userAvatar}')"` : ''}>
                    <div class="status-ring ${ringColor}"><\/div>
                    ${status.userAvatar ? '' : `<span>${initials}<\/span>`}
                    ${isPending ? '<div class="pending-upload-indicator" title="Pending upload"><i class="fas fa-clock"><\/i><\/div>' : ''}
                <\/div>
                <div class="contact-status-info">
                    <div class="contact-status-name">${status.userName || 'User'} 
                        ${isCached ? '<span class="offline-status-tag">Offline<\/span>' : ''}
                        ${isPending ? '<span class="offline-status-tag">Pending<\/span>' : ''}
                    <\/div>
                    <div class="contact-status-time">${timeAgo}<\/div>
                    ${status.type === 'poll' ? '<span style="color: var(--primary-color); font-size: 12px;"> Poll<\/span>' : ''}
                    ${status.type === 'question' ? '<span style="color: var(--success-color); font-size: 12px;"> Question<\/span>' : ''}
                    ${status.type === 'music' ? '<span style="color: var(--warning-color); font-size: 12px;"> Music<\/span>' : ''}
                    ${status.type === 'voice' ? '<span style="color: var(--danger-color); font-size: 12px;"> Voice<\/span>' : ''}
                <\/div>
                ${isArchived ? '<button class="restore-btn">Restore<\/button>' : `<div class="contact-status-count">${count}<\/div>`}
            `;
            
            // Add event listeners
            addStatusItemEventListeners(statusItem, status, count);
            
            return statusItem;
        }
        
        function addStatusItemEventListeners(statusItem, status, count) {
            const isArchived = currentCategory === 'archive';
            
            statusItem.addEventListener('click', (e) => {
                if (!e.target.classList.contains('restore-btn') && !e.target.classList.contains('retry-upload-btn')) {
                    if (isArchived) {
                        openStatusViewer(status.userId, [status]);
                    } else {
                        // Get all statuses for this user
                        const userStatuses = getAllStatusesForUser(status.userId);
                        openStatusViewer(status.userId, userStatuses);
                    }
                }
            });
            
            // Add retry button for pending uploads
            if (status.isPending && isOnline) {
                const retryBtn = document.createElement('button');
                retryBtn.className = 'retry-upload-btn';
                retryBtn.textContent = 'Retry';
                retryBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    retryPendingUpload(status.tempId);
                });
                statusItem.querySelector('.contact-status-info').appendChild(retryBtn);
            }
            
            // Add restore button functionality for archived statuses
            if (isArchived) {
                const restoreBtn = statusItem.querySelector('.restore-btn');
                restoreBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    restoreStatusFromArchive(status.id || status.tempId);
                });
            }
        }
        
        function getAllStatusesForUser(userId) {
            return [...allStatuses, ...cachedStatuses].filter(status => 
                status.userId === userId &&
                (!status.expiresAt || new Date(status.expiresAt) > new Date())
            ).sort((a, b) => {
                const dateA = a.createdAt ? new Date(a.createdAt) : new Date();
                const dateB = b.createdAt ? new Date(b.createdAt) : new Date();
                return dateB - dateA;
            });
        }
        
        function showEmptyState(container) {
            let emptyMessage = '';
            switch(currentCategory) {
                case 'recent':
                    emptyMessage = isOnline ? 'No recent status updates' : 'No cached status updates';
                    break;
                case 'viewed':
                    emptyMessage = 'No viewed status updates';
                    break;
                case 'muted':
                    emptyMessage = 'No muted users';
                    break;
                case 'archive':
                    emptyMessage = 'No archived statuses';
                    break;
                case 'highlights':
                    emptyMessage = 'No highlighted statuses';
                    break;
            }
            
            container.innerHTML = `
                <div style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
                    <i class="fas fa-comment" style="font-size: 48px; margin-bottom: 15px; opacity: 0.5;"><\/i>
                    <p>${emptyMessage}<\/p>
                    ${!isOnline ? '<p style="font-size: 14px; margin-top: 10px;">Connect to the internet to see new updates<\/p>' : ''}
                <\/div>
            `;
        }
        
        function showCacheInfo(container) {
            const cacheInfo = document.createElement('div');
            cacheInfo.className = 'offline-cache-info';
            cacheInfo.innerHTML = `<i class="fas fa-database"><\/i> Showing ${cachedStatuses.length} cached status updates`;
            container.insertBefore(cacheInfo, container.firstChild);
        }
        
        function loadPendingUploads() {
            try {
                if (!currentUser || !currentUser.uid) {
                    console.log('No user ID available for loading pending uploads');
                    pendingUploads = [];
                    return;
                }
                
                const pendingData = localStorage.getItem(`pendingUploads_${currentUser.uid}`);
                if (pendingData) {
                    pendingUploads = JSON.parse(pendingData);
                    console.log(`Loaded ${pendingUploads.length} pending uploads`);
                } else {
                    pendingUploads = [];
                }
            } catch (error) {
                console.error('Error loading pending uploads:', error);
                pendingUploads = [];
            }
        }
        
        function savePendingUpload(statusData) {
            try {
                if (!currentUser || !currentUser.uid) {
                    console.log('No user ID available for saving pending upload');
                    return null;
                }
                
                // Generate a temporary ID for offline status
                const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                statusData.tempId = tempId;
                statusData.isPending = true;
                statusData.createdAt = new Date().toISOString();
                
                // Add to pending uploads
                pendingUploads.push(statusData);
                
                // Save to localStorage
                localStorage.setItem(`pendingUploads_${currentUser.uid}`, JSON.stringify(pendingUploads));
                
                // Also save to cache for immediate viewing
                saveStatusToCache({
                    ...statusData,
                    isCached: true,
                    userId: currentUser.uid,
                    userName: currentUser.displayName || 'User',
                    userAvatar: currentUser.photoURL || ''
                });
                
                console.log(`Saved pending upload with tempId: ${tempId}`);
                
                return tempId;
            } catch (error) {
                console.error('Error saving pending upload:', error);
                return null;
            }
        }
        
        async function processPendingUploads() {
            if (isSyncing || pendingUploads.length === 0 || !isOnline) return;
            
            isSyncing = true;
            
            // Process each pending upload
            for (let i = 0; i < pendingUploads.length; i++) {
                const pendingStatus = pendingUploads[i];
                
                try {
                    // Upload media files if needed
                    let mediaUrl = pendingStatus.content;
                    
                    if (pendingStatus.type === 'photo' || pendingStatus.type === 'video' || pendingStatus.type === 'voice') {
                        if (pendingStatus.content && pendingStatus.content.startsWith('data:')) {
                            const response = await fetch(pendingStatus.content);
                            const blob = await response.blob();
                            const file = new File([blob], `status_${Date.now()}.${pendingStatus.type === 'photo' ? 'jpg' : pendingStatus.type === 'video' ? 'mp4' : 'wav'}`, {
                                type: blob.type
                            });
                            
                            mediaUrl = await uploadToCloudinary(file);
                        }
                    }
                    
                    // Prepare status data for Firestore - STATUSES EXPIRE AFTER 24 HOURS
                    const statusData = {
                        ...pendingStatus,
                        content: mediaUrl,
                        userId: currentUser.uid,
                        userName: currentUser.displayName || 'User',
                        userAvatar: currentUser.photoURL || '',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        expiresAt: new Date(Date.now() + (24 * 60 * 60 * 1000)), // 24 hours
                        viewers: [],
                        reactions: {},
                        pollVotes: {},
                        answers: [],
                        screenshotNotifications: [],
                        mood: userMood || 'happy'
                    };
                    
                    // Remove temporary fields
                    delete statusData.tempId;
                    delete statusData.isPending;
                    delete statusData.isCached;
                    
                    // Save to Firestore
                    await db.collection('statuses').add(statusData);
                    
                    // Remove from pending uploads
                    removePendingUpload(pendingStatus.tempId);
                    
                } catch (error) {
                    console.error(`Error uploading pending status ${pendingStatus.tempId}:`, error);
                }
            }
            
            isSyncing = false;
            
            // Reload statuses in background
            setTimeout(() => {
                loadStatusUpdates();
            }, 1000);
        }
        
        function retryPendingUpload(tempId) {
            if (!isOnline) {
                showNotification('Cannot retry upload while offline', 'error');
                return;
            }
            
            // Find the pending upload
            const pendingUpload = pendingUploads.find(upload => upload.tempId === tempId);
            if (pendingUpload) {
                processSinglePendingUpload(pendingUpload);
            }
        }
        
        async function processSinglePendingUpload(pendingStatus) {
            try {
                // Upload media files if needed
                let mediaUrl = pendingStatus.content;
                
                if (pendingStatus.type === 'photo' || pendingStatus.type === 'video' || pendingStatus.type === 'voice') {
                    if (pendingStatus.content && pendingStatus.content.startsWith('data:')) {
                        const response = await fetch(pendingStatus.content);
                        const blob = await response.blob();
                        const file = new File([blob], `status_${Date.now()}.${pendingStatus.type === 'photo' ? 'jpg' : pendingStatus.type === 'video' ? 'mp4' : 'wav'}`, {
                            type: blob.type
                        });
                        
                        mediaUrl = await uploadToCloudinary(file);
                    }
                }
                
                // Prepare status data for Firestore - STATUSES EXPIRE AFTER 24 HOURS
                const statusData = {
                    ...pendingStatus,
                    content: mediaUrl,
                    userId: currentUser.uid,
                    userName: currentUser.displayName || 'User',
                    userAvatar: currentUser.photoURL || '',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    expiresAt: new Date(Date.now() + (24 * 60 * 60 * 1000)), // 24 hours
                    viewers: [],
                    reactions: {},
                    pollVotes: {},
                    answers: [],
                    screenshotNotifications: [],
                    mood: userMood || 'happy'
                };
                
                // Remove temporary fields
                delete statusData.tempId;
                delete statusData.isPending;
                delete statusData.isCached;
                
                // Save to Firestore
                await db.collection('statuses').add(statusData);
                
                // Remove from pending uploads
                removePendingUpload(pendingStatus.tempId);
                
                showNotification('Status uploaded successfully!', 'success');
                
                // Reload statuses in background
                setTimeout(() => {
                    loadStatusUpdates();
                }, 500);
                
            } catch (error) {
                console.error('Error retrying upload:', error);
                showNotification('Failed to upload. Will retry later.', 'error');
            }
        }
        
        function removePendingUpload(tempId) {
            try {
                if (!currentUser || !currentUser.uid) {
                    console.log('No user ID available for removing pending upload');
                    return;
                }
                
                pendingUploads = pendingUploads.filter(upload => upload.tempId !== tempId);
                localStorage.setItem(`pendingUploads_${currentUser.uid}`, JSON.stringify(pendingUploads));
                
                // Also remove from cache
                cachedStatuses = cachedStatuses.filter(status => status.tempId !== tempId);
                localStorage.setItem(`cachedStatuses_${currentUser.uid}`, JSON.stringify(cachedStatuses));
                
                // Update UI
                updateStatusListWithCache();
                
            } catch (error) {
                console.error('Error removing pending upload:', error);
            }
        }
        
        function startBackgroundSync() {
            if (backgroundSyncInterval) {
                clearInterval(backgroundSyncInterval);
            }
            
            // Sync every 30 seconds when online
            backgroundSyncInterval = setInterval(() => {
                if (isOnline) {
                    syncOfflineData();
                }
            }, 30000);
        }
        
        function setupRealTimeListener() {
            if (!isOnline || !currentUser || !currentUser.uid) return;
            
            // Stop any existing listener
            stopRealTimeListener();
            
            const now = new Date();
            
            try {
                realTimeListener = db.collection('statuses')
                    .where('expiresAt', '>', now)
                    .orderBy('expiresAt', 'desc')
                    .limit(50)
                    .onSnapshot(snapshot => {
                        const changes = snapshot.docChanges();
                        
                        changes.forEach(change => {
                            if (change.type === 'added' || change.type === 'modified') {
                                const statusData = change.doc.data();
                                const status = {
                                    id: change.doc.id,
                                    ...statusData,
                                    createdAt: statusData.createdAt ? statusData.createdAt.toDate() : new Date(),
                                    expiresAt: statusData.expiresAt ? statusData.expiresAt.toDate() : new Date(now.getTime() + 24 * 60 * 60 * 1000)
                                };
                                
                                // Check if status is visible to user
                                if (isStatusVisible(status)) {
                                    // Update or add to allStatuses
                                    const existingIndex = allStatuses.findIndex(s => s.id === status.id);
                                    if (existingIndex !== -1) {
                                        allStatuses[existingIndex] = status;
                                    } else {
                                        allStatuses.push(status);
                                    }
                                    
                                    // Save to cache
                                    saveStatusToCache(status);
                                    
                                    // Update UI if not viewing status
                                    if (!statusViewer.classList.contains('active')) {
                                        updateStatusListWithCache();
                                    }
                                }
                            }
                        });
                        
                        // Sort allStatuses by date
                        allStatuses.sort((a, b) => {
                            const dateA = a.createdAt ? new Date(a.createdAt) : new Date();
                            const dateB = b.createdAt ? new Date(b.createdAt) : new Date();
                            return dateB - dateA;
                        });
                        
                    }, error => {
                        console.error('Real-time listener error:', error);
                    });
                    
            } catch (error) {
                console.error('Error setting up real-time listener:', error);
            }
        }
        
        function stopRealTimeListener() {
            if (realTimeListener) {
                realTimeListener();
                realTimeListener = null;
            }
        }
        
        async function syncOfflineData() {
            if (!isOnline) return;
            
            // Sync viewed statuses
            await syncViewedStatuses();
            
            // Sync reactions
            await syncOfflineReactions();
            
            // Sync poll votes
            await syncOfflinePollVotes();
            
            // Sync answers
            await syncOfflineAnswers();
        }
        
        async function syncViewedStatuses() {
            try {
                if (!currentUser || !currentUser.uid) return;
                
                const offlineViewed = localStorage.getItem(`offlineViewed_${currentUser.uid}`);
                if (!offlineViewed) return;
                
                const viewedStatuses = JSON.parse(offlineViewed);
                
                if (viewedStatuses.length === 0) return;
                
                // Sync each viewed status
                for (const statusId of viewedStatuses) {
                    try {
                        await db.collection('statuses')
                            .doc(statusId)
                            .update({
                                viewers: firebase.firestore.FieldValue.arrayUnion(currentUser.uid)
                            });
                    } catch (error) {
                        console.error(`Error syncing viewed status ${statusId}:`, error);
                    }
                }
                
                // Clear offline viewed cache
                localStorage.removeItem(`offlineViewed_${currentUser.uid}`);
                
            } catch (error) {
                console.error('Error syncing viewed statuses:', error);
            }
        }
        
        async function syncOfflineReactions() {
            try {
                if (!currentUser || !currentUser.uid) return;
                
                const offlineReactions = localStorage.getItem(`offlineReactions_${currentUser.uid}`);
                if (!offlineReactions) return;
                
                const reactions = JSON.parse(offlineReactions);
                
                for (const [statusId, emoji] of Object.entries(reactions)) {
                    try {
                        await db.collection('statuses')
                            .doc(statusId)
                            .update({
                                [`reactions.${currentUser.uid}`]: emoji
                            });
                    } catch (error) {
                        console.error(`Error syncing reaction for status ${statusId}:`, error);
                    }
                }
                
                localStorage.removeItem(`offlineReactions_${currentUser.uid}`);
                
            } catch (error) {
                console.error('Error syncing offline reactions:', error);
            }
        }
        
        async function syncOfflinePollVotes() {
            try {
                if (!currentUser || !currentUser.uid) return;
                
                const offlinePollVotes = localStorage.getItem(`offlinePollVotes_${currentUser.uid}`);
                if (!offlinePollVotes) return;
                
                const pollVotes = JSON.parse(offlinePollVotes);
                
                for (const [statusId, optionIndex] of Object.entries(pollVotes)) {
                    try {
                        await db.collection('statuses')
                            .doc(statusId)
                            .update({
                                [`pollVotes.${currentUser.uid}`]: optionIndex
                            });
                    } catch (error) {
                        console.error(`Error syncing poll vote for status ${statusId}:`, error);
                    }
                }
                
                localStorage.removeItem(`offlinePollVotes_${currentUser.uid}`);
                
            } catch (error) {
                console.error('Error syncing offline poll votes:', error);
            }
        }
        
        async function syncOfflineAnswers() {
            try {
                if (!currentUser || !currentUser.uid) return;
                
                const offlineAnswers = localStorage.getItem(`offlineAnswers_${currentUser.uid}`);
                if (!offlineAnswers) return;
                
                const answers = JSON.parse(offlineAnswers);
                
                for (const [statusId, answer] of Object.entries(answers)) {
                    try {
                        await db.collection('statuses')
                            .doc(statusId)
                            .update({
                                answers: firebase.firestore.FieldValue.arrayUnion({
                                    userId: currentUser.uid,
                                    userName: currentUser.displayName || 'User',
                                    answer: answer,
                                    timestamp: new Date()
                                })
                            });
                    } catch (error) {
                        console.error(`Error syncing answer for status ${statusId}:`, error);
                    }
                }
                
                localStorage.removeItem(`offlineAnswers_${currentUser.uid}`);
                
            } catch (error) {
                console.error('Error syncing offline answers:', error);
            }
        }
        
        // ============================================
        // STATUS MANAGEMENT FUNCTIONS
        // ============================================
        
        async function saveStatusToFirestore(statusData) {
            try {
                if (!isOnline) {
                    // Save to pending uploads for offline mode
                    const tempId = savePendingUpload(statusData);
                    showNotification('Status saved offline. Will upload when you\'re back online.', 'success');
                    
                    // Update UI immediately with cached version
                    updateStatusListWithCache();
                    
                    return tempId;
                }
                
                // Calculate expiration time - STATUSES EXPIRE AFTER 24 HOURS
                const expiresAt = new Date(Date.now() + (24 * 60 * 60 * 1000));
                
                // If scheduled, use scheduled time
                const createdAt = scheduledTime ? new Date(scheduledTime) : firebase.firestore.FieldValue.serverTimestamp();
                
                const statusRef = await db.collection('statuses').add({
                    ...statusData,
                    userId: currentUser.uid,
                    userName: currentUser.displayName || 'User',
                    userAvatar: currentUser.photoURL || '',
                    createdAt: createdAt,
                    expiresAt: expiresAt,
                    viewers: [],
                    reactions: {},
                    pollVotes: {},
                    answers: [],
                    screenshotNotifications: [],
                    mood: userMood || 'happy',
                    isHighlighted: false,
                    isPinned: false,
                    scheduled: !!scheduledTime
                });
                
                // Also cache the status locally
                saveStatusToCache({
                    ...statusData,
                    id: statusRef.id,
                    userId: currentUser.uid,
                    userName: currentUser.displayName || 'User',
                    userAvatar: currentUser.photoURL || '',
                    createdAt: new Date().toISOString(),
                    expiresAt: expiresAt.toISOString()
                });
                
                return statusRef.id;
            } catch (error) {
                console.error('Error saving status:', error);
                
                // If online but save failed, save to pending uploads
                if (isOnline) {
                    const tempId = savePendingUpload(statusData);
                    showNotification('Status queued for upload due to network error.', 'warning');
                    return tempId;
                }
                
                throw error;
            }
        }
        
        async function markStatusAsViewed(statusId) {
            try {
                if (!currentUser || !currentUser.uid) return;
                
                if (!viewedStatuses.includes(statusId)) {
                    viewedStatuses.push(statusId);
                    localStorage.setItem(`viewedStatuses_${currentUser.uid}`, JSON.stringify(viewedStatuses));
                    
                    if (isOnline) {
                        // Update in Firestore
                        try {
                            await db.collection('statuses')
                                .doc(statusId)
                                .update({
                                    viewers: firebase.firestore.FieldValue.arrayUnion(currentUser.uid)
                                });
                        } catch (error) {
                            console.log('Could not update viewers in Firestore:', error.message);
                            // Save for offline sync
                            const offlineViewed = JSON.parse(localStorage.getItem(`offlineViewed_${currentUser.uid}`) || '[]');
                            offlineViewed.push(statusId);
                            localStorage.setItem(`offlineViewed_${currentUser.uid}`, JSON.stringify(offlineViewed));
                        }
                    } else {
                        // Save for offline sync
                        const offlineViewed = JSON.parse(localStorage.getItem(`offlineViewed_${currentUser.uid}`) || '[]');
                        offlineViewed.push(statusId);
                        localStorage.setItem(`offlineViewed_${currentUser.uid}`, JSON.stringify(offlineViewed));
                    }
                    
                    // Update the status list
                    updateStatusListWithCache();
                }
            } catch (error) {
                console.error('Error marking status as viewed:', error);
            }
        }
        
        async function loadStatusUpdates() {
            try {
                if (!currentUser || !currentUser.uid) {
                    console.log('No user ID available for loading status updates');
                    updateStatusListWithCache();
                    return;
                }
                
                if (!isOnline) {
                    // Load from cache when offline
                    console.log('Offline mode: Using cached status updates');
                    updateStatusListWithCache();
                    return;
                }
                
                const now = new Date();
                
                // Load statuses from Firestore
                const statusesSnapshot = await db.collection('statuses')
                    .where('expiresAt', '>', now)
                    .orderBy('expiresAt', 'desc')
                    .limit(50)
                    .get();
                
                // Get user's viewed statuses from localStorage
                const viewedKey = `viewedStatuses_${currentUser.uid}`;
                const viewedData = localStorage.getItem(viewedKey);
                viewedStatuses = viewedData ? JSON.parse(viewedData) : [];
                
                // Process statuses
                allStatuses = [];
                
                statusesSnapshot.forEach(doc => {
                    const statusData = doc.data();
                    const status = {
                        id: doc.id,
                        ...statusData,
                        createdAt: statusData.createdAt ? statusData.createdAt.toDate() : new Date(),
                        expiresAt: statusData.expiresAt ? statusData.expiresAt.toDate() : new Date(now.getTime() + 24 * 60 * 60 * 1000)
                    };
                    
                    // Check if status is visible to user based on privacy
                    if (isStatusVisible(status)) {
                        // Don't show user's own statuses in the contacts list
                        if (status.userId !== currentUser.uid) {
                            allStatuses.push(status);
                        }
                        
                        // Cache the status
                        saveStatusToCache(status);
                    }
                });
                
                console.log(`Loaded ${allStatuses.length} status updates from Firestore`);
                
                // Update my status item
                updateMyStatusItem();
                
                // Update the status list
                updateStatusListWithCache();
                
                // Mark initial load as complete
                isInitialLoadComplete = true;
                
            } catch (error) {
                console.error('Error loading status updates:', error);
                
                // Fallback to cache on error
                console.log('Falling back to cached status updates');
                updateStatusListWithCache();
            }
        }
        
        function initializeApp() {
            // Check if user is loaded
            if (!currentUser) {
                loadCurrentUser();
            }
            
            // Initialize with user data
            if (currentUser && currentUser.uid) {
                loadUserData();
                loadMutedUsers();
                loadArchivedStatuses();
                loadHighlightedStatuses();
                loadUserGroups();
                
                // Load status updates in background
                setTimeout(() => {
                    loadStatusUpdates();
                }, 500);
                
            } else {
                // Wait for auth state
                auth.onAuthStateChanged(user => {
                    if (user) {
                        currentUser = user;
                        localStorage.setItem('currentUser', JSON.stringify({
                            uid: user.uid,
                            displayName: user.displayName,
                            photoURL: user.photoURL,
                            email: user.email
                        }));
                        loadUserData();
                        loadMutedUsers();
                        loadArchivedStatuses();
                        loadHighlightedStatuses();
                        loadUserGroups();
                        
                        // Load status updates in background
                        setTimeout(() => {
                            loadStatusUpdates();
                        }, 500);
                    } else {
                        // Redirect to login page if not authenticated
                        window.location.href = 'index.html';
                    }
                });
            }
        }
        
        async function loadMutedUsers() {
            try {
                if (!currentUser || !currentUser.uid) return;
                
                const userPrefs = localStorage.getItem(`mutedUsers_${currentUser.uid}`);
                if (userPrefs) {
                    mutedUsers = JSON.parse(userPrefs);
                } else {
                    mutedUsers = [];
                }
            } catch (error) {
                console.error('Error loading muted users:', error);
                mutedUsers = [];
            }
        }
        
        function saveMutedUsers() {
            try {
                if (!currentUser || !currentUser.uid) return;
                
                localStorage.setItem(`mutedUsers_${currentUser.uid}`, JSON.stringify(mutedUsers));
            } catch (error) {
                console.error('Error saving muted users:', error);
            }
        }
        
        async function loadArchivedStatuses() {
            try {
                if (!currentUser || !currentUser.uid) return;
                
                const archivedData = localStorage.getItem(`archivedStatuses_${currentUser.uid}`);
                if (archivedData) {
                    archivedStatuses = JSON.parse(archivedData);
                } else {
                    archivedStatuses = [];
                }
            } catch (error) {
                console.error('Error loading archived statuses:', error);
                archivedStatuses = [];
            }
        }
        
        async function loadHighlightedStatuses() {
            try {
                if (!currentUser || !currentUser.uid) return;
                
                const highlightsData = localStorage.getItem(`highlightedStatuses_${currentUser.uid}`);
                if (highlightsData) {
                    highlightedStatuses = JSON.parse(highlightsData);
                } else {
                    highlightedStatuses = [];
                }
            } catch (error) {
                console.error('Error loading highlighted statuses:', error);
                highlightedStatuses = [];
            }
        }
        
        async function loadUserGroups() {
            try {
                if (!currentUser || !currentUser.uid) return;
                
                // Load user's groups from Firestore
                const groupsSnapshot = await db.collection('groups')
                    .where('members', 'array-contains', currentUser.uid)
                    .get();
                
                userGroups = [];
                groupsSnapshot.forEach(doc => {
                    const groupData = doc.data();
                    userGroups.push({
                        id: doc.id,
                        name: groupData.name,
                        members: groupData.members || []
                    });
                });
            } catch (error) {
                console.error('Error loading user groups:', error);
                userGroups = [];
            }
        }
        
        function loadUserData() {
            if (!currentUser) return;
            
            const myStatusAvatar = document.getElementById('myStatusAvatar');
            const userInitials = currentUser.displayName ? 
                currentUser.displayName.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2) : 
                'ME';
            
            if (currentUser.photoURL) {
                myStatusAvatar.style.backgroundImage = `url('${currentUser.photoURL}')`;
                myStatusAvatar.innerHTML = '';
            } else {
                myStatusAvatar.innerHTML = `<span>${userInitials}<\/span>`;
            }
        }
        
        function isStatusVisible(status) {
            // Check if status has expired (24 hours)
            const now = new Date();
            if (status.expiresAt && new Date(status.expiresAt) < now) return false;
            
            // Check if user is muted
            if (mutedUsers.includes(status.userId)) return false;
            
            // Check privacy settings
            if (status.userId === currentUser.uid) return true;
            
            switch (status.privacy) {
                case 'contacts':
                    // Assume all users are contacts for demo
                    return true;
                case 'contacts-except':
                    return !(status.excludedContacts || []).includes(currentUser.uid);
                case 'only-share':
                    return (status.allowedContacts || []).includes(currentUser.uid);
                case 'public':
                    return true;
                default:
                    return true;
            }
        }
        
        async function updateMyStatusItem() {
            if (!currentUser || !currentUser.uid) return;
            
            const myStatuses = await getUserStatuses(currentUser.uid);
            const myStatusItem = document.getElementById('myStatusItem');
            const myStatusOptions = document.getElementById('myStatusOptions');
            
            if (myStatuses && myStatuses.length > 0) {
                const latestStatus = myStatuses[0];
                const statusCount = myStatuses.length;
                
                myStatusItem.querySelector('.my-status-desc').textContent = 
                    `${statusCount} update${statusCount > 1 ? 's' : ''}`;
                
                // Add status ring to avatar
                myStatusItem.querySelector('.my-status-avatar').classList.add('has-status');
                
                // Show options
                myStatusOptions.style.display = 'block';
                
                // Store current user's statuses
                window.myCurrentStatuses = myStatuses;
            } else {
                myStatusItem.querySelector('.my-status-desc').textContent = 'Tap to add status update';
                myStatusItem.querySelector('.my-status-avatar').classList.remove('has-status');
                myStatusOptions.style.display = 'none';
            }
        }
        
        async function getUserStatuses(userId) {
            try {
                const now = new Date();
                const statusesSnapshot = await db.collection('statuses')
                    .where('userId', '==', userId)
                    .where('expiresAt', '>', now)
                    .orderBy('expiresAt', 'desc')
                    .get();
                
                const statuses = [];
                statusesSnapshot.forEach(doc => {
                    const statusData = doc.data();
                    const status = {
                        id: doc.id,
                        ...statusData,
                        createdAt: statusData.createdAt ? statusData.createdAt.toDate() : new Date(),
                        expiresAt: statusData.expiresAt ? statusData.expiresAt.toDate() : new Date(now.getTime() + 24 * 60 * 60 * 1000)
                    };
                    
                    if (status.expiresAt > now) {
                        statuses.push(status);
                    }
                });
                
                return statuses;
            } catch (error) {
                console.error('Error getting user statuses:', error);
                return [];
            }
        }
        
        // ============================================
        // STATUS VIEWER FUNCTIONS
        // ============================================
        
        function openStatusViewer(userId, statuses) {
            if (!statuses || statuses.length === 0) return;
            
            currentStatusUser = userId;
            userStatuses = statuses.filter(status => 
                !status.expiresAt || new Date(status.expiresAt) > new Date()
            );
            
            if (userStatuses.length === 0) {
                showNotification('No active statuses to view', 'warning');
                return;
            }
            
            currentStatusIndex = 0;
            
            // Show status viewer
            statusViewer.classList.add('active');
            
            // Load first status
            loadStatus(currentStatusIndex);
            
            // Start auto-advance timer
            startStatusTimer();
            
            // Show appropriate buttons
            const shareBtn = document.getElementById('shareStatusBtn');
            const muteBtn = document.getElementById('muteUserBtn');
            const highlightBtn = document.getElementById('highlightStatusBtn');
            
            shareBtn.style.display = userId !== currentUser.uid ? 'flex' : 'none';
            muteBtn.style.display = userId !== currentUser.uid ? 'flex' : 'none';
            highlightBtn.style.display = userId === currentUser.uid ? 'flex' : 'none';
            
            // Check if already highlighted
            if (userId === currentUser.uid && userStatuses[0].id) {
                const isHighlighted = highlightedStatuses.some(s => s.id === userStatuses[0].id);
                highlightBtn.innerHTML = isHighlighted ? 
                    '<i class="fas fa-star"><\/i> Unhighlight' : 
                    '<i class="fas fa-star"><\/i> Highlight';
            }
        }
        
        function loadStatus(index) {
            if (!userStatuses || index >= userStatuses.length) {
                closeStatusViewer();
                return;
            }
            
            const status = userStatuses[index];
            currentStatusId = status.id || status.tempId;
            
            // Update user info
            document.getElementById('statusUserName').textContent = status.userName || 'User';
            document.getElementById('statusTime').textContent = getTimeAgo(status.createdAt);
            
            // Update user avatar
            const statusUserAvatar = document.querySelector('.status-user-avatar');
            const initials = status.userName ? 
                status.userName.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2) : 
                'U';
            
            if (status.userAvatar) {
                statusUserAvatar.style.backgroundImage = `url('${status.userAvatar}')`;
                statusUserAvatar.innerHTML = '';
            } else {
                statusUserAvatar.style.backgroundImage = '';
                statusUserAvatar.innerHTML = `<span>${initials}<\/span>`;
            }
            
            // Clear previous content
            const statusContent = document.getElementById('statusContent');
            statusContent.innerHTML = '';
            
            // Hide interactive elements
            document.getElementById('pollDisplay').style.display = 'none';
            document.getElementById('questionDisplay').style.display = 'none';
            document.getElementById('musicDisplay').style.display = 'none';
            
            // Create progress bars
            updateProgressBars();
            
            // Load status content based on type
            switch(status.type) {
                case 'text':
                case 'emoji':
                    loadTextStatus(status);
                    break;
                case 'photo':
                case 'gif':
                    loadImageStatus(status);
                    break;
                case 'video':
                    loadVideoStatus(status);
                    break;
                case 'voice':
                    loadVoiceStatus(status);
                    break;
                case 'poll':
                    loadPollStatus(status);
                    break;
                case 'question':
                    loadQuestionStatus(status);
                    break;
                case 'music':
                    loadMusicStatus(status);
                    break;
                default:
                    loadTextStatus(status);
            }
            
            // Mark as viewed (only if not the owner and not a pending status)
            if (status.userId !== currentUser.uid && !status.isPending && status.id) {
                markStatusAsViewed(status.id);
            }
        }
        
        function loadTextStatus(status) {
            const statusContent = document.getElementById('statusContent');
            const textStatus = document.createElement('div');
            textStatus.className = 'text-status';
            textStatus.style.color = status.textColor || '#ffffff';
            textStatus.style.backgroundColor = status.backgroundColor || '#0084ff';
            textStatus.style.fontFamily = status.font || 'Segoe UI, sans-serif';
            textStatus.style.padding = '40px';
            textStatus.style.borderRadius = '20px';
            textStatus.style.maxWidth = '800px';
            textStatus.style.margin = '0 auto';
            textStatus.style.fontSize = status.type === 'emoji' ? '80px' : '32px';
            textStatus.style.display = 'flex';
            textStatus.style.alignItems = 'center';
            textStatus.style.justifyContent = 'center';
            textStatus.style.minHeight = '300px';
            textStatus.style.wordBreak = 'break-word';
            
            if (status.type === 'emoji') {
                textStatus.textContent = status.content || '';
            } else {
                textStatus.innerHTML = formatText(status.content || '');
            }
            
            statusContent.appendChild(textStatus);
        }
        
        function loadImageStatus(status) {
            const statusContent = document.getElementById('statusContent');
            const img = document.createElement('img');
            img.className = 'status-media';
            img.src = status.content || 'https://via.placeholder.com/800x1400/0084ff/ffffff?text=Status+Image';
            img.alt = status.caption || 'Status image';
            img.onerror = function() {
                this.src = 'https://via.placeholder.com/800x1400/0084ff/ffffff?text=Image+Not+Found';
            };
            
            statusContent.appendChild(img);
            
            if (status.caption) {
                const caption = document.createElement('div');
                caption.className = 'text-status';
                caption.style.position = 'absolute';
                caption.style.bottom = '100px';
                caption.style.left = '0';
                caption.style.right = '0';
                caption.style.textAlign = 'center';
                caption.style.padding = '20px';
                caption.style.fontSize = '20px';
                caption.style.backgroundColor = 'rgba(0,0,0,0.5)';
                caption.style.backdropFilter = 'blur(10px)';
                caption.textContent = status.caption;
                
                statusContent.appendChild(caption);
            }
        }
        
        function loadVideoStatus(status) {
            const statusContent = document.getElementById('statusContent');
            const video = document.createElement('video');
            video.className = 'status-media';
            video.src = status.content || '';
            video.controls = true;
            video.autoplay = true;
            video.muted = false;
            video.onended = function() {
                // Auto-advance to next status when video ends
                setTimeout(() => {
                    currentStatusIndex++;
                    if (currentStatusIndex < userStatuses.length) {
                        loadStatus(currentStatusIndex);
                    } else {
                        closeStatusViewer();
                    }
                }, 1000);
            };
            
            statusContent.appendChild(video);
            
            if (status.caption) {
                const caption = document.createElement('div');
                caption.className = 'text-status';
                caption.style.position = 'absolute';
                caption.style.bottom = '100px';
                caption.style.left = '0';
                caption.style.right = '0';
                caption.style.textAlign = 'center';
                caption.style.padding = '20px';
                caption.style.fontSize = '20px';
                caption.style.backgroundColor = 'rgba(0,0,0,0.5)';
                caption.style.backdropFilter = 'blur(10px)';
                caption.textContent = status.caption;
                
                statusContent.appendChild(caption);
            }
        }
        
        function loadVoiceStatus(status) {
            const statusContent = document.getElementById('statusContent');
            
            const voiceContainer = document.createElement('div');
            voiceContainer.style.display = 'flex';
            voiceContainer.style.flexDirection = 'column';
            voiceContainer.style.alignItems = 'center';
            voiceContainer.style.justifyContent = 'center';
            voiceContainer.style.height = '100%';
            voiceContainer.style.width = '100%';
            voiceContainer.style.backgroundColor = '#0084ff';
            voiceContainer.style.borderRadius = '20px';
            voiceContainer.style.maxWidth = '600px';
            voiceContainer.style.maxHeight = '600px';
            voiceContainer.style.margin = '0 auto';
            voiceContainer.style.padding = '40px';
            
            const voiceIcon = document.createElement('div');
            voiceIcon.innerHTML = '<i class="fas fa-microphone" style="font-size: 80px; color: white; margin-bottom: 30px;"><\/i>';
            
            const playButton = document.createElement('button');
            playButton.className = 'play-btn';
            playButton.innerHTML = '<i class="fas fa-play"><\/i>';
            playButton.onclick = function() {
                playVoiceStatus(status.content);
            };
            
            const durationText = document.createElement('div');
            durationText.textContent = 'Voice Message';
            durationText.style.color = 'white';
            durationText.style.marginTop = '20px';
            durationText.style.fontSize = '18px';
            
            voiceContainer.appendChild(voiceIcon);
            voiceContainer.appendChild(playButton);
            voiceContainer.appendChild(durationText);
            
            statusContent.appendChild(voiceContainer);
        }
        
        function loadPollStatus(status) {
            const statusContent = document.getElementById('statusContent');
            
            // Create poll background
            const pollBackground = document.createElement('div');
            pollBackground.style.display = 'flex';
            pollBackground.style.flexDirection = 'column';
            pollBackground.style.alignItems = 'center';
            pollBackground.style.justifyContent = 'center';
            pollBackground.style.height = '100%';
            pollBackground.style.width = '100%';
            pollBackground.style.backgroundColor = status.backgroundColor || '#0084ff';
            pollBackground.style.padding = '40px';
            
            const pollQuestion = document.createElement('div');
            pollQuestion.textContent = status.pollQuestion || 'Poll Question';
            pollQuestion.style.color = 'white';
            pollQuestion.style.fontSize = '28px';
            pollQuestion.style.fontWeight = 'bold';
            pollQuestion.style.textAlign = 'center';
            pollQuestion.style.marginBottom = '40px';
            pollQuestion.style.maxWidth = '600px';
            
            pollBackground.appendChild(pollQuestion);
            statusContent.appendChild(pollBackground);
            
            // Show poll options in overlay
            const pollDisplay = document.getElementById('pollDisplay');
            pollDisplay.style.display = 'block';
            pollDisplay.innerHTML = '';
            
            const pollOptions = status.pollOptions || [];
            const pollVotes = status.pollVotes || {};
            const totalVotes = Object.values(pollVotes).length;
            
            pollOptions.forEach((option, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'poll-option-result';
                
                const optionText = document.createElement('div');
                optionText.textContent = option;
                
                const votes = Object.values(pollVotes).filter(vote => vote === index).length;
                const percentage = totalVotes > 0 ? (votes / totalVotes * 100).toFixed(1) : 0;
                
                const barContainer = document.createElement('div');
                barContainer.style.marginTop = '5px';
                
                const bar = document.createElement('div');
                bar.className = 'poll-bar';
                bar.style.width = `${percentage}%`;
                bar.style.height = '8px';
                bar.style.backgroundColor = '#34c759';
                bar.style.borderRadius = '4px';
                bar.style.transition = 'width 0.5s ease';
                
                const percentageText = document.createElement('div');
                percentageText.textContent = `${percentage}% (${votes} votes)`;
                percentageText.style.fontSize = '12px';
                percentageText.style.color = '#65676b';
                percentageText.style.marginTop = '5px';
                
                barContainer.appendChild(bar);
                optionDiv.appendChild(optionText);
                optionDiv.appendChild(barContainer);
                optionDiv.appendChild(percentageText);
                
                // Add click event to vote
                optionDiv.onclick = function() {
                    voteOnPoll(status.id, index);
                };
                
                pollDisplay.appendChild(optionDiv);
            });
            
            const totalVotesText = document.createElement('div');
            totalVotesText.textContent = `Total votes: ${totalVotes}`;
            totalVotesText.style.marginTop = '15px';
            totalVotesText.style.fontSize = '14px';
            totalVotesText.style.color = '#65676b';
            totalVotesText.style.textAlign = 'center';
            
            pollDisplay.appendChild(totalVotesText);
        }
        
        function loadQuestionStatus(status) {
            const statusContent = document.getElementById('statusContent');
            
            const questionBackground = document.createElement('div');
            questionBackground.style.display = 'flex';
            questionBackground.style.flexDirection = 'column';
            questionBackground.style.alignItems = 'center';
            questionBackground.style.justifyContent = 'center';
            questionBackground.style.height = '100%';
            questionBackground.style.width = '100%';
            questionBackground.style.backgroundColor = status.backgroundColor || '#ff9500';
            questionBackground.style.padding = '40px';
            
            const questionIcon = document.createElement('div');
            questionIcon.innerHTML = '<i class="fas fa-question-circle" style="font-size: 80px; color: white; margin-bottom: 30px;"><\/i>';
            
            const questionText = document.createElement('div');
            questionText.textContent = status.question || 'Ask me anything!';
            questionText.style.color = 'white';
            questionText.style.fontSize = '28px';
            questionText.style.fontWeight = 'bold';
            questionText.style.textAlign = 'center';
            questionText.style.maxWidth = '600px';
            
            questionBackground.appendChild(questionIcon);
            questionBackground.appendChild(questionText);
            statusContent.appendChild(questionBackground);
            
            // Show answer input
            const questionDisplay = document.getElementById('questionDisplay');
            questionDisplay.style.display = 'block';
            questionDisplay.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 10px;">Answer the question:<\/div>
                <input type="text" class="answer-input" id="answerInput" placeholder="Type your answer...">
                <button class="text-tool-btn" id="submitAnswerBtn" style="margin-top: 10px; width: 100%; background-color: var(--primary-color); color: white;">Submit Answer<\/button>
            `;
            
            document.getElementById('submitAnswerBtn').onclick = function() {
                const answer = document.getElementById('answerInput').value.trim();
                if (answer) {
                    submitAnswer(status.id, answer);
                    document.getElementById('answerInput').value = '';
                    showNotification('Answer submitted!', 'success');
                }
            };
        }
        
        function loadMusicStatus(status) {
            const statusContent = document.getElementById('statusContent');
            
            const musicBackground = document.createElement('div');
            musicBackground.style.display = 'flex';
            musicBackground.style.flexDirection = 'column';
            musicBackground.style.alignItems = 'center';
            musicBackground.style.justifyContent = 'center';
            musicBackground.style.height = '100%';
            musicBackground.style.width = '100%';
            musicBackground.style.backgroundColor = status.backgroundColor || '#5856d6';
            musicBackground.style.padding = '40px';
            
            const musicIcon = document.createElement('div');
            musicIcon.innerHTML = '<i class="fas fa-music" style="font-size: 80px; color: white; margin-bottom: 30px;"><\/i>';
            
            const musicTitle = document.createElement('div');
            musicTitle.textContent = status.musicTitle || 'Now Playing';
            musicTitle.style.color = 'white';
            musicTitle.style.fontSize = '24px';
            musicTitle.style.fontWeight = 'bold';
            musicTitle.style.textAlign = 'center';
            musicTitle.style.marginBottom = '10px';
            
            const musicArtist = document.createElement('div');
            musicArtist.textContent = status.musicArtist || 'Unknown Artist';
            musicArtist.style.color = 'rgba(255,255,255,0.8)';
            musicArtist.style.fontSize = '18px';
            musicArtist.style.textAlign = 'center';
            
            musicBackground.appendChild(musicIcon);
            musicBackground.appendChild(musicTitle);
            musicBackground.appendChild(musicArtist);
            statusContent.appendChild(musicBackground);
            
            // Show music controls
            const musicDisplay = document.getElementById('musicDisplay');
            musicDisplay.style.display = 'flex';
            musicDisplay.innerHTML = `
                <div style="width: 50px; height: 50px; background: #0084ff; border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                    <i class="fas fa-music" style="color: white; font-size: 24px;"><\/i>
                <\/div>
                <div class="music-info">
                    <div style="font-weight: bold;">${status.musicTitle || 'Track'}<\/div>
                    <div style="font-size: 14px; color: #65676b;">${status.musicArtist || 'Artist'}<\/div>
                <\/div>
                <div class="music-controls">
                    <button class="status-action-btn" id="playMusicBtn">
                        <i class="fas fa-play"><\/i>
                    <\/button>
                    <button class="status-action-btn" id="pauseMusicBtn" style="display: none;">
                        <i class="fas fa-pause"><\/i>
                    <\/button>
                <\/div>
            `;
            
            // Music control functionality
            let isPlaying = false;
            const playBtn = document.getElementById('playMusicBtn');
            const pauseBtn = document.getElementById('pauseMusicBtn');
            
            playBtn.onclick = function() {
                isPlaying = true;
                playBtn.style.display = 'none';
                pauseBtn.style.display = 'flex';
                showNotification('Playing music...', 'success');
            };
            
            pauseBtn.onclick = function() {
                isPlaying = false;
                pauseBtn.style.display = 'none';
                playBtn.style.display = 'flex';
                showNotification('Music paused', 'warning');
            };
        }
        
        function formatText(text) {
            return (text || '')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1<\/strong>')
                .replace(/\*(.*?)\*/g, '<em>$1<\/em>')
                .replace(/~~(.*?)~~/g, '<s>$1<\/s>')
                .replace(/`(.*?)`/g, '<code>$1<\/code>');
        }
        
        function updateProgressBars() {
            const container = document.getElementById('statusProgressContainer');
            container.innerHTML = '';
            
            userStatuses.forEach((status, index) => {
                const progressBar = document.createElement('div');
                progressBar.className = 'status-progress-bar';
                
                const progressFill = document.createElement('div');
                progressFill.className = 'status-progress-fill';
                progressFill.style.width = index < currentStatusIndex ? '100%' : '0%';
                
                progressBar.appendChild(progressFill);
                container.appendChild(progressBar);
            });
        }
        
        function startStatusTimer() {
            if (statusInterval) clearInterval(statusInterval);
            
            // Don't start timer for videos or voice (they have their own controls)
            const currentStatus = userStatuses[currentStatusIndex];
            if (currentStatus && (currentStatus.type === 'video' || currentStatus.type === 'voice' || currentStatus.type === 'music')) {
                return;
            }
            
            statusInterval = setInterval(() => {
                if (isPaused) return;
                
                const progressBars = document.querySelectorAll('.status-progress-fill');
                if (progressBars[currentStatusIndex]) {
                    const currentWidth = parseFloat(progressBars[currentStatusIndex].style.width) || 0;
                    const newWidth = Math.min(currentWidth + 0.5, 100); // 10 seconds total
                    progressBars[currentStatusIndex].style.width = `${newWidth}%`;
                    
                    if (newWidth >= 100) {
                        currentStatusIndex++;
                        if (currentStatusIndex < userStatuses.length) {
                            loadStatus(currentStatusIndex);
                        } else {
                            closeStatusViewer();
                        }
                    }
                }
            }, 50);
        }
        
        function closeStatusViewer() {
            statusViewer.classList.remove('active');
            if (statusInterval) {
                clearInterval(statusInterval);
                statusInterval = null;
            }
            isPaused = false;
            pauseOverlay.classList.remove('active');
        }
        
        // ============================================
        // UI INITIALIZATION FUNCTIONS
        // ============================================
        
        function initializeStatusTypeContainers() {
            const containers = document.getElementById('statusTypeContainers');
            containers.innerHTML = '';
            
            // Text Status
            const textContainer = document.createElement('div');
            textContainer.className = 'status-type-container active';
            textContainer.id = 'textStatusContainer';
            textContainer.innerHTML = `
                <div class="text-editor-container" id="textEditorContainer">
                    <textarea class="text-editor" id="textEditor" placeholder="Type your status here..."><\/textarea>
                <\/div>
                
                <div class="text-toolbar">
                    <button class="text-tool-btn" data-format="bold">
                        <i class="fas fa-bold"><\/i> Bold
                    <\/button>
                    <button class="text-tool-btn" data-format="italic">
                        <i class="fas fa-italic"><\/i> Italic
                    <\/button>
                    <button class="text-tool-btn" data-format="strikethrough">
                        <i class="fas fa-strikethrough"><\/i> Strikethrough
                    <\/button>
                    <button class="text-tool-btn" data-format="monospace">
                        <i class="fas fa-code"><\/i> Monospace
                    <\/button>
                <\/div>
                
                <div>
                    <div style="font-weight: 500; margin-bottom: 10px;">Text Color<\/div>
                    <div class="color-palette" id="textColorPalette"><\/div>
                <\/div>
                
                <div style="margin-top: 20px;">
                    <div style="font-weight: 500; margin-bottom: 10px;">Background Color<\/div>
                    <div class="color-palette" id="backgroundColorPalette"><\/div>
                <\/div>
                
                <div style="margin-top: 20px;">
                    <div style="font-weight: 500; margin-bottom: 10px;">Font Style<\/div>
                    <div class="font-options" id="fontOptions"><\/div>
                <\/div>
            `;
            containers.appendChild(textContainer);
            
            // Emoji Status
            const emojiContainer = document.createElement('div');
            emojiContainer.className = 'status-type-container';
            emojiContainer.id = 'emojiStatusContainer';
            emojiContainer.innerHTML = `
                <div class="emoji-only-container" id="emojiOnlyContainer">
                    <div class="emoji-only-display" id="emojiOnlyDisplay"><\/div>
                    <button class="text-tool-btn" id="openEmojiPickerBtn">
                        <i class="fas fa-smile"><\/i> Choose Emoji
                    <\/button>
                    <div class="emoji-picker-container" id="emojiPickerContainer"><\/div>
                <\/div>
                
                <div>
                    <div style="font-weight: 500; margin-bottom: 10px;">Background Color<\/div>
                    <div class="color-palette" id="emojiBackgroundPalette"><\/div>
                <\/div>
            `;
            containers.appendChild(emojiContainer);
            
            // Photo Status
            const photoContainer = document.createElement('div');
            photoContainer.className = 'status-type-container';
            photoContainer.id = 'photoStatusContainer';
            photoContainer.innerHTML = `
                <div class="media-upload-area" id="photoUploadArea">
                    <div class="media-upload-icon">
                        <i class="fas fa-camera"><\/i>
                    <\/div>
                    <div class="media-upload-text">Tap to upload photo<\/div>
                    <div class="media-upload-subtext">or drag and drop<\/div>
                    <input type="file" id="photoUploadInput" accept="image/*" style="display: none;">
                <\/div>
                
                <div class="media-preview" id="photoPreview">
                    <img src="" alt="" class="media-preview-img" id="photoPreviewImg">
                <\/div>
                
                <div class="media-edit-tools" id="photoEditTools" style="display: none;">
                    <button class="media-edit-btn" id="addTextToPhotoBtn">
                        <i class="fas fa-font"><\/i> Add Text
                    <\/button>
                    <button class="media-edit-btn" id="drawOnPhotoBtn">
                        <i class="fas fa-paint-brush"><\/i> Draw
                    <\/button>
                    <button class="media-edit-btn" id="addFilterToPhotoBtn">
                        <i class="fas fa-sliders-h"><\/i> Filters
                    <\/button>
                    <button class="media-edit-btn" id="addStickerToPhotoBtn">
                        <i class="fas fa-sticky-note"><\/i> Add Sticker
                    <\/button>
                <\/div>
                
                <div style="margin-top: 20px;">
                    <input type="text" class="poll-question-input" id="photoCaptionInput" placeholder="Add a caption (optional)">
                <\/div>
            `;
            containers.appendChild(photoContainer);
            
            // Video Status
            const videoContainer = document.createElement('div');
            videoContainer.className = 'status-type-container';
            videoContainer.id = 'videoStatusContainer';
            videoContainer.innerHTML = `
                <div class="media-upload-area" id="videoUploadArea">
                    <div class="media-upload-icon">
                        <i class="fas fa-video"><\/i>
                    <\/div>
                    <div class="media-upload-text">Tap to upload video<\/div>
                    <div class="media-upload-subtext">Max 30 seconds<\/div>
                    <div class="video-duration-warning" id="videoDurationWarning" style="display: none;">
                        <i class="fas fa-exclamation-triangle"><\/i> Video must be 30 seconds or less
                    <\/div>
                    <input type="file" id="videoUploadInput" accept="video/*" style="display: none;">
                <\/div>
                
                <div class="media-preview" id="videoPreview">
                    <video class="media-preview-video" id="videoPreviewVideo" controls><\/video>
                <\/div>
                
                <div class="media-edit-tools" id="videoEditTools" style="display: none;">
                    <button class="media-edit-btn" id="trimVideoBtn">
                        <i class="fas fa-cut"><\/i> Trim Video
                    <\/button>
                    <button class="media-edit-btn" id="addCaptionToVideoBtn">
                        <i class="fas fa-font"><\/i> Add Caption
                    <\/button>
                <\/div>
                
                <div style="margin-top: 20px;">
                    <input type="text" class="poll-question-input" id="videoCaptionInput" placeholder="Add a caption (optional)">
                <\/div>
            `;
            containers.appendChild(videoContainer);
            
            // Voice Status
            const voiceContainer = document.createElement('div');
            voiceContainer.className = 'status-type-container';
            voiceContainer.id = 'voiceStatusContainer';
            voiceContainer.innerHTML = `
                <div class="voice-recorder-container">
                    <div class="waveform-container" id="waveformContainer"><\/div>
                    
                    <div class="recording-controls">
                        <button class="record-btn" id="recordBtn">
                            <i class="fas fa-microphone"><\/i>
                        <\/button>
                        <div class="recording-timer" id="recordingTimer">00:00<\/div>
                    <\/div>
                    
                    <div class="voice-playback" id="voicePlayback" style="display: none;">
                        <button class="play-btn" id="playRecordedBtn">
                            <i class="fas fa-play"><\/i>
                        <\/button>
                        <div style="flex: 1;">
                            <div id="recordingDuration">Recording: 0s<\/div>
                            <div style="font-size: 12px; color: var(--text-secondary);">Click play to preview<\/div>
                        <\/div>
                        <button class="text-tool-btn" id="rerecordBtn">
                            <i class="fas fa-redo"><\/i> Re-record
                        <\/button>
                    <\/div>
                <\/div>
            `;
            containers.appendChild(voiceContainer);
            
            // Poll Status
            const pollContainer = document.createElement('div');
            pollContainer.className = 'status-type-container';
            pollContainer.id = 'pollStatusContainer';
            pollContainer.innerHTML = `
                <div class="poll-container">
                    <input type="text" class="poll-question-input" id="pollQuestionInput" placeholder="Ask a question...">
                    
                    <div id="pollOptionsContainer">
                        <div class="poll-option">
                            <input type="text" class="poll-option-input" placeholder="Option 1" data-index="0">
                        <\/div>
                        <div class="poll-option">
                            <input type="text" class="poll-option-input" placeholder="Option 2" data-index="1">
                        <\/div>
                    <\/div>
                    
                    <button class="add-option-btn" id="addPollOptionBtn">
                        <i class="fas fa-plus"><\/i> Add Option
                    <\/button>
                <\/div>
                
                <div style="margin-top: 20px;">
                    <div style="font-weight: 500; margin-bottom: 10px;">Poll Background Color<\/div>
                    <div class="color-palette" id="pollBackgroundPalette"><\/div>
                <\/div>
            `;
            containers.appendChild(pollContainer);
            
            // Question Status
            const questionContainer = document.createElement('div');
            questionContainer.className = 'status-type-container';
            questionContainer.id = 'questionStatusContainer';
            questionContainer.innerHTML = `
                <div class="question-container">
                    <input type="text" class="question-input" id="questionInput" placeholder="Ask me anything...">
                <\/div>
                
                <div style="margin-top: 20px;">
                    <div style="font-weight: 500; margin-bottom: 10px;">Question Background Color<\/div>
                    <div class="color-palette" id="questionBackgroundPalette"><\/div>
                <\/div>
            `;
            containers.appendChild(questionContainer);
            
            // Music Status
            const musicContainer = document.createElement('div');
            musicContainer.className = 'status-type-container';
            musicContainer.id = 'musicStatusContainer';
            musicContainer.innerHTML = `
                <div class="music-container">
                    <input type="text" class="music-search" id="musicSearchInput" placeholder="Search for music...">
                    
                    <div class="music-results" id="musicResults">
                        ${musicTracks.map(track => `
                            <div class="music-result" data-id="${track.id}" data-title="${track.title}" data-artist="${track.artist}">
                                <div style="font-weight: 500;">${track.title}<\/div>
                                <div style="font-size: 12px; color: var(--text-secondary);">${track.artist}  ${track.duration}<\/div>
                            <\/div>
                        `).join('')}
                    <\/div>
                <\/div>
                
                <div style="margin-top: 20px;">
                    <div style="font-weight: 500; margin-bottom: 10px;">Music Background Color<\/div>
                    <div class="color-palette" id="musicBackgroundPalette"><\/div>
                <\/div>
            `;
            containers.appendChild(musicContainer);
            
            // Group Status
            const groupContainer = document.createElement('div');
            groupContainer.className = 'status-type-container';
            groupContainer.id = 'groupStatusContainer';
            groupContainer.innerHTML = `
                <div class="group-status-selector">
                    <div style="font-weight: 500; margin-bottom: 10px;">Select a group:<\/div>
                    <div id="groupOptionsContainer">
                        ${userGroups.length > 0 ? userGroups.map(group => `
                            <div class="group-option" data-group-id="${group.id}">
                                <i class="fas fa-users"><\/i>
                                <span>${group.name}<\/span>
                                <span style="font-size: 12px; color: var(--text-secondary); margin-left: auto;">${group.members.length} members<\/span>
                            <\/div>
                        `).join('') : '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">No groups found<\/p>'}
                    <\/div>
                    <p style="font-size: 12px; color: var(--text-secondary); margin-top: 10px;">
                        Status will be shared with all group members
                    <\/p>
                <\/div>
                
                <div id="groupStatusContent" style="display: none;">
                    <!-- Content from other status types will be shown here -->
                <\/div>
            `;
            containers.appendChild(groupContainer);
        }
        
        function initializeColorPalettes() {
            // Text color palette
            const textColorPalette = document.getElementById('textColorPalette');
            if (textColorPalette) {
                textColorPalette.innerHTML = '';
                textColors.forEach(color => {
                    const colorOption = document.createElement('div');
                    colorOption.className = 'color-option';
                    colorOption.style.backgroundColor = color;
                    colorOption.dataset.color = color;
                    colorOption.addEventListener('click', () => selectTextColor(color));
                    textColorPalette.appendChild(colorOption);
                });
                
                if (textColors.length > 0) {
                    selectTextColor(textColors[0]);
                }
            }
            
            // Background color palette
            const backgroundColorPalette = document.getElementById('backgroundColorPalette');
            if (backgroundColorPalette) {
                backgroundColorPalette.innerHTML = '';
                backgroundColors.forEach(color => {
                    const colorOption = document.createElement('div');
                    colorOption.className = 'color-option';
                    colorOption.style.backgroundColor = color;
                    colorOption.dataset.color = color;
                    colorOption.addEventListener('click', () => selectBackgroundColor(color));
                    backgroundColorPalette.appendChild(colorOption);
                });
                
                if (backgroundColors.length > 0) {
                    selectBackgroundColor(backgroundColors[0]);
                }
            }
            
            // Emoji background palette
            const emojiBackgroundPalette = document.getElementById('emojiBackgroundPalette');
            if (emojiBackgroundPalette) {
                emojiBackgroundPalette.innerHTML = '';
                backgroundColors.forEach(color => {
                    const colorOption = document.createElement('div');
                    colorOption.className = 'color-option';
                    colorOption.style.backgroundColor = color;
                    colorOption.dataset.color = color;
                    colorOption.addEventListener('click', () => selectEmojiBackgroundColor(color));
                    emojiBackgroundPalette.appendChild(colorOption);
                });
            }
            
            // Other palettes
            ['pollBackgroundPalette', 'questionBackgroundPalette', 'musicBackgroundPalette'].forEach(paletteId => {
                const palette = document.getElementById(paletteId);
                if (palette) {
                    palette.innerHTML = '';
                    backgroundColors.forEach(color => {
                        const colorOption = document.createElement('div');
                        colorOption.className = 'color-option';
                        colorOption.style.backgroundColor = color;
                        colorOption.dataset.color = color;
                        colorOption.addEventListener('click', () => {
                            document.querySelectorAll(`#${paletteId} .color-option`).forEach(opt => {
                                opt.classList.remove('active');
                            });
                            colorOption.classList.add('active');
                        });
                        palette.appendChild(colorOption);
                    });
                    
                    if (backgroundColors.length > 0) {
                        palette.querySelector('.color-option').classList.add('active');
                    }
                }
            });
        }
        
        function initializeFontOptions() {
            const fontOptions = document.getElementById('fontOptions');
            if (fontOptions) {
                fontOptions.innerHTML = '';
                fonts.forEach(font => {
                    const fontOption = document.createElement('div');
                    fontOption.className = 'font-option';
                    fontOption.textContent = font.name;
                    fontOption.style.fontFamily = font.value;
                    fontOption.dataset.font = font.value;
                    fontOption.addEventListener('click', () => selectFont(font.value));
                    fontOptions.appendChild(fontOption);
                });
                
                if (fonts.length > 0) {
                    selectFont(fonts[0].value);
                }
            }
        }
        
        function initializeDrawingTools() {
            const drawingColorsContainer = document.getElementById('drawingColors');
            if (drawingColorsContainer) {
                drawingColorsContainer.innerHTML = '';
                drawingColors.forEach(color => {
                    const colorOption = document.createElement('div');
                    colorOption.className = 'drawing-color';
                    colorOption.style.backgroundColor = color;
                    colorOption.dataset.color = color;
                    colorOption.addEventListener('click', () => selectDrawingColor(color));
                    drawingColorsContainer.appendChild(colorOption);
                });
                
                if (drawingColors.length > 0) {
                    selectDrawingColor(drawingColors[0]);
                }
            }
            
            const drawingBrushesContainer = document.getElementById('drawingBrushes');
            if (drawingBrushesContainer) {
                drawingBrushesContainer.innerHTML = '';
                brushSizes.forEach(size => {
                    const brushOption = document.createElement('div');
                    brushOption.className = 'drawing-brush';
                    brushOption.textContent = size;
                    brushOption.dataset.size = size;
                    brushOption.addEventListener('click', () => selectBrushSize(size));
                    drawingBrushesContainer.appendChild(brushOption);
                });
                
                if (brushSizes.length > 0) {
                    selectBrushSize(brushSizes[0]);
                }
            }
            
            const canvasElement = document.getElementById('drawingCanvas');
            if (canvasElement) {
                fabricCanvas = new fabric.Canvas(canvasElement, {
                    isDrawingMode: true,
                    width: window.innerWidth,
                    height: window.innerHeight - 100
                });
                
                fabricCanvas.freeDrawingBrush = new fabric.PencilBrush(fabricCanvas);
                fabricCanvas.freeDrawingBrush.width = brushSizes[0];
                fabricCanvas.freeDrawingBrush.color = drawingColors[0];
            }
        }
        
        function initializeEmojiPicker() {
            try {
                // Initialize emoji picker
                const pickerContainer = document.getElementById('emojiPickerContainer');
                if (pickerContainer) {
                    const picker = document.createElement('emoji-picker');
                    picker.addEventListener('emoji-click', event => {
                        selectedEmoji = event.detail.unicode;
                        document.getElementById('emojiOnlyDisplay').textContent = selectedEmoji;
                        pickerContainer.classList.remove('active');
                    });
                    
                    pickerContainer.appendChild(picker);
                }
            } catch (error) {
                console.error('Error initializing emoji picker:', error);
                // Fallback: create simple emoji selector
                createSimpleEmojiPicker();
            }
        }
        
        function createSimpleEmojiPicker() {
            const pickerContainer = document.getElementById('emojiPickerContainer');
            if (!pickerContainer) return;
            
            const commonEmojis = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];
            
            pickerContainer.innerHTML = '';
            commonEmojis.forEach(emoji => {
                const emojiBtn = document.createElement('button');
                emojiBtn.textContent = emoji;
                emojiBtn.style.fontSize = '24px';
                emojiBtn.style.padding = '10px';
                emojiBtn.style.border = 'none';
                emojiBtn.style.background = 'none';
                emojiBtn.style.cursor = 'pointer';
                emojiBtn.addEventListener('click', () => {
                    selectedEmoji = emoji;
                    document.getElementById('emojiOnlyDisplay').textContent = selectedEmoji;
                    pickerContainer.classList.remove('active');
                });
                pickerContainer.appendChild(emojiBtn);
            });
        }
        
        function setupScreenshotDetection() {
            // Listen for key combinations (Ctrl+Shift+S, Print Screen, etc.)
            document.addEventListener('keydown', function(e) {
                // Detect Print Screen key
                if (e.key === 'PrintScreen') {
                    handleScreenshot();
                }
                
                // Detect Ctrl+Shift+S (common screenshot shortcut)
                if (e.ctrlKey && e.shiftKey && e.key === 'S') {
                    handleScreenshot();
                }
            });
            
            // Also listen for the clipboard paste event (for screenshots copied to clipboard)
            document.addEventListener('paste', function(e) {
                // Check if pasted content is an image
                const items = e.clipboardData.items;
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf('image') !== -1) {
                        handleScreenshot();
                        break;
                    }
                }
            });
        }
        
        function setupTouchGestures() {
            const statusViewer = document.getElementById('statusViewer');
            
            // Touch events for swipe
            statusViewer.addEventListener('touchstart', function(e) {
                touchStartX = e.changedTouches[0].screenX;
            });
            
            statusViewer.addEventListener('touchend', function(e) {
                touchEndX = e.changedTouches[0].screenX;
                handleSwipe();
            });
            
            // Click events for tap zones
            const swipeLeft = document.getElementById('swipeLeft');
            const swipeRight = document.getElementById('swipeRight');
            
            if (swipeLeft) {
                swipeLeft.addEventListener('click', function() {
                    navigateToPreviousStatus();
                });
            }
            
            if (swipeRight) {
                swipeRight.addEventListener('click', function() {
                    navigateToNextStatus();
                });
            }
            
            // Long press to pause
            let longPressTimer;
            statusViewer.addEventListener('touchstart', function(e) {
                longPressTimer = setTimeout(() => {
                    togglePause();
                }, 500);
            });
            
            statusViewer.addEventListener('touchend', function(e) {
                clearTimeout(longPressTimer);
            });
            
            statusViewer.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                togglePause();
            });
        }
        
        function handleSwipe() {
            const swipeThreshold = 50;
            const diff = touchStartX - touchEndX;
            
            if (Math.abs(diff) > swipeThreshold) {
                if (diff > 0) {
                    // Swipe left - next status
                    navigateToNextStatus();
                } else {
                    // Swipe right - previous status
                    navigateToPreviousStatus();
                }
            }
        }
        
        function navigateToNextStatus() {
            currentStatusIndex++;
            if (currentStatusIndex < userStatuses.length) {
                loadStatus(currentStatusIndex);
            } else {
                closeStatusViewer();
            }
        }
        
        function navigateToPreviousStatus() {
            if (currentStatusIndex > 0) {
                currentStatusIndex--;
                loadStatus(currentStatusIndex);
            }
        }
        
        function togglePause() {
            isPaused = !isPaused;
            pauseOverlay.classList.toggle('active');
            
            if (isPaused) {
                if (statusInterval) clearInterval(statusInterval);
            } else {
                startStatusTimer();
            }
        }
        
        function handleScreenshot() {
            if (statusViewer.classList.contains('active') && !screenshotDetected) {
                screenshotDetected = true;
                
                // Show screenshot overlay
                screenshotOverlay.classList.add('active');
                
                // Notify the status owner
                if (currentStatusUser && currentStatusUser !== currentUser.uid) {
                    notifyScreenshotToOwner(currentStatusUser, currentStatusId);
                }
                
                // Prevent multiple detections
                setTimeout(() => {
                    screenshotDetected = false;
                }, 5000);
            }
        }
        
        async function notifyScreenshotToOwner(userId, statusId) {
            try {
                // Get status data
                const statusDoc = await db.collection('statuses').doc(statusId).get();
                if (!statusDoc.exists) return;
                
                // Create notification in Firestore
                await db.collection('notifications').add({
                    type: 'screenshot',
                    fromUserId: currentUser.uid,
                    fromUserName: currentUser.displayName || 'Someone',
                    toUserId: userId,
                    statusId: statusId,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    read: false
                });
                
            } catch (error) {
                console.error('Error notifying screenshot:', error);
            }
        }
        
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        
        function selectTextColor(color) {
            const palette = document.getElementById('textColorPalette');
            if (!palette) return;
            
            palette.querySelectorAll('.color-option').forEach(opt => {
                opt.classList.remove('active');
                if (opt.dataset.color === color) {
                    opt.classList.add('active');
                }
            });
            
            const textEditor = document.getElementById('textEditor');
            if (textEditor) {
                textEditor.style.color = color;
            }
        }
        
        function selectBackgroundColor(color) {
            const palette = document.getElementById('backgroundColorPalette');
            if (!palette) return;
            
            palette.querySelectorAll('.color-option').forEach(opt => {
                opt.classList.remove('active');
                if (opt.dataset.color === color) {
                    opt.classList.add('active');
                }
            });
            
            const container = document.getElementById('textEditorContainer');
            if (container) {
                container.style.backgroundColor = color;
            }
        }
        
        function selectEmojiBackgroundColor(color) {
            const palette = document.getElementById('emojiBackgroundPalette');
            if (!palette) return;
            
            palette.querySelectorAll('.color-option').forEach(opt => {
                opt.classList.remove('active');
                if (opt.dataset.color === color) {
                    opt.classList.add('active');
                }
            });
            
            const container = document.getElementById('emojiOnlyContainer');
            if (container) {
                container.style.backgroundColor = color;
            }
        }
        
        function selectFont(font) {
            const options = document.getElementById('fontOptions');
            if (!options) return;
            
            options.querySelectorAll('.font-option').forEach(opt => {
                opt.classList.remove('active');
                if (opt.dataset.font === font) {
                    opt.classList.add('active');
                }
            });
            
            const textEditor = document.getElementById('textEditor');
            if (textEditor) {
                textEditor.style.fontFamily = font;
            }
        }
        
        function selectDrawingColor(color) {
            const colorsContainer = document.getElementById('drawingColors');
            if (!colorsContainer) return;
            
            colorsContainer.querySelectorAll('.drawing-color').forEach(opt => {
                opt.classList.remove('active');
                if (opt.dataset.color === color) {
                    opt.classList.add('active');
                }
            });
            
            if (fabricCanvas) {
                fabricCanvas.freeDrawingBrush.color = color;
            }
        }
        
        function selectBrushSize(size) {
            const brushesContainer = document.getElementById('drawingBrushes');
            if (!brushesContainer) return;
            
            brushesContainer.querySelectorAll('.drawing-brush').forEach(opt => {
                opt.classList.remove('active');
                if (opt.dataset.size == size) {
                    opt.classList.add('active');
                }
            });
            
            if (fabricCanvas) {
                fabricCanvas.freeDrawingBrush.width = parseInt(size);
            }
        }
        
        function showNotification(message, type = 'success') {
            const notificationText = document.getElementById('notificationText');
            if (notificationText) {
                notificationText.textContent = message;
            }
            
            if (notification) {
                notification.className = 'notification';
                notification.classList.add(type);
                notification.classList.add('active');
                
                setTimeout(() => {
                    notification.classList.remove('active');
                }, 3000);
            }
        }
        
        async function uploadToCloudinary(file) {
            return new Promise((resolve, reject) => {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);
                formData.append('cloud_name', CLOUDINARY_CLOUD_NAME);
                
                fetch(`https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/upload`, {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.secure_url) {
                        resolve(data.secure_url);
                    } else {
                        reject(new Error('Upload failed'));
                    }
                })
                .catch(error => {
                    reject(error);
                });
            });
        }
        
        async function deleteStatus(statusId) {
            try {
                if (!confirm('Are you sure you want to delete this status?')) {
                    return;
                }
                
                await db.collection('statuses').doc(statusId).delete();
                showNotification('Status deleted successfully', 'success');
                
                // Close modals
                statusInfoModal.classList.remove('active');
                closeStatusViewer();
                
                // Remove from cache
                cachedStatuses = cachedStatuses.filter(status => status.id !== statusId);
                localStorage.setItem(`cachedStatuses_${currentUser.uid}`, JSON.stringify(cachedStatuses));
                
                // Reload statuses
                updateStatusListWithCache();
                
            } catch (error) {
                console.error('Error deleting status:', error);
                showNotification('Failed to delete status', 'error');
            }
        }
        
        async function archiveStatus(statusId) {
            try {
                const statusDoc = await db.collection('statuses').doc(statusId).get();
                if (!statusDoc.exists) {
                    showNotification('Status not found', 'error');
                    return;
                }
                
                const statusData = statusDoc.data();
                archivedStatuses.push({
                    id: statusId,
                    ...statusData
                });
                
                localStorage.setItem(`archivedStatuses_${currentUser.uid}`, JSON.stringify(archivedStatuses));
                
                showNotification('Status archived', 'success');
                
            } catch (error) {
                console.error('Error archiving status:', error);
                showNotification('Failed to archive status', 'error');
            }
        }
        
        function restoreStatusFromArchive(statusId) {
            try {
                const index = archivedStatuses.findIndex(s => s.id === statusId);
                if (index !== -1) {
                    archivedStatuses.splice(index, 1);
                    localStorage.setItem(`archivedStatuses_${currentUser.uid}`, JSON.stringify(archivedStatuses));
                    showNotification('Status restored', 'success');
                    updateStatusListWithCache();
                }
            } catch (error) {
                console.error('Error restoring status:', error);
                showNotification('Failed to restore status', 'error');
            }
        }
        
        async function highlightStatus(statusId) {
            try {
                const statusDoc = await db.collection('statuses').doc(statusId).get();
                if (!statusDoc.exists) {
                    showNotification('Status not found', 'error');
                    return;
                }
                
                const statusData = statusDoc.data();
                
                // Check if already highlighted
                const isAlreadyHighlighted = highlightedStatuses.some(s => s.id === statusId);
                
                if (isAlreadyHighlighted) {
                    // Remove from highlights
                    highlightedStatuses = highlightedStatuses.filter(s => s.id !== statusId);
                    showNotification('Removed from highlights', 'success');
                } else {
                    // Add to highlights
                    highlightedStatuses.push({
                        id: statusId,
                        ...statusData
                    });
                    showNotification('Added to highlights', 'success');
                }
                
                localStorage.setItem(`highlightedStatuses_${currentUser.uid}`, JSON.stringify(highlightedStatuses));
                
                // Update button text
                const highlightBtn = document.getElementById('highlightStatusBtn');
                if (highlightBtn) {
                    highlightBtn.innerHTML = isAlreadyHighlighted ? 
                        '<i class="fas fa-star"><\/i> Unhighlight' : 
                        '<i class="fas fa-star"><\/i> Highlight';
                }
                
            } catch (error) {
                console.error('Error highlighting status:', error);
                showNotification('Failed to update highlights', 'error');
            }
        }
        
        async function shareStatus(statusId) {
            try {
                const statusDoc = await db.collection('statuses').doc(statusId).get();
                if (!statusDoc.exists) {
                    showNotification('Status not found', 'error');
                    return;
                }
                
                const statusData = statusDoc.data();
                
                // Create a shared status record
                await db.collection('shared_statuses').add({
                    originalStatusId: statusId,
                    originalUserId: statusData.userId,
                    sharedByUserId: currentUser.uid,
                    sharedByUserName: currentUser.displayName || 'User',
                    sharedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    statusType: statusData.type,
                    statusContent: statusData.content,
                    statusCaption: statusData.caption || '',
                    privacy: 'contacts'
                });
                
                showNotification('Status shared successfully', 'success');
                
            } catch (error) {
                console.error('Error sharing status:', error);
                showNotification('Failed to share status', 'error');
            }
        }
        
        async function openChatWithUser(userId) {
            try {
                const userDoc = await db.collection('users').doc(userId).get();
                if (!userDoc.exists) {
                    showNotification('User not found', 'error');
                    return;
                }
                
                const userData = userDoc.data();
                const chatId = [currentUser.uid, userId].sort().join('_');
                
                statusInfoModal.classList.remove('active');
                closeStatusViewer();
                
                window.location.href = `chat.html?chatId=${chatId}`;
                
            } catch (error) {
                console.error('Error opening chat:', error);
                showNotification('Failed to open chat', 'error');
            }
        }
        
        async function muteUser(userId) {
            try {
                if (!mutedUsers.includes(userId)) {
                    mutedUsers.push(userId);
                    saveMutedUsers();
                    showNotification('User muted', 'success');
                    updateStatusListWithCache();
                } else {
                    mutedUsers = mutedUsers.filter(id => id !== userId);
                    saveMutedUsers();
                    showNotification('User unmuted', 'success');
                    updateStatusListWithCache();
                }
            } catch (error) {
                console.error('Error muting user:', error);
                showNotification('Failed to mute user', 'error');
            }
        }
        
        async function voteOnPoll(statusId, optionIndex) {
            try {
                await db.collection('statuses').doc(statusId).update({
                    [`pollVotes.${currentUser.uid}`]: optionIndex
                });
                
                showNotification('Vote submitted!', 'success');
                
                // Reload the poll to show updated results
                const currentStatus = userStatuses[currentStatusIndex];
                if (currentStatus && currentStatus.id === statusId) {
                    loadPollStatus(currentStatus);
                }
                
            } catch (error) {
                console.error('Error voting on poll:', error);
                showNotification('Failed to submit vote', 'error');
            }
        }
        
        async function submitAnswer(statusId, answer) {
            try {
                await db.collection('statuses').doc(statusId).update({
                    answers: firebase.firestore.FieldValue.arrayUnion({
                        userId: currentUser.uid,
                        userName: currentUser.displayName || 'User',
                        answer: answer,
                        timestamp: new Date()
                    })
                });
                
            } catch (error) {
                console.error('Error submitting answer:', error);
            }
        }
        
        function playVoiceStatus(audioUrl) {
            // Implement audio playback
            const audio = new Audio(audioUrl);
            audio.play().catch(error => {
                console.error('Error playing audio:', error);
                showNotification('Failed to play voice message', 'error');
            });
        }
        
        function startVoiceRecording() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showNotification('Microphone access not available', 'error');
                return;
            }
            
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    
                    mediaRecorder.ondataavailable = event => {
                        audioChunks.push(event.data);
                    };
                    
                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        currentMediaFile = new File([audioBlob], 'voice-message.wav', { type: 'audio/wav' });
                        
                        // Show playback controls
                        const playback = document.getElementById('voicePlayback');
                        const duration = document.getElementById('recordingDuration');
                        if (playback) playback.style.display = 'flex';
                        if (duration) duration.textContent = `Recording: ${recordingTime}s`;
                        
                        // Stop all tracks
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    mediaRecorder.start();
                    isRecording = true;
                    recordingTime = 0;
                    
                    // Update recording timer
                    const timer = document.getElementById('recordingTimer');
                    recordingTimer = setInterval(() => {
                        recordingTime++;
                        if (timer) {
                            timer.textContent = 
                                `${Math.floor(recordingTime / 60).toString().padStart(2, '0')}:${(recordingTime % 60).toString().padStart(2, '0')}`;
                        }
                        
                        // Max 30 seconds
                        if (recordingTime >= 30) {
                            stopVoiceRecording();
                        }
                    }, 1000);
                    
                    // Update UI
                    const recordBtn = document.getElementById('recordBtn');
                    if (recordBtn) recordBtn.classList.add('recording');
                    
                })
                .catch(error => {
                    console.error('Error accessing microphone:', error);
                    showNotification('Microphone access denied', 'error');
                });
        }
        
        function stopVoiceRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                clearInterval(recordingTimer);
                const recordBtn = document.getElementById('recordBtn');
                if (recordBtn) recordBtn.classList.remove('recording');
            }
        }
        
        function getTimeAgo(date) {
            if (!date) return 'Just now';
            
            const now = new Date();
            const dateObj = new Date(date);
            const diffMs = now - dateObj;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return `${Math.floor(diffDays / 7)}w ago`;
        }
        
        // ============================================
        // EVENT LISTENERS SETUP
        // ============================================
        
        function setupEventListeners() {
            // New status button
            const newStatusBtn = document.getElementById('newStatusBtn');
            if (newStatusBtn) {
                newStatusBtn.addEventListener('click', () => {
                    createStatusModal.classList.add('active');
                    // Show AI suggestions
                    const aiSuggestions = document.getElementById('aiSuggestions');
                    if (aiSuggestions) aiSuggestions.style.display = 'block';
                    
                    // Show offline posting indicator if offline
                    if (offlinePostingIndicator) {
                        offlinePostingIndicator.style.display = isOnline ? 'none' : 'block';
                    }
                });
            }
            
            // My status item
            const myStatusItem = document.getElementById('myStatusItem');
            if (myStatusItem) {
                myStatusItem.addEventListener('click', () => {
                    createStatusModal.classList.add('active');
                    
                    // Show offline posting indicator if offline
                    if (offlinePostingIndicator) {
                        offlinePostingIndicator.style.display = isOnline ? 'none' : 'block';
                    }
                });
            }
            
            // Delete my status button
            const deleteMyStatusBtn = document.getElementById('deleteMyStatusBtn');
            if (deleteMyStatusBtn) {
                deleteMyStatusBtn.addEventListener('click', async () => {
                    const myStatuses = window.myCurrentStatuses;
                    if (myStatuses && myStatuses.length > 0) {
                        if (confirm(`Delete all ${myStatuses.length} of your status updates?`)) {
                            for (const status of myStatuses) {
                                await deleteStatus(status.id);
                            }
                            showNotification('All statuses deleted', 'success');
                            updateStatusListWithCache();
                        }
                    }
                });
            }
            
            // Archive my status button
            const archiveMyStatusBtn = document.getElementById('archiveMyStatusBtn');
            if (archiveMyStatusBtn) {
                archiveMyStatusBtn.addEventListener('click', async () => {
                    const myStatuses = window.myCurrentStatuses;
                    if (myStatuses && myStatuses.length > 0) {
                        for (const status of myStatuses) {
                            await archiveStatus(status.id);
                        }
                        showNotification('All statuses archived', 'success');
                        updateStatusListWithCache();
                    }
                });
            }
            
            // Close status viewer
            const closeStatusViewerBtn = document.getElementById('closeStatusViewer');
            if (closeStatusViewerBtn) {
                closeStatusViewerBtn.addEventListener('click', closeStatusViewer);
            }
            
            // Close create status modal
            const closeCreateStatusModal = document.getElementById('closeCreateStatusModal');
            if (closeCreateStatusModal) {
                closeCreateStatusModal.addEventListener('click', () => {
                    createStatusModal.classList.remove('active');
                    resetCreateStatusForm();
                });
            }
            
            const cancelStatusBtn = document.getElementById('cancelStatusBtn');
            if (cancelStatusBtn) {
                cancelStatusBtn.addEventListener('click', () => {
                    createStatusModal.classList.remove('active');
                    resetCreateStatusForm();
                });
            }
            
            // Status type tabs
            document.querySelectorAll('.create-status-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const type = this.dataset.type;
                    selectedStatusType = type;
                    
                    // Update active tab
                    document.querySelectorAll('.create-status-tab').forEach(t => {
                        t.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // Show corresponding container
                    document.querySelectorAll('.status-type-container').forEach(container => {
                        container.classList.remove('active');
                    });
                    const container = document.getElementById(`${type}StatusContainer`);
                    if (container) container.classList.add('active');
                    
                    // Show/hide additional options
                    const durationSelector = document.getElementById('durationSelector');
                    const scheduleContainer = document.getElementById('scheduleContainer');
                    
                    if (durationSelector) {
                        durationSelector.style.display = 
                            (type === 'text' || type === 'photo' || type === 'video') ? 'flex' : 'none';
                    }
                    
                    if (scheduleContainer) {
                        scheduleContainer.style.display = 
                            (type !== 'voice' && type !== 'poll' && type !== 'question') ? 'block' : 'none';
                    }
                    
                    // Show group content if group status
                    if (type === 'group') {
                        const groupStatusContent = document.getElementById('groupStatusContent');
                        if (groupStatusContent) {
                            groupStatusContent.style.display = 'block';
                            // Clone text status container to group content
                            const textContainer = document.getElementById('textStatusContainer');
                            if (textContainer) {
                                const clonedContainer = textContainer.cloneNode(true);
                                clonedContainer.id = 'groupTextStatusContainer';
                                groupStatusContent.innerHTML = '';
                                groupStatusContent.appendChild(clonedContainer);
                                initializeColorPalettes();
                                initializeFontOptions();
                            }
                        }
                    } else {
                        const groupStatusContent = document.getElementById('groupStatusContent');
                        if (groupStatusContent) groupStatusContent.style.display = 'none';
                    }
                });
            });
            
            // AI Suggestions
            document.querySelectorAll('.ai-suggestion').forEach(suggestion => {
                suggestion.addEventListener('click', function() {
                    const textEditor = document.getElementById('textEditor');
                    if (textEditor) textEditor.value = this.dataset.suggestion;
                });
            });
            
            // Text formatting buttons
            document.addEventListener('click', function(e) {
                if (e.target.closest('.text-tool-btn[data-format]')) {
                    const btn = e.target.closest('.text-tool-btn[data-format]');
                    const format = btn.dataset.format;
                    const textEditor = document.getElementById('textEditor');
                    
                    if (textEditor) {
                        const start = textEditor.selectionStart;
                        const end = textEditor.selectionEnd;
                        const selectedText = textEditor.value.substring(start, end);
                        
                        let formattedText = selectedText;
                        
                        switch(format) {
                            case 'bold':
                                formattedText = `**${selectedText}**`;
                                break;
                            case 'italic':
                                formattedText = `*${selectedText}*`;
                                break;
                            case 'strikethrough':
                                formattedText = `~~${selectedText}~~`;
                                break;
                            case 'monospace':
                                formattedText = `\`${selectedText}\``;
                                break;
                        }
                        
                        textEditor.value = textEditor.value.substring(0, start) + 
                                          formattedText + 
                                          textEditor.value.substring(end);
                        
                        btn.classList.toggle('active');
                    }
                }
            });
            
            // Open emoji picker
            const openEmojiPickerBtn = document.getElementById('openEmojiPickerBtn');
            if (openEmojiPickerBtn) {
                openEmojiPickerBtn.addEventListener('click', () => {
                    const picker = document.getElementById('emojiPickerContainer');
                    if (picker) picker.classList.toggle('active');
                });
            }
            
            // Photo upload
            const photoUploadArea = document.getElementById('photoUploadArea');
            if (photoUploadArea) {
                photoUploadArea.addEventListener('click', () => {
                    const photoInput = document.getElementById('photoUploadInput');
                    if (photoInput) photoInput.click();
                });
            }
            
            const photoUploadInput = document.getElementById('photoUploadInput');
            if (photoUploadInput) {
                photoUploadInput.addEventListener('change', function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const file = e.target.files[0];
                        currentMediaFile = file;
                        
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const photoPreview = document.getElementById('photoPreview');
                            const photoPreviewImg = document.getElementById('photoPreviewImg');
                            const photoEditTools = document.getElementById('photoEditTools');
                            
                            if (photoPreviewImg) photoPreviewImg.src = event.target.result;
                            if (photoPreview) photoPreview.classList.add('active');
                            if (photoEditTools) photoEditTools.style.display = 'flex';
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }
            
            // Video upload
            const videoUploadArea = document.getElementById('videoUploadArea');
            if (videoUploadArea) {
                videoUploadArea.addEventListener('click', () => {
                    const videoInput = document.getElementById('videoUploadInput');
                    if (videoInput) videoInput.click();
                });
            }
            
            const videoUploadInput = document.getElementById('videoUploadInput');
            if (videoUploadInput) {
                videoUploadInput.addEventListener('change', function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const file = e.target.files[0];
                        currentMediaFile = file;
                        
                        const video = document.createElement('video');
                        video.preload = 'metadata';
                        
                        video.onloadedmetadata = function() {
                            window.URL.revokeObjectURL(video.src);
                            
                            // Check video duration (max 30 seconds)
                            if (video.duration > 30) {
                                showNotification('Video must be 30 seconds or less', 'error');
                                const warning = document.getElementById('videoDurationWarning');
                                if (warning) warning.style.display = 'block';
                                currentMediaFile = null;
                                return;
                            }
                            
                            const videoPreview = document.getElementById('videoPreview');
                            const videoPreviewVideo = document.getElementById('videoPreviewVideo');
                            const videoEditTools = document.getElementById('videoEditTools');
                            
                            if (videoPreviewVideo) videoPreviewVideo.src = URL.createObjectURL(file);
                            if (videoPreview) videoPreview.classList.add('active');
                            if (videoEditTools) videoEditTools.style.display = 'flex';
                        };
                        
                        video.src = URL.createObjectURL(file);
                    }
                });
            }
            
            // Trim video button
            const trimVideoBtn = document.getElementById('trimVideoBtn');
            if (trimVideoBtn) {
                trimVideoBtn.addEventListener('click', () => {
                    const videoPreview = document.getElementById('videoPreviewVideo');
                    if (videoPreview && videoPreview.src) {
                        openVideoTrimmer(videoPreview.src);
                    }
                });
            }
            
            // Voice recording
            const recordBtn = document.getElementById('recordBtn');
            if (recordBtn) {
                recordBtn.addEventListener('click', function() {
                    if (isRecording) {
                        stopVoiceRecording();
                    } else {
                        startVoiceRecording();
                    }
                });
            }
            
            // Re-record button
            const rerecordBtn = document.getElementById('rerecordBtn');
            if (rerecordBtn) {
                rerecordBtn.addEventListener('click', function() {
                    const playback = document.getElementById('voicePlayback');
                    if (playback) playback.style.display = 'none';
                    currentMediaFile = null;
                    audioChunks = [];
                });
            }
            
            // Poll options
            const addPollOptionBtn = document.getElementById('addPollOptionBtn');
            if (addPollOptionBtn) {
                addPollOptionBtn.addEventListener('click', function() {
                    const container = document.getElementById('pollOptionsContainer');
                    if (container) {
                        const index = container.children.length;
                        const optionDiv = document.createElement('div');
                        optionDiv.className = 'poll-option';
                        optionDiv.innerHTML = `
                            <input type="text" class="poll-option-input" placeholder="Option ${index + 1}" data-index="${index}">
                        `;
                        container.appendChild(optionDiv);
                    }
                });
            }
            
            // Music selection
            document.querySelectorAll('.music-result').forEach(result => {
                result.addEventListener('click', function() {
                    const title = this.dataset.title;
                    const artist = this.dataset.artist;
                    
                    // Store selected music
                    window.selectedMusic = { title, artist };
                    
                    // Highlight selection
                    document.querySelectorAll('.music-result').forEach(r => {
                        r.style.background = 'none';
                    });
                    this.style.background = 'var(--secondary-color)';
                });
            });
            
            // Group selection
            document.querySelectorAll('.group-option').forEach(option => {
                option.addEventListener('click', function() {
                    selectedGroup = this.dataset.groupId;
                    
                    // Update selection
                    document.querySelectorAll('.group-option').forEach(opt => {
                        opt.classList.remove('active');
                    });
                    this.classList.add('active');
                });
            });
            
            // Draw button for photo
            const drawOnPhotoBtn = document.getElementById('drawOnPhotoBtn');
            if (drawOnPhotoBtn) {
                drawOnPhotoBtn.addEventListener('click', () => {
                    if (drawingCanvasContainer) {
                        drawingCanvasContainer.classList.add('active');
                        
                        const photoPreviewImg = document.getElementById('photoPreviewImg');
                        if (photoPreviewImg && photoPreviewImg.src && fabricCanvas) {
                            fabricCanvas.clear();
                            fabricCanvas.setBackgroundImage(photoPreviewImg.src, fabricCanvas.renderAll.bind(fabricCanvas), {
                                originX: 'left',
                                originY: 'top',
                                scaleX: fabricCanvas.width / photoPreviewImg.naturalWidth,
                                scaleY: fabricCanvas.height / photoPreviewImg.naturalHeight
                            });
                        }
                    }
                });
            }
            
            // Save drawing
            const saveDrawingBtn = document.getElementById('saveDrawingBtn');
            if (saveDrawingBtn) {
                saveDrawingBtn.addEventListener('click', () => {
                    if (fabricCanvas) {
                        const dataURL = fabricCanvas.toDataURL({
                            format: 'png',
                            quality: 1
                        });
                        
                        const photoPreviewImg = document.getElementById('photoPreviewImg');
                        if (photoPreviewImg) photoPreviewImg.src = dataURL;
                        
                        if (drawingCanvasContainer) drawingCanvasContainer.classList.remove('active');
                        
                        fetch(dataURL)
                            .then(res => res.blob())
                            .then(blob => {
                                currentMediaFile = new File([blob], 'edited-image.png', { type: 'image/png' });
                            });
                    }
                });
            }
            
            // Clear drawing
            const clearDrawingBtn = document.getElementById('clearDrawingBtn');
            if (clearDrawingBtn) {
                clearDrawingBtn.addEventListener('click', () => {
                    if (fabricCanvas) {
                        fabricCanvas.clear();
                        
                        const photoPreviewImg = document.getElementById('photoPreviewImg');
                        if (photoPreviewImg && photoPreviewImg.src) {
                            fabricCanvas.setBackgroundImage(photoPreviewImg.src, fabricCanvas.renderAll.bind(fabricCanvas), {
                                originX: 'left',
                                originY: 'top',
                                scaleX: fabricCanvas.width / photoPreviewImg.naturalWidth,
                                scaleY: fabricCanvas.height / photoPreviewImg.naturalHeight
                            });
                        }
                    }
                });
            }
            
            // Close drawing canvas
            if (drawingCanvasContainer) {
                drawingCanvasContainer.addEventListener('click', function(e) {
                    if (e.target === this) {
                        this.classList.remove('active');
                    }
                });
            }
            
            // Video trimmer
            let trimVideo = null;
            
            function openVideoTrimmer(videoSrc) {
                if (videoTrimmerContainer) {
                    videoTrimmerContainer.classList.add('active');
                    trimVideo = document.getElementById('trimVideoPreview');
                    if (trimVideo) {
                        trimVideo.src = videoSrc;
                        trimVideo.load();
                        
                        trimVideo.onloadedmetadata = function() {
                            const trimRange = document.getElementById('trimRange');
                            if (trimRange) trimRange.max = Math.floor(trimVideo.duration);
                            updateTrimTime();
                        };
                    }
                }
            }
            
            const trimRange = document.getElementById('trimRange');
            if (trimRange) {
                trimRange.addEventListener('input', function() {
                    if (trimVideo) {
                        trimVideo.currentTime = this.value;
                        updateTrimTime();
                    }
                });
            }
            
            const cancelTrimBtn = document.getElementById('cancelTrimBtn');
            if (cancelTrimBtn) {
                cancelTrimBtn.addEventListener('click', () => {
                    if (videoTrimmerContainer) videoTrimmerContainer.classList.remove('active');
                    trimVideo = null;
                });
            }
            
            const saveTrimBtn = document.getElementById('saveTrimBtn');
            if (saveTrimBtn) {
                saveTrimBtn.addEventListener('click', () => {
                    if (trimVideo) {
                        showNotification('Video trimmed successfully', 'success');
                        if (videoTrimmerContainer) videoTrimmerContainer.classList.remove('active');
                        trimVideo = null;
                    }
                });
            }
            
            function updateTrimTime() {
                if (trimVideo) {
                    const current = Math.floor(trimVideo.currentTime);
                    const total = Math.floor(trimVideo.duration);
                    const trimTime = document.getElementById('trimTime');
                    if (trimTime) {
                        trimTime.textContent = 
                            `${Math.floor(current / 60)}:${(current % 60).toString().padStart(2, '0')} / ${Math.floor(total / 60)}:${(total % 60).toString().padStart(2, '0')}`;
                    }
                }
            }
            
            // Duration selection - STATUSES NOW EXPIRE AFTER 24 HOURS (only 24h option)
            const durationSelector = document.getElementById('durationSelector');
            if (durationSelector) {
                durationSelector.innerHTML = '';
                const durationBtn = document.createElement('button');
                durationBtn.className = 'duration-btn active';
                durationBtn.dataset.hours = '24';
                durationBtn.textContent = '24h';
                durationBtn.addEventListener('click', function() {
                    selectedDuration = 24;
                    document.querySelectorAll('.duration-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    this.classList.add('active');
                });
                durationSelector.appendChild(durationBtn);
            }
            
            // Schedule input
            const scheduleInput = document.getElementById('scheduleInput');
            if (scheduleInput) {
                scheduleInput.addEventListener('change', function() {
                    scheduledTime = this.value;
                });
            }
            
            // Privacy button
            const privacyBtn = document.getElementById('privacyBtn');
            if (privacyBtn) {
                privacyBtn.addEventListener('click', () => {
                    if (privacyModal) privacyModal.classList.add('active');
                });
            }
            
            // Privacy options
            document.querySelectorAll('.privacy-option').forEach(option => {
                option.addEventListener('click', function() {
                    selectedPrivacy = this.dataset.privacy;
                    
                    document.querySelectorAll('.privacy-option').forEach(opt => {
                        opt.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    const privacyText = document.getElementById('privacyText');
                    if (privacyText) {
                        switch(selectedPrivacy) {
                            case 'contacts':
                                privacyText.textContent = 'My Contacts';
                                break;
                            case 'contacts-except':
                                privacyText.textContent = 'My Contacts Except...';
                                break;
                            case 'only-share':
                                privacyText.textContent = 'Only Share With...';
                                break;
                            case 'public':
                                privacyText.textContent = 'Public';
                                break;
                        }
                    }
                    
                    if (privacyModal) privacyModal.classList.remove('active');
                });
            });
            
            // Close privacy modal
            if (privacyModal) {
                privacyModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        this.classList.remove('active');
                    }
                });
            }
            
            // Post status button
            const postStatusBtn = document.getElementById('postStatusBtn');
            if (postStatusBtn) {
                postStatusBtn.addEventListener('click', async () => {
                    try {
                        let statusData = {
                            type: selectedStatusType,
                            privacy: selectedPrivacy,
                            mood: userMood || 'happy',
                            duration: selectedDuration // 24 hours
                        };
                        
                        if (selectedStatusType === 'text') {
                            const textEditor = document.getElementById('textEditor');
                            if (!textEditor) {
                                showNotification('Text editor not found', 'error');
                                return;
                            }
                            
                            const textContent = textEditor.value.trim();
                            if (!textContent) {
                                showNotification('Please enter status text', 'error');
                                return;
                            }
                            
                            statusData.content = textContent;
                            statusData.textColor = textEditor.style.color || '#ffffff';
                            const container = document.getElementById('textEditorContainer');
                            statusData.backgroundColor = container ? container.style.backgroundColor || '#0084ff' : '#0084ff';
                            statusData.font = textEditor.style.fontFamily || 'Segoe UI, sans-serif';
                            
                        } else if (selectedStatusType === 'emoji') {
                            statusData.content = selectedEmoji;
                            statusData.textColor = '#ffffff';
                            const container = document.getElementById('emojiOnlyContainer');
                            statusData.backgroundColor = container ? container.style.backgroundColor || '#0084ff' : '#0084ff';
                            statusData.font = 'Segoe UI, sans-serif';
                            
                        } else if (selectedStatusType === 'photo') {
                            if (!currentMediaFile) {
                                showNotification('Please select a photo', 'error');
                                return;
                            }
                            
                            showNotification('Processing photo...', 'success');
                            
                            // Convert to base64 for offline storage
                            const reader = new FileReader();
                            reader.onload = async function(event) {
                                statusData.content = event.target.result;
                                
                                const caption = document.getElementById('photoCaptionInput');
                                if (caption && caption.value.trim()) {
                                    statusData.caption = caption.value.trim();
                                }
                                
                                await saveStatusToFirestore(statusData);
                            };
                            reader.readAsDataURL(currentMediaFile);
                            return; // Early return since we're using async FileReader
                            
                        } else if (selectedStatusType === 'video') {
                            if (!currentMediaFile) {
                                showNotification('Please select a video', 'error');
                                return;
                            }
                            
                            showNotification('Processing video...', 'success');
                            
                            // Convert to base64 for offline storage
                            const reader = new FileReader();
                            reader.onload = async function(event) {
                                statusData.content = event.target.result;
                                
                                const caption = document.getElementById('videoCaptionInput');
                                if (caption && caption.value.trim()) {
                                    statusData.caption = caption.value.trim();
                                }
                                
                                await saveStatusToFirestore(statusData);
                            };
                            reader.readAsDataURL(currentMediaFile);
                            return; // Early return since we're using async FileReader
                            
                        } else if (selectedStatusType === 'voice') {
                            if (!currentMediaFile) {
                                showNotification('Please record a voice message', 'error');
                                return;
                            }
                            
                            showNotification('Processing voice message...', 'success');
                            
                            // Convert to base64 for offline storage
                            const reader = new FileReader();
                            reader.onload = async function(event) {
                                statusData.content = event.target.result;
                                statusData.duration = recordingTime;
                                
                                await saveStatusToFirestore(statusData);
                            };
                            reader.readAsDataURL(currentMediaFile);
                            return; // Early return since we're using async FileReader
                            
                        } else if (selectedStatusType === 'poll') {
                            const questionInput = document.getElementById('pollQuestionInput');
                            if (!questionInput) {
                                showNotification('Poll question input not found', 'error');
                                return;
                            }
                            
                            const question = questionInput.value.trim();
                            if (!question) {
                                showNotification('Please enter a poll question', 'error');
                                return;
                            }
                            
                            const options = [];
                            const optionInputs = document.querySelectorAll('#pollOptionsContainer .poll-option-input');
                            optionInputs.forEach(input => {
                                if (input.value.trim()) {
                                    options.push(input.value.trim());
                                }
                            });
                            
                            if (options.length < 2) {
                                showNotification('Please add at least 2 options', 'error');
                                return;
                            }
                            
                            statusData.pollQuestion = question;
                            statusData.pollOptions = options;
                            const activeColor = document.querySelector('#pollBackgroundPalette .color-option.active');
                            statusData.backgroundColor = activeColor ? activeColor.dataset.color || '#0084ff' : '#0084ff';
                            
                        } else if (selectedStatusType === 'question') {
                            const questionInput = document.getElementById('questionInput');
                            if (!questionInput) {
                                showNotification('Question input not found', 'error');
                                return;
                            }
                            
                            const question = questionInput.value.trim();
                            if (!question) {
                                showNotification('Please enter a question', 'error');
                                return;
                            }
                            
                            statusData.question = question;
                            const activeColor = document.querySelector('#questionBackgroundPalette .color-option.active');
                            statusData.backgroundColor = activeColor ? activeColor.dataset.color || '#ff9500' : '#ff9500';
                            
                        } else if (selectedStatusType === 'music') {
                            if (!window.selectedMusic) {
                                showNotification('Please select a music track', 'error');
                                return;
                            }
                            
                            statusData.musicTitle = window.selectedMusic.title;
                            statusData.musicArtist = window.selectedMusic.artist;
                            const activeColor = document.querySelector('#musicBackgroundPalette .color-option.active');
                            statusData.backgroundColor = activeColor ? activeColor.dataset.color || '#5856d6' : '#5856d6';
                            
                        } else if (selectedStatusType === 'group') {
                            if (!selectedGroup) {
                                showNotification('Please select a group', 'error');
                                return;
                            }
                            
                            // For group status, we need to get content from the embedded text editor
                            const groupTextEditor = document.querySelector('#groupTextStatusContainer #textEditor');
                            const textContent = groupTextEditor ? groupTextEditor.value.trim() : '';
                            
                            if (!textContent) {
                                showNotification('Please enter status text', 'error');
                                return;
                            }
                            
                            statusData.content = textContent;
                            statusData.textColor = groupTextEditor ? groupTextEditor.style.color : '#ffffff';
                            const container = document.querySelector('#groupTextStatusContainer #textEditorContainer');
                            statusData.backgroundColor = container ? container.style.backgroundColor : '#0084ff';
                            statusData.font = groupTextEditor ? groupTextEditor.style.fontFamily : 'Segoe UI, sans-serif';
                            statusData.groupId = selectedGroup;
                            statusData.type = 'text'; // Group statuses are text-based for now
                        }
                        
                        // Add group info if applicable
                        if (selectedGroup && selectedStatusType === 'group') {
                            const selectedGroupData = userGroups.find(g => g.id === selectedGroup);
                            if (selectedGroupData) {
                                statusData.groupName = selectedGroupData.name;
                                statusData.groupMembers = selectedGroupData.members;
                            }
                        }
                        
                        await saveStatusToFirestore(statusData);
                        
                        createStatusModal.classList.remove('active');
                        resetCreateStatusForm();
                        
                        if (!isOnline) {
                            showNotification('Status saved offline. Will upload when you\'re back online.', 'success');
                        } else if (scheduledTime) {
                            showNotification('Status scheduled!', 'success');
                        } else {
                            showNotification('Status posted successfully!', 'success');
                        }
                        
                        // Update UI
                        updateStatusListWithCache();
                        
                    } catch (error) {
                        console.error('Error posting status:', error);
                        showNotification('Failed to post status', 'error');
                    }
                });
            }
            
            // Status reply
            const statusReplyBtn = document.getElementById('statusReplyBtn');
            if (statusReplyBtn) {
                statusReplyBtn.addEventListener('click', () => {
                    const replyInput = document.getElementById('statusReplyInput');
                    if (replyInput) {
                        const replyText = replyInput.value.trim();
                        if (replyText) {
                            showNotification('Reply sent as direct message', 'success');
                            replyInput.value = '';
                            
                            // In a real app, this would send a message
                            console.log('Status reply:', replyText);
                        }
                    }
                });
            }
            
            // Share status button
            const shareStatusBtn = document.getElementById('shareStatusBtn');
            if (shareStatusBtn) {
                shareStatusBtn.addEventListener('click', () => {
                    if (currentStatusId) {
                        shareStatus(currentStatusId);
                    }
                });
            }
            
            // Mute user button
            const muteUserBtn = document.getElementById('muteUserBtn');
            if (muteUserBtn) {
                muteUserBtn.addEventListener('click', () => {
                    if (currentStatusUser) {
                        muteUser(currentStatusUser);
                    }
                });
            }
            
            // Highlight status button
            const highlightStatusBtn = document.getElementById('highlightStatusBtn');
            if (highlightStatusBtn) {
                highlightStatusBtn.addEventListener('click', () => {
                    if (currentStatusId) {
                        highlightStatus(currentStatusId);
                    }
                });
            }
            
            // Status info button
            const statusInfoBtn = document.getElementById('statusInfoBtn');
            if (statusInfoBtn) {
                statusInfoBtn.addEventListener('click', async () => {
                    if (userStatuses && userStatuses[currentStatusIndex]) {
                        const status = userStatuses[currentStatusIndex];
                        
                        const viewersList = document.getElementById('viewersList');
                        const statusInfoActions = document.getElementById('statusInfoActions');
                        const ownStatusActions = document.getElementById('ownStatusActions');
                        if (viewersList) viewersList.innerHTML = '';
                        
                        // Show appropriate actions
                        if (status.userId !== currentUser.uid) {
                            if (statusInfoActions) statusInfoActions.style.display = 'block';
                            if (ownStatusActions) ownStatusActions.style.display = 'none';
                            
                            const chatUserBtn = document.getElementById('chatUserBtn');
                            if (chatUserBtn) {
                                chatUserBtn.onclick = () => openChatWithUser(status.userId);
                            }
                            
                            const shareStatusInfoBtn = document.getElementById('shareStatusInfoBtn');
                            if (shareStatusInfoBtn) {
                                shareStatusInfoBtn.onclick = () => shareStatus(status.id);
                            }
                            
                            const muteStatusUserBtn = document.getElementById('muteStatusUserBtn');
                            if (muteStatusUserBtn) {
                                muteStatusUserBtn.onclick = () => {
                                    muteUser(status.userId);
                                    if (statusInfoModal) statusInfoModal.classList.remove('active');
                                };
                            }
                        } else {
                            if (statusInfoActions) statusInfoActions.style.display = 'none';
                            if (ownStatusActions) ownStatusActions.style.display = 'block';
                            
                            const deleteStatusBtn = document.getElementById('deleteStatusBtn');
                            if (deleteStatusBtn) {
                                deleteStatusBtn.onclick = () => deleteStatus(status.id);
                            }
                            
                            const editStatusBtn = document.getElementById('editStatusBtn');
                            if (editStatusBtn) {
                                editStatusBtn.onclick = () => {
                                    showNotification('Edit feature coming soon!', 'info');
                                };
                            }
                            
                            const highlightStatusActionBtn = document.getElementById('highlightStatusActionBtn');
                            if (highlightStatusActionBtn) {
                                highlightStatusActionBtn.onclick = () => {
                                    highlightStatus(status.id);
                                    if (statusInfoModal) statusInfoModal.classList.remove('active');
                                };
                            }
                            
                            const pinStatusBtn = document.getElementById('pinStatusBtn');
                            if (pinStatusBtn) {
                                pinStatusBtn.onclick = () => {
                                    showNotification('Status pinned!', 'success');
                                };
                            }
                        }
                        
                        // Fetch viewers from Firestore
                        try {
                            if (status.id && !status.tempId) {
                                const statusDoc = await db.collection('statuses').doc(status.id).get();
                                if (statusDoc.exists) {
                                    const viewers = statusDoc.data().viewers || [];
                                    const screenshotNotifications = statusDoc.data().screenshotNotifications || [];
                                    
                                    if (viewers.length > 0 && viewersList) {
                                        for (const viewerId of viewers) {
                                            if (viewerId === currentUser.uid) continue;
                                            
                                            const viewerDoc = await db.collection('users').doc(viewerId).get();
                                            if (viewerDoc.exists) {
                                                const viewerData = viewerDoc.data();
                                                const initials = viewerData.displayName ? 
                                                    viewerData.displayName.split(' ').map(word => word[0]).join('').toUpperCase().substring(0, 2) : 
                                                    'U';
                                                
                                                const viewerItem = document.createElement('div');
                                                viewerItem.className = 'viewer-item';
                                                
                                                // Check if this viewer took a screenshot
                                                const tookScreenshot = screenshotNotifications.some(notif => notif.userId === viewerId);
                                                
                                                viewerItem.innerHTML = `
                                                    <div class="viewer-avatar" ${viewerData.photoURL ? `style="background-image: url('${viewerData.photoURL}')"` : ''}>
                                                        ${viewerData.photoURL ? '' : `<span>${initials}<\/span>`}
                                                        ${tookScreenshot ? '<span style="position: absolute; bottom: -5px; right: -5px; background: var(--danger-color); color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 10px;"><i class="fas fa-camera"><\/i><\/span>' : ''}
                                                    <\/div>
                                                    <div class="viewer-info">
                                                        <div class="viewer-name">${viewerData.displayName || 'User'} ${tookScreenshot ? '<span style="color: var(--danger-color); font-size: 12px;">(took screenshot)<\/span>' : ''}<\/div>
                                                        <div class="viewer-time">Viewed recently<\/div>
                                                    <\/div>
                                                `;
                                                viewersList.appendChild(viewerItem);
                                            }
                                        }
                                        
                                        if (viewers.includes(currentUser.uid)) {
                                            const currentUserItem = document.createElement('div');
                                            currentUserItem.className = 'viewer-item';
                                            currentUserItem.innerHTML = `
                                                <div class="viewer-avatar" ${currentUser.photoURL ? `style="background-image: url('${currentUser.photoURL}')"` : ''}>
                                                    ${currentUser.photoURL ? '' : '<span>ME<\/span>'}
                                                <\/div>
                                                <div class="viewer-info">
                                                    <div class="viewer-name">You<\/div>
                                                    <div class="viewer-time">Viewed recently<\/div>
                                                <\/div>
                                            `;
                                            viewersList.appendChild(currentUserItem);
                                        }
                                    } else if (viewersList) {
                                        viewersList.innerHTML = `
                                            <div style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
                                                <i class="fas fa-eye" style="font-size: 48px; margin-bottom: 15px; opacity: 0.5;"><\/i>
                                                <p>No viewers yet<\/p>
                                            <\/div>
                                        `;
                                    }
                                }
                            } else if (viewersList) {
                                // For offline/pending statuses
                                viewersList.innerHTML = `
                                    <div style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
                                        <i class="fas fa-wifi-slash" style="font-size: 48px; margin-bottom: 15px; opacity: 0.5;"><\/i>
                                        <p>Viewer information unavailable offline<\/p>
                                    <\/div>
                                `;
                            }
                        } catch (error) {
                            console.error('Error loading viewers:', error);
                            if (viewersList) {
                                viewersList.innerHTML = `
                                    <div style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
                                        <i class="fas fa-exclamation-triangle" style="font-size: 48px; margin-bottom: 15px; opacity: 0.5;"><\/i>
                                        <p>Failed to load viewers<\/p>
                                    <\/div>
                                `;
                            }
                        }
                        
                        if (statusInfoModal) statusInfoModal.classList.add('active');
                    }
                });
            }
            
            // Close status info modal
            const closeStatusInfoModal = document.getElementById('closeStatusInfoModal');
            if (closeStatusInfoModal) {
                closeStatusInfoModal.addEventListener('click', () => {
                    if (statusInfoModal) statusInfoModal.classList.remove('active');
                });
            }
            
            if (statusInfoModal) {
                statusInfoModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        this.classList.remove('active');
                    }
                });
            }
            
            // Close screenshot overlay
            const closeScreenshotOverlay = document.getElementById('closeScreenshotOverlay');
            if (closeScreenshotOverlay) {
                closeScreenshotOverlay.addEventListener('click', () => {
                    if (screenshotOverlay) screenshotOverlay.classList.remove('active');
                });
            }
            
            // Emoji reactions
            document.querySelectorAll('.emoji-reaction').forEach(reaction => {
                reaction.addEventListener('click', function() {
                    const emoji = this.dataset.emoji;
                    
                    if (userStatuses && userStatuses[currentStatusIndex]) {
                        const statusId = userStatuses[currentStatusIndex].id;
                        
                        if (statusId && !userStatuses[currentStatusIndex].tempId) {
                            // Save reaction locally for offline sync
                            const offlineReactions = JSON.parse(localStorage.getItem(`offlineReactions_${currentUser.uid}`) || '{}');
                            offlineReactions[statusId] = emoji;
                            localStorage.setItem(`offlineReactions_${currentUser.uid}`, JSON.stringify(offlineReactions));
                            
                            if (isOnline) {
                                db.collection('statuses').doc(statusId).update({
                                    [`reactions.${currentUser.uid}`]: emoji
                                }).then(() => {
                                    showNotification(`Reacted with ${emoji}`, 'success');
                                }).catch(error => {
                                    console.error('Error saving reaction:', error);
                                });
                            } else {
                                showNotification(`Reacted with ${emoji} (offline)`, 'success');
                            }
                        }
                    }
                });
            });
            
            // Category tabs
            document.querySelectorAll('.category-btn').forEach(tab => {
                tab.addEventListener('click', function() {
                    const category = this.id.replace('Tab', '');
                    currentCategory = category;
                    
                    // Update active tab
                    document.querySelectorAll('.category-btn').forEach(t => {
                        t.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // Update section title
                    const sectionTitle = document.getElementById('sectionTitle');
                    if (sectionTitle) {
                        switch(category) {
                            case 'recent':
                                sectionTitle.textContent = 'Recent Updates';
                                break;
                            case 'viewed':
                                sectionTitle.textContent = 'Viewed Updates';
                                break;
                            case 'muted':
                                sectionTitle.textContent = 'Muted Users';
                                break;
                            case 'archive':
                                sectionTitle.textContent = 'Archived Statuses';
                                break;
                            case 'highlights':
                                sectionTitle.textContent = 'Highlights';
                                break;
                        }
                    }
                    
                    // Update the status list
                    updateStatusListWithCache();
                });
            });
        }
        
        function resetCreateStatusForm() {
            // Reset text editor
            const textEditor = document.getElementById('textEditor');
            if (textEditor) textEditor.value = '';
            
            // Reset emoji
            selectedEmoji = '';
            const emojiOnlyDisplay = document.getElementById('emojiOnlyDisplay');
            if (emojiOnlyDisplay) emojiOnlyDisplay.textContent = selectedEmoji;
            
            // Reset media previews
            const photoPreview = document.getElementById('photoPreview');
            if (photoPreview) photoPreview.classList.remove('active');
            
            const videoPreview = document.getElementById('videoPreview');
            if (videoPreview) videoPreview.classList.remove('active');
            
            // Hide edit tools
            const photoEditTools = document.getElementById('photoEditTools');
            if (photoEditTools) photoEditTools.style.display = 'none';
            
            const videoEditTools = document.getElementById('videoEditTools');
            if (videoEditTools) videoEditTools.style.display = 'none';
            
            // Reset voice recording
            const voicePlayback = document.getElementById('voicePlayback');
            if (voicePlayback) voicePlayback.style.display = 'none';
            currentMediaFile = null;
            audioChunks = [];
            isRecording = false;
            recordingTime = 0;
            clearInterval(recordingTimer);
            const recordBtn = document.getElementById('recordBtn');
            if (recordBtn) recordBtn.classList.remove('recording');
            
            // Reset poll
            const pollQuestionInput = document.getElementById('pollQuestionInput');
            if (pollQuestionInput) pollQuestionInput.value = '';
            
            const pollOptionsContainer = document.getElementById('pollOptionsContainer');
            if (pollOptionsContainer) {
                pollOptionsContainer.innerHTML = `
                    <div class="poll-option">
                        <input type="text" class="poll-option-input" placeholder="Option 1" data-index="0">
                    <\/div>
                    <div class="poll-option">
                        <input type="text" class="poll-option-input" placeholder="Option 2" data-index="1">
                    <\/div>
                `;
            }
            
            // Reset question
            const questionInput = document.getElementById('questionInput');
            if (questionInput) questionInput.value = '';
            
            // Reset music selection
            window.selectedMusic = null;
            const musicResults = document.getElementById('musicResults');
            if (musicResults) {
                musicResults.querySelectorAll('.music-result').forEach(r => {
                    r.style.background = 'none';
                });
            }
            
            // Reset group selection
            selectedGroup = null;
            const groupOptions = document.querySelectorAll('.group-option');
            groupOptions.forEach(opt => {
                opt.classList.remove('active');
            });
            
            // Reset scheduled time
            scheduledTime = null;
            const scheduleInput = document.getElementById('scheduleInput');
            if (scheduleInput) scheduleInput.value = '';
        }
    </script>
</body>
</html>